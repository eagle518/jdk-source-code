// @(#)ia64.ad	1.114 04/07/29 16:36:05
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// SUN PROPRIETARY/CONFIDENTIAL.  Use is subject to license terms.
//

// IA64 Architecture Description File

//----------REGISTER DEFINITION BLOCK------------------------------------------
// This information is used by the matcher and the register allocator to
// describe individual registers and classes of registers within the target
// archtecture.
register %{
//----------Architecture Description Register Definitions----------------------
// General Registers
// "reg_def"  name ( register save type, C convention save type, 
//                   ideal register type, encoding );
// Register Save Types:
// 
// NS  = No-Save:       The register allocator assumes that these registers
//                      can be used without saving upon entry to the method, &
//                      that they do not need to be saved at call sites.
// 
// SOC = Save-On-Call:  The register allocator assumes that these registers
//                      can be used without saving upon entry to the method,
//                      but that they must be saved at call sites.
// 
// SOE = Save-On-Entry: The register allocator assumes that these registers
//                      must be saved before using them upon entry to the
//                      method, but they do not need to be saved at call
//                      sites.
// 
// AS  = Always-Save:   The register allocator assumes that these registers
//                      must be saved before using them upon entry to the
//                      method, & that they must be saved at call sites.
//
// Ideal Register Type is used to determine how to save & restore a 
// register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
// spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
// 
// The encoding number is the actual bit-pattern placed into the opcodes.


// Integer/Long Registers
// each of these registers is 64 bits long, but also has an additional
// NATS bit indicating if the data is valid
reg_def GR0H  (NS,  NS,  Op_RegI, 128);  // Integer constant 0
reg_def GR0   (NS,  NS,  Op_RegI,   0);
reg_def GR1_GPH(SOC,SOC, Op_RegI, 129);  // Global Data Pointer (gp)
reg_def GR1_GP (SOC,SOC, Op_RegI,   1);
reg_def GR2H  (SOC, SOC, Op_RegI, 130);  // Scratch for 22 bit immediate add
reg_def GR2   (SOC, SOC, Op_RegI,   2);
reg_def GR3H  (SOC, SOC, Op_RegI, 131);  // Scratch for 22 bit immediate add
reg_def GR3   (SOC, SOC, Op_RegI,   3);
reg_def GR4_TLSH(NS, NS, Op_RegI, 132);  // VM Thread Pointer (tls)
reg_def GR4_TLS (NS, NS, Op_RegI,   4);
reg_def GR5H  (SOE, SOE, Op_RegI, 133);  // Preserved
reg_def GR5   (SOE, SOE, Op_RegI,   5);
reg_def GR6H  (SOE, SOE, Op_RegI, 134);  // Preserved
reg_def GR6   (SOE, SOE, Op_RegI,   6);
reg_def GR7H  (SOE, SOE, Op_RegI, 135);  // Preserved
reg_def GR7   (SOE, SOE, Op_RegI,   7);
reg_def GR8_RETH(SOC,SOC,Op_RegI, 136);  // Return Value
reg_def GR8_RET (SOC,SOC,Op_RegI,   8);
reg_def GR9H  (SOC, SOC, Op_RegI, 137);  // Return Value (if size >  8 bytes)
reg_def GR9   (SOC, SOC, Op_RegI,   9);
reg_def GR10H (SOC, SOC, Op_RegI, 138);  // Return Value (if size > 16 bytes)
reg_def GR10  (SOC, SOC, Op_RegI,  10);
reg_def GR11H (SOC, SOC, Op_RegI, 139);  // Return Value (if size > 24 bytes)
reg_def GR11  (SOC, SOC, Op_RegI,  11);
reg_def GR12_SPH(NS, NS, Op_RegI, 140);  // Stack Pointer (sp)
reg_def GR12_SP (NS, NS, Op_RegI,  12);
reg_def GR13H (SOC, SOC, Op_RegI, 141);  // OS-reserved Thread pointer
reg_def GR13  (SOC, SOC, Op_RegI,  13);
reg_def GR14H (SOC, SOC, Op_RegI, 142);
reg_def GR14  (SOC, SOC, Op_RegI,  14);
reg_def GR15H (SOC, SOC, Op_RegI, 143);
reg_def GR15  (SOC, SOC, Op_RegI,  15);
reg_def GR16H (SOC, SOC, Op_RegI, 144);
reg_def GR16  (SOC, SOC, Op_RegI,  16);
reg_def GR17H (SOC, SOC, Op_RegI, 145);
reg_def GR17  (SOC, SOC, Op_RegI,  17);
reg_def GR18H (SOC, SOC, Op_RegI, 146);
reg_def GR18  (SOC, SOC, Op_RegI,  18);
reg_def GR19H (SOC, SOC, Op_RegI, 147);
reg_def GR19  (SOC, SOC, Op_RegI,  19);
reg_def GR20H (SOC, SOC, Op_RegI, 148);
reg_def GR20  (SOC, SOC, Op_RegI,  20);
reg_def GR21H (SOC, SOC, Op_RegI, 149);
reg_def GR21  (SOC, SOC, Op_RegI,  21);
reg_def GR22H (SOC, SOC, Op_RegI, 150);
reg_def GR22  (SOC, SOC, Op_RegI,  22);
reg_def GR23H (SOC, SOC, Op_RegI, 151);
reg_def GR23  (SOC, SOC, Op_RegI,  23);
reg_def GR24H (SOC, SOC, Op_RegI, 152);
reg_def GR24  (SOC, SOC, Op_RegI,  24);
reg_def GR25H (SOC, SOC, Op_RegI, 153);
reg_def GR25  (SOC, SOC, Op_RegI,  25);
reg_def GR26H (SOC, SOC, Op_RegI, 154);
reg_def GR26  (SOC, SOC, Op_RegI,  26);
reg_def GR27H (SOC, SOC, Op_RegI, 155);
reg_def GR27  (SOC, SOC, Op_RegI,  27);
reg_def GR28H (SOC, SOC, Op_RegI, 156);  // Used as scratch
reg_def GR28  (SOC, SOC, Op_RegI,  28);
reg_def GR29H (NS,  NS,  Op_RegI, 157);  // Used as scratch (SP + offset)
reg_def GR29  (NS,  NS,  Op_RegI,  29);
reg_def GR30H (NS,  NS,  Op_RegI, 158);
reg_def GR30  (NS,  NS,  Op_RegI,  30);
reg_def GR31H (SOC, SOC, Op_RegI, 159);
reg_def GR31  (SOC, SOC, Op_RegI,  31);
reg_def I0H   (NS,  NS,  Op_RegI, 160);  // Kludge - start of input registers
reg_def I0    (NS,  NS,  Op_RegI,  32);
reg_def I1H   (NS,  NS,  Op_RegI, 161);
reg_def I1    (NS,  NS,  Op_RegI,  33);
reg_def I2H   (NS,  NS,  Op_RegI, 162);
reg_def I2    (NS,  NS,  Op_RegI,  34);
reg_def I3H   (NS,  NS,  Op_RegI, 163);
reg_def I3    (NS,  NS,  Op_RegI,  35);
reg_def I4H   (NS,  NS,  Op_RegI, 164);
reg_def I4    (NS,  NS,  Op_RegI,  36);
reg_def I5H   (NS,  NS,  Op_RegI, 165);
reg_def I5    (NS,  NS,  Op_RegI,  37);
reg_def I6H   (NS,  NS,  Op_RegI, 166);
reg_def I6    (NS,  NS,  Op_RegI,  38);
reg_def I7H   (NS,  NS,  Op_RegI, 167);
reg_def I7    (NS,  NS,  Op_RegI,  39);
reg_def L0H   (NS,  NS,  Op_RegI, 168);  // Kludge - start of local registers
reg_def L0    (NS,  NS,  Op_RegI,  40);
reg_def L1H   (NS,  NS,  Op_RegI, 169);
reg_def L1    (NS,  NS,  Op_RegI,  41);
reg_def L2H   (NS,  NS,  Op_RegI, 170);
reg_def L2    (NS,  NS,  Op_RegI,  42);
reg_def L3H   (NS,  NS,  Op_RegI, 171);
reg_def L3    (NS,  NS,  Op_RegI,  43);
reg_def L4H   (NS,  NS,  Op_RegI, 172);
reg_def L4    (NS,  NS,  Op_RegI,  44);
reg_def L5H   (NS,  NS,  Op_RegI, 173);
reg_def L5    (NS,  NS,  Op_RegI,  45);
reg_def L6H   (NS,  NS,  Op_RegI, 174);
reg_def L6    (NS,  NS,  Op_RegI,  46);
reg_def L7H   (NS,  NS,  Op_RegI, 175);
reg_def L7    (NS,  NS,  Op_RegI,  47);
reg_def L8H   (NS,  NS,  Op_RegI, 176);
reg_def L8    (NS,  NS,  Op_RegI,  48);
reg_def L9H   (NS,  NS,  Op_RegI, 177);
reg_def L9    (NS,  NS,  Op_RegI,  49);
reg_def L10H  (NS,  NS,  Op_RegI, 178);
reg_def L10   (NS,  NS,  Op_RegI,  50);
reg_def L11H  (NS,  NS,  Op_RegI, 179);
reg_def L11   (NS,  NS,  Op_RegI,  51);
reg_def L12H  (NS,  NS,  Op_RegI, 180);
reg_def L12   (NS,  NS,  Op_RegI,  52);
reg_def L13H  (NS,  NS,  Op_RegI, 181);
reg_def L13   (NS,  NS,  Op_RegI,  53);
reg_def L14H  (NS,  NS,  Op_RegI, 182);
reg_def L14   (NS,  NS,  Op_RegI,  54);
reg_def L15H  (NS,  NS,  Op_RegI, 183);
reg_def L15   (NS,  NS,  Op_RegI,  55);
reg_def O0H   (SOC, SOC, Op_RegI, 184);  // Kludge - start of output registers
reg_def O0    (SOC, SOC, Op_RegI,  56);
reg_def O1H   (SOC, SOC, Op_RegI, 185);
reg_def O1    (SOC, SOC, Op_RegI,  57);
reg_def O2H   (SOC, SOC, Op_RegI, 186);
reg_def O2    (SOC, SOC, Op_RegI,  58);
reg_def O3H   (SOC, SOC, Op_RegI, 187);
reg_def O3    (SOC, SOC, Op_RegI,  59);
reg_def O4H   (SOC, SOC, Op_RegI, 188);
reg_def O4    (SOC, SOC, Op_RegI,  60);
reg_def O5H   (SOC, SOC, Op_RegI, 189);
reg_def O5    (SOC, SOC, Op_RegI,  61);
reg_def O6H   (SOC, SOC, Op_RegI, 190);
reg_def O6    (SOC, SOC, Op_RegI,  62);
reg_def O7H   (SOC, SOC, Op_RegI, 191);
reg_def O7    (SOC, SOC, Op_RegI,  63);
reg_def GR64H (NS,  NS,  Op_RegI, 192);
reg_def GR64  (NS,  NS,  Op_RegI,  64);
reg_def GR65H (NS,  NS,  Op_RegI, 193);
reg_def GR65  (NS,  NS,  Op_RegI,  65);
reg_def GR66H (NS,  NS,  Op_RegI, 194);
reg_def GR66  (NS,  NS,  Op_RegI,  66);
reg_def GR67H (NS,  NS,  Op_RegI, 195);
reg_def GR67  (NS,  NS,  Op_RegI,  67);
reg_def GR68H (NS,  NS,  Op_RegI, 196);
reg_def GR68  (NS,  NS,  Op_RegI,  68);
reg_def GR69H (NS,  NS,  Op_RegI, 197);
reg_def GR69  (NS,  NS,  Op_RegI,  69);
reg_def GR70H (NS,  NS,  Op_RegI, 198);
reg_def GR70  (NS,  NS,  Op_RegI,  70);
reg_def GR71H (NS,  NS,  Op_RegI, 199);
reg_def GR71  (NS,  NS,  Op_RegI,  71);
reg_def GR72H (NS,  NS,  Op_RegI, 200);
reg_def GR72  (NS,  NS,  Op_RegI,  72);
reg_def GR73H (NS,  NS,  Op_RegI, 201);
reg_def GR73  (NS,  NS,  Op_RegI,  73);
reg_def GR74H (NS,  NS,  Op_RegI, 202);
reg_def GR74  (NS,  NS,  Op_RegI,  74);
reg_def GR75H (NS,  NS,  Op_RegI, 203);
reg_def GR75  (NS,  NS,  Op_RegI,  75);
reg_def GR76H (NS,  NS,  Op_RegI, 204);
reg_def GR76  (NS,  NS,  Op_RegI,  76);
reg_def GR77H (NS,  NS,  Op_RegI, 205);
reg_def GR77  (NS,  NS,  Op_RegI,  77);
reg_def GR78H (NS,  NS,  Op_RegI, 206);
reg_def GR78  (NS,  NS,  Op_RegI,  78);
reg_def GR79H (NS,  NS,  Op_RegI, 207);
reg_def GR79  (NS,  NS,  Op_RegI,  79);
reg_def GR80H (NS,  NS,  Op_RegI, 208);
reg_def GR80  (NS,  NS,  Op_RegI,  80);
reg_def GR81H (NS,  NS,  Op_RegI, 209);
reg_def GR81  (NS,  NS,  Op_RegI,  81);
reg_def GR82H (NS,  NS,  Op_RegI, 210);
reg_def GR82  (NS,  NS,  Op_RegI,  82);
reg_def GR83H (NS,  NS,  Op_RegI, 211);
reg_def GR83  (NS,  NS,  Op_RegI,  83);
reg_def GR84H (NS,  NS,  Op_RegI, 212);
reg_def GR84  (NS,  NS,  Op_RegI,  84);
reg_def GR85H (NS,  NS,  Op_RegI, 213);
reg_def GR85  (NS,  NS,  Op_RegI,  85);
reg_def GR86H (NS,  NS,  Op_RegI, 214);
reg_def GR86  (NS,  NS,  Op_RegI,  86);
reg_def GR87H (NS,  NS,  Op_RegI, 215);
reg_def GR87  (NS,  NS,  Op_RegI,  87);
reg_def GR88H (NS,  NS,  Op_RegI, 216);
reg_def GR88  (NS,  NS,  Op_RegI,  88);
reg_def GR89H (NS,  NS,  Op_RegI, 217);
reg_def GR89  (NS,  NS,  Op_RegI,  89);
reg_def GR90H (NS,  NS,  Op_RegI, 218);
reg_def GR90  (NS,  NS,  Op_RegI,  90);
reg_def GR91H (NS,  NS,  Op_RegI, 219);
reg_def GR91  (NS,  NS,  Op_RegI,  91);
reg_def GR92H (NS,  NS,  Op_RegI, 220);
reg_def GR92  (NS,  NS,  Op_RegI,  92);
reg_def GR93H (NS,  NS,  Op_RegI, 221);
reg_def GR93  (NS,  NS,  Op_RegI,  93);
reg_def GR94H (NS,  NS,  Op_RegI, 222);
reg_def GR94  (NS,  NS,  Op_RegI,  94);
reg_def GR95H (NS,  NS,  Op_RegI, 223);
reg_def GR95  (NS,  NS,  Op_RegI,  95);
reg_def GR96H (NS,  NS,  Op_RegI, 224);
reg_def GR96  (NS,  NS,  Op_RegI,  96);
reg_def GR97H (NS,  NS,  Op_RegI, 225);
reg_def GR97  (NS,  NS,  Op_RegI,  97);
reg_def GR98H (NS,  NS,  Op_RegI, 226);
reg_def GR98  (NS,  NS,  Op_RegI,  98);
reg_def GR99H (NS,  NS,  Op_RegI, 227);
reg_def GR99  (NS,  NS,  Op_RegI,  99);
reg_def GR100H(NS,  NS,  Op_RegI, 228);
reg_def GR100 (NS,  NS,  Op_RegI, 100);
reg_def GR101H(NS,  NS,  Op_RegI, 229);
reg_def GR101 (NS,  NS,  Op_RegI, 101);
reg_def GR102H(NS,  NS,  Op_RegI, 230);
reg_def GR102 (NS,  NS,  Op_RegI, 102);
reg_def GR103H(NS,  NS,  Op_RegI, 231);
reg_def GR103 (NS,  NS,  Op_RegI, 103);
reg_def GR104H(NS,  NS,  Op_RegI, 232);
reg_def GR104 (NS,  NS,  Op_RegI, 104);
reg_def GR105H(NS,  NS,  Op_RegI, 233);
reg_def GR105 (NS,  NS,  Op_RegI, 105);
reg_def GR106H(NS,  NS,  Op_RegI, 234);
reg_def GR106 (NS,  NS,  Op_RegI, 106);
reg_def GR107H(NS,  NS,  Op_RegI, 235);
reg_def GR107 (NS,  NS,  Op_RegI, 107);
reg_def GR108H(NS,  NS,  Op_RegI, 236);
reg_def GR108 (NS,  NS,  Op_RegI, 108);
reg_def GR109H(NS,  NS,  Op_RegI, 237);
reg_def GR109 (NS,  NS,  Op_RegI, 109);
reg_def GR110H(NS,  NS,  Op_RegI, 238);
reg_def GR110 (NS,  NS,  Op_RegI, 110);
reg_def GR111H(NS,  NS,  Op_RegI, 239);
reg_def GR111 (NS,  NS,  Op_RegI, 111);
reg_def GR112H(NS,  NS,  Op_RegI, 240);
reg_def GR112 (NS,  NS,  Op_RegI, 112);
reg_def GR113H(NS,  NS,  Op_RegI, 241);
reg_def GR113 (NS,  NS,  Op_RegI, 113);
reg_def GR114H(NS,  NS,  Op_RegI, 242);
reg_def GR114 (NS,  NS,  Op_RegI, 114);
reg_def GR115H(NS,  NS,  Op_RegI, 243);
reg_def GR115 (NS,  NS,  Op_RegI, 115);
reg_def GR116H(NS,  NS,  Op_RegI, 244);
reg_def GR116 (NS,  NS,  Op_RegI, 116);
reg_def GR117H(NS,  NS,  Op_RegI, 245);
reg_def GR117 (NS,  NS,  Op_RegI, 117);
reg_def GR118H(NS,  NS,  Op_RegI, 246);
reg_def GR118 (NS,  NS,  Op_RegI, 118);
reg_def GR119H(NS,  NS,  Op_RegI, 247);
reg_def GR119 (NS,  NS,  Op_RegI, 119);
reg_def GR120H(NS,  NS,  Op_RegI, 248);
reg_def GR120 (NS,  NS,  Op_RegI, 120);
reg_def GR121H(NS,  NS,  Op_RegI, 249);
reg_def GR121 (NS,  NS,  Op_RegI, 121);
reg_def GR122H(NS,  NS,  Op_RegI, 250);
reg_def GR122 (NS,  NS,  Op_RegI, 122);
reg_def GR123H(NS,  NS,  Op_RegI, 251);
reg_def GR123 (NS,  NS,  Op_RegI, 123);
reg_def GR124H(NS,  NS,  Op_RegI, 252);
reg_def GR124 (NS,  NS,  Op_RegI, 124);
reg_def GR125H(NS,  NS,  Op_RegI, 253);
reg_def GR125 (NS,  NS,  Op_RegI, 125);
reg_def GR126H(NS,  NS,  Op_RegI, 254);
reg_def GR126 (NS,  NS,  Op_RegI, 126);
reg_def GR127H(NS,  NS,  Op_RegI, 255);
reg_def GR127 (NS,  NS,  Op_RegI, 127);

// Floating Point Registers
// Each of these registers is 82 bits long, and can represent a
// float, double, or extended value.
reg_def FR0H  (NS,  NS,  Op_RegF, 128);  // Floating-point constant 0.0
reg_def FR0   (NS,  NS,  Op_RegF,   0);
reg_def FR1H  (NS,  NS,  Op_RegF, 129);  // Floating-point constant 1.0
reg_def FR1   (NS,  NS,  Op_RegF,   1);
reg_def FR2H  (SOE, SOE, Op_RegF, 130);  // Preserved
reg_def FR2   (SOE, SOE, Op_RegF,   2);
reg_def FR3H  (SOE, SOE, Op_RegF, 131);  // Preserved
reg_def FR3   (SOE, SOE, Op_RegF,   3);
reg_def FR4H  (SOE, SOE, Op_RegF, 132);  // Preserved
reg_def FR4   (SOE, SOE, Op_RegF,   4);
reg_def FR5H  (SOE, SOE, Op_RegF, 133);  // Preserved
reg_def FR5   (SOE, SOE, Op_RegF,   5);
reg_def FR6H  (SOC, SOC, Op_RegF, 134);  // Scratch
reg_def FR6   (SOC, SOC, Op_RegF,   6);
reg_def FR7H  (SOC, SOC, Op_RegF, 135);  // Scratch
reg_def FR7   (SOC, SOC, Op_RegF,   7);
reg_def FR8H  (SOC, SOC, Op_RegF, 136);  // Argument/Return Value
reg_def FR8   (SOC, SOC, Op_RegF,   8);
reg_def FR9H  (SOC, SOC, Op_RegF, 137);  // Argument/Return Value
reg_def FR9   (SOC, SOC, Op_RegF,   9);
reg_def FR10H (SOC, SOC, Op_RegF, 138);  // Argument/Return Value
reg_def FR10  (SOC, SOC, Op_RegF,  10);
reg_def FR11H (SOC, SOC, Op_RegF, 139);  // Argument/Return Value
reg_def FR11  (SOC, SOC, Op_RegF,  11);
reg_def FR12H (SOC, SOC, Op_RegF, 140);  // Argument/Return Value
reg_def FR12  (SOC, SOC, Op_RegF,  12);
reg_def FR13H (SOC, SOC, Op_RegF, 141);  // Argument/Return Value
reg_def FR13  (SOC, SOC, Op_RegF,  13);
reg_def FR14H (SOC, SOC, Op_RegF, 142);  // Argument/Return Value
reg_def FR14  (SOC, SOC, Op_RegF,  14);
reg_def FR15H (SOC, SOC, Op_RegF, 143);  // Argument/Return Value
reg_def FR15  (SOC, SOC, Op_RegF,  15);
reg_def FR16H (SOE, SOE, Op_RegF, 144);  // Preserved
reg_def FR16  (SOE, SOE, Op_RegF,  16);
reg_def FR17H (SOE, SOE, Op_RegF, 145);  // Preserved
reg_def FR17  (SOE, SOE, Op_RegF,  17);
reg_def FR18H (SOE, SOE, Op_RegF, 146);  // Preserved
reg_def FR18  (SOE, SOE, Op_RegF,  18);
reg_def FR19H (SOE, SOE, Op_RegF, 147);  // Preserved
reg_def FR19  (SOE, SOE, Op_RegF,  19);
reg_def FR20H (SOE, SOE, Op_RegF, 148);  // Preserved
reg_def FR20  (SOE, SOE, Op_RegF,  20);
reg_def FR21H (SOE, SOE, Op_RegF, 149);  // Preserved
reg_def FR21  (SOE, SOE, Op_RegF,  21);
reg_def FR22H (SOE, SOE, Op_RegF, 150);  // Preserved
reg_def FR22  (SOE, SOE, Op_RegF,  22);
reg_def FR23H (SOE, SOE, Op_RegF, 151);  // Preserved
reg_def FR23  (SOE, SOE, Op_RegF,  23);
reg_def FR24H (SOE, SOE, Op_RegF, 152);  // Preserved
reg_def FR24  (SOE, SOE, Op_RegF,  24);
reg_def FR25H (SOE, SOE, Op_RegF, 153);  // Preserved
reg_def FR25  (SOE, SOE, Op_RegF,  25);
reg_def FR26H (SOE, SOE, Op_RegF, 154);  // Preserved
reg_def FR26  (SOE, SOE, Op_RegF,  26);
reg_def FR27H (SOE, SOE, Op_RegF, 155);  // Preserved
reg_def FR27  (SOE, SOE, Op_RegF,  27);
reg_def FR28H (SOE, SOE, Op_RegF, 156);  // Preserved
reg_def FR28  (SOE, SOE, Op_RegF,  28);
reg_def FR29H (SOE, SOE, Op_RegF, 157);  // Preserved
reg_def FR29  (SOE, SOE, Op_RegF,  29);
reg_def FR30H (SOE, SOE, Op_RegF, 158);  // Preserved
reg_def FR30  (SOE, SOE, Op_RegF,  30);
reg_def FR31H (SOE, SOE, Op_RegF, 159);  // Preserved
reg_def FR31  (SOE, SOE, Op_RegF,  31);
reg_def FR32H (SOC, SOC, Op_RegF, 160);  // Start of Rotating Register File
reg_def FR32  (SOC, SOC, Op_RegF,  32);
reg_def FR33H (SOC, SOC, Op_RegF, 161);
reg_def FR33  (SOC, SOC, Op_RegF,  33);
reg_def FR34H (SOC, SOC, Op_RegF, 162);
reg_def FR34  (SOC, SOC, Op_RegF,  34);
reg_def FR35H (SOC, SOC, Op_RegF, 163);
reg_def FR35  (SOC, SOC, Op_RegF,  35);
reg_def FR36H (SOC, SOC, Op_RegF, 164);
reg_def FR36  (SOC, SOC, Op_RegF,  36);
reg_def FR37H (SOC, SOC, Op_RegF, 165);
reg_def FR37  (SOC, SOC, Op_RegF,  37);
reg_def FR38H (SOC, SOC, Op_RegF, 166);
reg_def FR38  (SOC, SOC, Op_RegF,  38);
reg_def FR39H (SOC, SOC, Op_RegF, 167);
reg_def FR39  (SOC, SOC, Op_RegF,  39);
reg_def FR40H (SOC, SOC, Op_RegF, 168);
reg_def FR40  (SOC, SOC, Op_RegF,  40);
reg_def FR41H (SOC, SOC, Op_RegF, 169);
reg_def FR41  (SOC, SOC, Op_RegF,  41);
reg_def FR42H (SOC, SOC, Op_RegF, 170);
reg_def FR42  (SOC, SOC, Op_RegF,  42);
reg_def FR43H (SOC, SOC, Op_RegF, 171);
reg_def FR43  (SOC, SOC, Op_RegF,  43);
reg_def FR44H (SOC, SOC, Op_RegF, 172);
reg_def FR44  (SOC, SOC, Op_RegF,  44);
reg_def FR45H (SOC, SOC, Op_RegF, 173);
reg_def FR45  (SOC, SOC, Op_RegF,  45);
reg_def FR46H (SOC, SOC, Op_RegF, 174);
reg_def FR46  (SOC, SOC, Op_RegF,  46);
reg_def FR47H (SOC, SOC, Op_RegF, 175);
reg_def FR47  (SOC, SOC, Op_RegF,  47);
reg_def FR48H (SOC, SOC, Op_RegF, 176);
reg_def FR48  (SOC, SOC, Op_RegF,  48);
reg_def FR49H (SOC, SOC, Op_RegF, 177);
reg_def FR49  (SOC, SOC, Op_RegF,  49);
reg_def FR50H (SOC, SOC, Op_RegF, 178);
reg_def FR50  (SOC, SOC, Op_RegF,  50);
reg_def FR51H (SOC, SOC, Op_RegF, 179);
reg_def FR51  (SOC, SOC, Op_RegF,  51);
reg_def FR52H (SOC, SOC, Op_RegF, 180);
reg_def FR52  (SOC, SOC, Op_RegF,  52);
reg_def FR53H (SOC, SOC, Op_RegF, 181);
reg_def FR53  (SOC, SOC, Op_RegF,  53);
reg_def FR54H (SOC, SOC, Op_RegF, 182);
reg_def FR54  (SOC, SOC, Op_RegF,  54);
reg_def FR55H (SOC, SOC, Op_RegF, 183);
reg_def FR55  (SOC, SOC, Op_RegF,  55);
reg_def FR56H (SOC, SOC, Op_RegF, 184);
reg_def FR56  (SOC, SOC, Op_RegF,  56);
reg_def FR57H (SOC, SOC, Op_RegF, 185);
reg_def FR57  (SOC, SOC, Op_RegF,  57);
reg_def FR58H (SOC, SOC, Op_RegF, 186);
reg_def FR58  (SOC, SOC, Op_RegF,  58);
reg_def FR59H (SOC, SOC, Op_RegF, 187);
reg_def FR59  (SOC, SOC, Op_RegF,  59);
reg_def FR60H (SOC, SOC, Op_RegF, 188);
reg_def FR60  (SOC, SOC, Op_RegF,  60);
reg_def FR61H (SOC, SOC, Op_RegF, 189);
reg_def FR61  (SOC, SOC, Op_RegF,  61);
reg_def FR62H (SOC, SOC, Op_RegF, 190);
reg_def FR62  (SOC, SOC, Op_RegF,  62);
reg_def FR63H (SOC, SOC, Op_RegF, 191);
reg_def FR63  (SOC, SOC, Op_RegF,  63);
reg_def FR64H (SOC, SOC, Op_RegF, 192);
reg_def FR64  (SOC, SOC, Op_RegF,  64);
reg_def FR65H (SOC, SOC, Op_RegF, 193);
reg_def FR65  (SOC, SOC, Op_RegF,  65);
reg_def FR66H (SOC, SOC, Op_RegF, 194);
reg_def FR66  (SOC, SOC, Op_RegF,  66);
reg_def FR67H (SOC, SOC, Op_RegF, 195);
reg_def FR67  (SOC, SOC, Op_RegF,  67);
reg_def FR68H (SOC, SOC, Op_RegF, 196);
reg_def FR68  (SOC, SOC, Op_RegF,  68);
reg_def FR69H (SOC, SOC, Op_RegF, 197);
reg_def FR69  (SOC, SOC, Op_RegF,  69);
reg_def FR70H (SOC, SOC, Op_RegF, 198);
reg_def FR70  (SOC, SOC, Op_RegF,  70);
reg_def FR71H (SOC, SOC, Op_RegF, 199);
reg_def FR71  (SOC, SOC, Op_RegF,  71);
reg_def FR72H (SOC, SOC, Op_RegF, 200);
reg_def FR72  (SOC, SOC, Op_RegF,  72);
reg_def FR73H (SOC, SOC, Op_RegF, 201);
reg_def FR73  (SOC, SOC, Op_RegF,  73);
reg_def FR74H (SOC, SOC, Op_RegF, 202);
reg_def FR74  (SOC, SOC, Op_RegF,  74);
reg_def FR75H (SOC, SOC, Op_RegF, 203);
reg_def FR75  (SOC, SOC, Op_RegF,  75);
reg_def FR76H (SOC, SOC, Op_RegF, 204);
reg_def FR76  (SOC, SOC, Op_RegF,  76);
reg_def FR77H (SOC, SOC, Op_RegF, 205);
reg_def FR77  (SOC, SOC, Op_RegF,  77);
reg_def FR78H (SOC, SOC, Op_RegF, 206);
reg_def FR78  (SOC, SOC, Op_RegF,  78);
reg_def FR79H (SOC, SOC, Op_RegF, 207);
reg_def FR79  (SOC, SOC, Op_RegF,  79);
reg_def FR80H (SOC, SOC, Op_RegF, 208);
reg_def FR80  (SOC, SOC, Op_RegF,  80);
reg_def FR81H (SOC, SOC, Op_RegF, 209);
reg_def FR81  (SOC, SOC, Op_RegF,  81);
reg_def FR82H (SOC, SOC, Op_RegF, 210);
reg_def FR82  (SOC, SOC, Op_RegF,  82);
reg_def FR83H (SOC, SOC, Op_RegF, 211);
reg_def FR83  (SOC, SOC, Op_RegF,  83);
reg_def FR84H (SOC, SOC, Op_RegF, 212);
reg_def FR84  (SOC, SOC, Op_RegF,  84);
reg_def FR85H (SOC, SOC, Op_RegF, 213);
reg_def FR85  (SOC, SOC, Op_RegF,  85);
reg_def FR86H (SOC, SOC, Op_RegF, 214);
reg_def FR86  (SOC, SOC, Op_RegF,  86);
reg_def FR87H (SOC, SOC, Op_RegF, 215);
reg_def FR87  (SOC, SOC, Op_RegF,  87);
reg_def FR88H (SOC, SOC, Op_RegF, 216);
reg_def FR88  (SOC, SOC, Op_RegF,  88);
reg_def FR89H (SOC, SOC, Op_RegF, 217);
reg_def FR89  (SOC, SOC, Op_RegF,  89);
reg_def FR90H (SOC, SOC, Op_RegF, 218);
reg_def FR90  (SOC, SOC, Op_RegF,  90);
reg_def FR91H (SOC, SOC, Op_RegF, 219);
reg_def FR91  (SOC, SOC, Op_RegF,  91);
reg_def FR92H (SOC, SOC, Op_RegF, 220);
reg_def FR92  (SOC, SOC, Op_RegF,  92);
reg_def FR93H (SOC, SOC, Op_RegF, 221);
reg_def FR93  (SOC, SOC, Op_RegF,  93);
reg_def FR94H (SOC, SOC, Op_RegF, 222);
reg_def FR94  (SOC, SOC, Op_RegF,  94);
reg_def FR95H (SOC, SOC, Op_RegF, 223);
reg_def FR95  (SOC, SOC, Op_RegF,  95);
reg_def FR96H (SOC, SOC, Op_RegF, 224);
reg_def FR96  (SOC, SOC, Op_RegF,  96);
reg_def FR97H (SOC, SOC, Op_RegF, 225);
reg_def FR97  (SOC, SOC, Op_RegF,  97);
reg_def FR98H (SOC, SOC, Op_RegF, 226);
reg_def FR98  (SOC, SOC, Op_RegF,  98);
reg_def FR99H (SOC, SOC, Op_RegF, 227);
reg_def FR99  (SOC, SOC, Op_RegF,  99);
reg_def FR100H(SOC, SOC, Op_RegF, 228);
reg_def FR100 (SOC, SOC, Op_RegF, 100);
reg_def FR101H(SOC, SOC, Op_RegF, 229);
reg_def FR101 (SOC, SOC, Op_RegF, 101);
reg_def FR102H(SOC, SOC, Op_RegF, 230);
reg_def FR102 (SOC, SOC, Op_RegF, 102);
reg_def FR103H(SOC, SOC, Op_RegF, 231);
reg_def FR103 (SOC, SOC, Op_RegF, 103);
reg_def FR104H(SOC, SOC, Op_RegF, 232);
reg_def FR104 (SOC, SOC, Op_RegF, 104);
reg_def FR105H(SOC, SOC, Op_RegF, 233);
reg_def FR105 (SOC, SOC, Op_RegF, 105);
reg_def FR106H(SOC, SOC, Op_RegF, 234);
reg_def FR106 (SOC, SOC, Op_RegF, 106);
reg_def FR107H(SOC, SOC, Op_RegF, 235);
reg_def FR107 (SOC, SOC, Op_RegF, 107);
reg_def FR108H(SOC, SOC, Op_RegF, 236);
reg_def FR108 (SOC, SOC, Op_RegF, 108);
reg_def FR109H(SOC, SOC, Op_RegF, 237);
reg_def FR109 (SOC, SOC, Op_RegF, 109);
reg_def FR110H(SOC, SOC, Op_RegF, 238);
reg_def FR110 (SOC, SOC, Op_RegF, 110);
reg_def FR111H(SOC, SOC, Op_RegF, 239);
reg_def FR111 (SOC, SOC, Op_RegF, 111);
reg_def FR112H(SOC, SOC, Op_RegF, 240);
reg_def FR112 (SOC, SOC, Op_RegF, 112);
reg_def FR113H(SOC, SOC, Op_RegF, 241);
reg_def FR113 (SOC, SOC, Op_RegF, 113);
reg_def FR114H(SOC, SOC, Op_RegF, 242);
reg_def FR114 (SOC, SOC, Op_RegF, 114);
reg_def FR115H(SOC, SOC, Op_RegF, 243);
reg_def FR115 (SOC, SOC, Op_RegF, 115);
reg_def FR116H(SOC, SOC, Op_RegF, 244);
reg_def FR116 (SOC, SOC, Op_RegF, 116);
reg_def FR117H(SOC, SOC, Op_RegF, 245);
reg_def FR117 (SOC, SOC, Op_RegF, 117);
reg_def FR118H(SOC, SOC, Op_RegF, 246);
reg_def FR118 (SOC, SOC, Op_RegF, 118);
reg_def FR119H(SOC, SOC, Op_RegF, 247);
reg_def FR119 (SOC, SOC, Op_RegF, 119);
reg_def FR120H(SOC, SOC, Op_RegF, 248);
reg_def FR120 (SOC, SOC, Op_RegF, 120);
reg_def FR121H(SOC, SOC, Op_RegF, 249);
reg_def FR121 (SOC, SOC, Op_RegF, 121);
reg_def FR122H(SOC, SOC, Op_RegF, 250);
reg_def FR122 (SOC, SOC, Op_RegF, 122);
reg_def FR123H(SOC, SOC, Op_RegF, 251);
reg_def FR123 (SOC, SOC, Op_RegF, 123);
reg_def FR124H(SOC, SOC, Op_RegF, 252);
reg_def FR124 (SOC, SOC, Op_RegF, 124);
reg_def FR125H(SOC, SOC, Op_RegF, 253);
reg_def FR125 (SOC, SOC, Op_RegF, 125);
reg_def FR126H(SOC, SOC, Op_RegF, 254);
reg_def FR126 (SOC, SOC, Op_RegF, 126);
reg_def FR127H(SOC, SOC, Op_RegF, 255);
reg_def FR127 (SOC, SOC, Op_RegF, 127);

// Branch Registers 0-7
// These registers contain pointers to code, and are used
// for indirect or computed branches and calls.
reg_def BR0H  (NS,  NS,  Op_RegP, 128);  // Return Pointer (rp)
reg_def BR0   (NS,  NS,  Op_RegP,   0);
reg_def BR1H  (SOE, SOE, Op_RegP, 129);  // Preserved
reg_def BR1   (SOE, SOE, Op_RegP,   1);
reg_def BR2H  (SOE, SOE, Op_RegP, 130);  // Preserved
reg_def BR2   (SOE, SOE, Op_RegP,   2);
reg_def BR3H  (SOE, SOE, Op_RegP, 131);  // Preserved
reg_def BR3   (SOE, SOE, Op_RegP,   3);
reg_def BR4H  (SOE, SOE, Op_RegP, 132);  // Preserved
reg_def BR4   (SOE, SOE, Op_RegP,   4);
reg_def BR5H  (SOE, SOE, Op_RegP, 133);  // Preserved
reg_def BR5   (SOE, SOE, Op_RegP,   5);
reg_def BR6H  (SOC, SOC, Op_RegP, 134);  // Scratch
reg_def BR6   (SOC, SOC, Op_RegP,   6);
reg_def BR7H  (SOC, SOC, Op_RegP, 135);  // Scratch
reg_def BR7   (SOC, SOC, Op_RegP,   7);

// Predicate Registers 0-63
// These registers contain boolean values, and indicate if code
// is to be conditionally executed. Sort of a binary condition
// code, but there are 64 of them (1 is constant true)
reg_def PR0    (NS,  NS,  Op_RegFlags,   0);  // Constant True
reg_def PR1    (SOE, SOE, Op_RegFlags,   1);  // Preserved
reg_def PR2    (SOE, SOE, Op_RegFlags,   2);  // Preserved
reg_def PR3    (SOE, SOE, Op_RegFlags,   3);  // Preserved
reg_def PR4    (SOE, SOE, Op_RegFlags,   4);  // Preserved
reg_def PR5    (SOE, SOE, Op_RegFlags,   5);  // Preserved
reg_def PR6    (SOC, SOC, Op_RegFlags,   6);  // Scratch
reg_def PR7    (SOC, SOC, Op_RegFlags,   7);  // Scratch
reg_def PR8    (SOC, SOC, Op_RegFlags,   8);  // Scratch
reg_def PR9    (SOC, SOC, Op_RegFlags,   9);  // Scratch
reg_def PR10   (SOC, SOC, Op_RegFlags,  10);  // Scratch
reg_def PR11   (SOC, SOC, Op_RegFlags,  11);  // Scratch
reg_def PR12   (SOC, SOC, Op_RegFlags,  12);  // Scratch
reg_def PR13   (SOC, SOC, Op_RegFlags,  13);  // Scratch
reg_def PR14   (SOC, SOC, Op_RegFlags,  14);  // Scratch
reg_def PR15   (SOC, SOC, Op_RegFlags,  15);  // Scratch
reg_def PR16   (SOC, SOC, Op_RegFlags,  16);  // Start of Rotating Registers
reg_def PR17   (SOC, SOC, Op_RegFlags,  17);
reg_def PR18   (SOC, SOC, Op_RegFlags,  18);
reg_def PR19   (SOC, SOC, Op_RegFlags,  19);
reg_def PR20   (SOC, SOC, Op_RegFlags,  20);
reg_def PR21   (SOC, SOC, Op_RegFlags,  21);
reg_def PR22   (SOC, SOC, Op_RegFlags,  22);
reg_def PR23   (SOC, SOC, Op_RegFlags,  23);
reg_def PR24   (SOC, SOC, Op_RegFlags,  24);
reg_def PR25   (SOC, SOC, Op_RegFlags,  25);
reg_def PR26   (SOC, SOC, Op_RegFlags,  26);
reg_def PR27   (SOC, SOC, Op_RegFlags,  27);
reg_def PR28   (SOC, SOC, Op_RegFlags,  28);
reg_def PR29   (SOC, SOC, Op_RegFlags,  29);
reg_def PR30   (SOC, SOC, Op_RegFlags,  30);
reg_def PR31   (SOC, SOC, Op_RegFlags,  31);
reg_def PR32   (SOC, SOC, Op_RegFlags,  32);
reg_def PR33   (SOC, SOC, Op_RegFlags,  33);
reg_def PR34   (SOC, SOC, Op_RegFlags,  34);
reg_def PR35   (SOC, SOC, Op_RegFlags,  35);
reg_def PR36   (SOC, SOC, Op_RegFlags,  36);
reg_def PR37   (SOC, SOC, Op_RegFlags,  37);
reg_def PR38   (SOC, SOC, Op_RegFlags,  38);
reg_def PR39   (SOC, SOC, Op_RegFlags,  39);
reg_def PR40   (SOC, SOC, Op_RegFlags,  40);
reg_def PR41   (SOC, SOC, Op_RegFlags,  41);
reg_def PR42   (SOC, SOC, Op_RegFlags,  42);
reg_def PR43   (SOC, SOC, Op_RegFlags,  43);
reg_def PR44   (SOC, SOC, Op_RegFlags,  44);
reg_def PR45   (SOC, SOC, Op_RegFlags,  45);
reg_def PR46   (SOC, SOC, Op_RegFlags,  46);
reg_def PR47   (SOC, SOC, Op_RegFlags,  47);
reg_def PR48   (SOC, SOC, Op_RegFlags,  48);
reg_def PR49   (SOC, SOC, Op_RegFlags,  49);
reg_def PR50   (SOC, SOC, Op_RegFlags,  50);
reg_def PR51   (SOC, SOC, Op_RegFlags,  51);
reg_def PR52   (SOC, SOC, Op_RegFlags,  52);
reg_def PR53   (SOC, SOC, Op_RegFlags,  53);
reg_def PR54   (SOC, SOC, Op_RegFlags,  54);
reg_def PR55   (SOC, SOC, Op_RegFlags,  55);
reg_def PR56   (SOC, SOC, Op_RegFlags,  56);
reg_def PR57   (SOC, SOC, Op_RegFlags,  57);
reg_def PR58   (SOC, SOC, Op_RegFlags,  58);
reg_def PR59   (SOC, SOC, Op_RegFlags,  59);
reg_def PR60   (SOC, SOC, Op_RegFlags,  60);
reg_def PR61   (SOC, SOC, Op_RegFlags,  61);
reg_def PR62   (SOC, SOC, Op_RegFlags,  62);
reg_def PR63   (SOC, SOC, Op_RegFlags,  63);

// Specify priority of register selection within phases of register 
// allocation.  Highest priority is first.  A useful heuristic is to 
// give registers a low priority when they are required by machine 
// instructions, like EAX and EDX on I486, and choose no-save registers
// before save-on-call, & save-on-call before save-on-entry.  Registers
// which participate in fixed calling sequences should come last.
// Registers which are used as pairs must fall on an even boundary.

// These registers are for more general use
//
// NOTE: Initially, the NaT bit will _NOT_ be preserved. This means that
//   NaT bits are only legal between calls, and their use otherwise is
//   discouraged
alloc_class all_grs(

	// Locals (preserved automatically), always allocated
	L0,   L0H,      L1,   L1H,      L2,   L2H,      L3,   L3H,
        L4,   L4H,      L5,   L5H,      L6,   L6H,      L7,   L7H,  
	L8,   L8H,      L9,   L9H,      L10,  L10H,     L11,  L11H,
        L12,  L12H,     L13,  L13H,     L14,  L14H,     L15,  L15H,  

	// Scratch (i.e., caller save)
        GR13, GR13H,    GR14, GR14H,
	GR15, GR15H,    GR16, GR16H,    GR17, GR17H,    GR18, GR18H,
        GR19, GR19H,    GR20, GR20H,    GR21, GR21H,    GR22, GR22H,
        GR23, GR23H,    GR24, GR24H,    GR25, GR25H,    GR26, GR26H,
        GR27, GR27H,    GR28, GR28H,    GR29, GR29H,    GR30, GR30H,
        GR31, GR31H,  

        // Preserved (i.e., callee save)
//	GR5,  GR5H,      GR6,  GR6H,     GR7,  GR7H,  

	// Used as return values
	GR11, GR11H,    GR10, GR10H,    GR9,  GR9H,     GR8_RET,  GR8_RETH,  

	// Used for output parameters
	O7,   O7H,      O6,   O6H,      O5,   O5H,      O4,   O4H,
        O3,   O3H,      O2,   O2H,      O1,   O1H,      O0,   O0H,  

	// Used for input parameters
	I7,   I7H,      I6,   I6H,      I5,   I5H,      I4,   I4H,
        I3,   I3H,      I2,   I2H,      I1,   I1H,      I0,   I0H,  

	// Used for 22 bit immediates
	GR2,  GR2H,     GR3,  GR3H,  

	// Special Registers
	GR0,     GR0H,
        GR1_GP,  GR1_GPH,
        GR4_TLS, GR4_TLSH,
        GR12_SP, GR12_SPH,
);

// Same for the floating point registers, it is best not to allocate those
// registers above 31 unless needed.
alloc_class all_frs(

	// Always 0.0
	FR0,   FR0H,

	// Always 1.0
	FR1,   FR1H

	// Preserved
//	FR2,   FR2H,    FR3,   FR3H,    FR4,   FR4H,    FR5,   FR5H,

	// Scratch
	FR6,  FR6H,     FR7,   FR7H,  

	// Argument/Return registers
        FR8,   FR8H,    FR9,   FR9H,    FR10,  FR10H,   FR11,  FR11H,
        FR12,  FR12H,   FR13,  FR13H,   FR14,  FR14H,   FR15,  FR15H,  

	// More Scratch (rotating, but we'll ignore that)
	FR32,  FR32H,   FR33,  FR33H,   FR34,  FR34H,   FR35,  FR35H,
        FR36,  FR36H,   FR37,  FR37H,   FR38,  FR38H,   FR39,  FR39H,  
	FR40,  FR40H,   FR41,  FR41H,   FR42,  FR42H,   FR43,  FR43H,
        FR44,  FR44H,   FR45,  FR45H,   FR46,  FR46H,   FR47,  FR47H,
	FR48,  FR48H,   FR49,  FR49H,   FR50,  FR50H,   FR51,  FR51H,
        FR52,  FR52H,   FR53,  FR53H,   FR54,  FR54H,   FR55,  FR55H,  
	FR56,  FR56H,   FR57,  FR57H,   FR58,  FR58H,   FR59,  FR59H,
        FR60,  FR60H,   FR61,  FR61H,   FR62,  FR62H,   FR63,  FR63H

	// Preserved (i.e., callee save)
//	FR16,  FR16H,   FR17,  FR17H,   FR18,  FR18H,   FR19,  FR19H,
//	FR20,  FR20H,   FR21,  FR21H,   FR22,  FR22H,   FR23,  FR23H,  
//	FR24,  FR24H,   FR25,  FR25H,   FR26,  FR26H,   FR27,  FR27H,
//	FR28,  FR28H,   FR29,  FR29H,   FR30,  FR30H,   FR31,  FR31H,  
);

// Branch registers
alloc_class all_brs(
 
 	// Return Address
	BR0, BR0H,

 	// Preserved
// 	BR1,  BR1H,   BR2,  BR2H,   BR3,  BR3H,   BR4,  BR4H,
//	BR5,  BR5H

 	// Scratch
 	BR6,  BR6H,   BR7,  BR7H
);

// Predicate registers
alloc_class all_prs(

 	// Always true
 	PR0,

 	// Preserved
// 	PR1,  PR2,  PR3,  PR4,  PR5,

 	// Scratch (i.e., caller save)
 	PR6,  PR7,  PR8,  PR9,  PR10, PR11, PR12, PR13,
 	PR14, PR15

	// Preserved
// 	PR16, PR17, PR18, PR19, PR20, PR21, PR22, PR23,
//	PR24, PR25, PR26, PR27, PR28, PR29, PR30, PR31,
// 	PR32, PR33, PR34, PR35, PR36, PR37, PR38, PR39,
// 	PR40, PR41, PR42, PR43, PR44, PR45, PR46, PR47,
//	PR48, PR49, PR50, PR51, PR52, PR53, PR54, PR55,
// 	PR56, PR57, PR58, PR59, PR60, PR61, PR62, PR63
);

//----------Architecture Description Register Classes--------------------------
// Several register classes are automatically defined based upon information in
// this architecture description.
// 1) reg_class inline_cache_reg           ( as defined in frame section )
// 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
// 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
// 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
// 

// GR0 is not included in integer class since it has special meaning.
//reg_class gr0_reg    (GR0);

// GR2 and GR3 can be used for 22 bit immediates
reg_class imm22_64reg(GR2H, GR2,   GR3H, GR3);
reg_class imm22_32reg(       GR2,          GR3);

// Class for all long and pointer registers
//   exclude GR1:  GP
//   exclude GR28: scratch register
//   exclude GR29: scratch registers
//   exclude L0:   GR_Lsave_SP
//   exclude L1:   GR_Lsave_PFS
//   exclude L2:   GR_Lsave_RP
//   exclude L3:   GR_Lsave_caller_BSP
//   exclude L4:   GR_jni_save_RSC (GR_Lsave_UNAT)	< jni >
//   exclude L5:   GR_Lsave_GP                          < jni >
//   exclude L6:   GR_jni_mod_RSC  (GR_Lsave_LC)        < jni >

reg_class bits64_reg(
	                                 GR2H,  GR2,     GR3H,  GR3,  
//                       GR5H,  GR5,     GR6H,  GR6,     GR7H,  GR7,    
	GR8_RETH, GR8_RET, GR9H,  GR9,  GR10H, GR10,    GR11H, GR11,
                        // GR15H, GR15,    
			GR16H, GR16,    GR17H, GR17,
	GR18H, GR18,    GR19H, GR19,    GR20H, GR20,    GR21H, GR21,
	GR22H, GR22,    GR23H, GR23,    GR24H, GR24,    GR25H, GR25,
	GR26H, GR26,    GR27H, GR27,
        //                GR31H, GR31, QQQ

        // Input Registers
	I0H,   I0,      I1H,   I1,      I2H,   I2,      I3H,   I3,
        I4H,   I4,      I5H,   I5,      I6H,   I6,      I7H,   I7,  

        // Local Registers
        L7H,   L7,
	L8H,   L8,      L9H,   L9,      L10H,  L10,     L11H,  L11,
        L12H,  L12,     L13H,  L13,     L14H,  L14,     L15H,  L15,  

        // Output Registers
	O0H,   O0,      O1H,   O1,      O2H,   O2,      O3H,   O3,
        O4H,   O4,      O5H,   O5,      O6H,   O6,      O7H,   O7
);

// Include GR12_SP in this class
reg_class bits64_sp_reg(
	                                GR2H,  GR2,     GR3H,  GR3,  
//                      GR5H,  GR5,     GR6H,  GR6,     GR7H,  GR7,    
	GR8_RETH,  GR8_RET,    GR9H,  GR9,     GR10H, GR10,    GR11H, GR11,
                       //  GR15H, GR15,
			GR16H, GR16,    GR17H, GR17,
	GR18H, GR18,    GR19H, GR19,    GR20H, GR20,    GR21H, GR21,
	GR22H, GR22,    GR23H, GR23,    GR24H, GR24,    GR25H, GR25,
	GR26H, GR26,    GR27H, GR27,
                        // GR31H, GR31 QQQ

        // Input Registers
	I0H,   I0,      I1H,   I1,      I2H,   I2,      I3H,   I3,
        I4H,   I4,      I5H,   I5,      I6H,   I6,      I7H,   I7,  

        // Local Registers
        L7H,   L7,  
	L8H,   L8,      L9H,   L9,      L10H,  L10,     L11H,  L11,
        L12H,  L12,     L13H,  L13,     L14H,  L14,     L15H,  L15,  

        // Output Registers
	O0H,   O0,      O1H,   O1,      O2H,   O2,      O3H,   O3,
        O4H,   O4,      O5H,   O5,      O6H,   O6,      O7H,   O7,

	// Special Registers
	GR12_SPH, GR12_SP
);

// Exclude temp registers
reg_class bits64_reg_notmp(
//	                                 GR2H,  GR2,     GR3H,  GR3,  
//                       GR5H,  GR5,     GR6H,  GR6,     GR7H,  GR7,    
	GR8_RETH, GR8_RET, GR9H,  GR9,  GR10H, GR10,    GR11H, GR11,
                        // GR15H, GR15,    
			GR16H, GR16,    GR17H, GR17,
	GR18H, GR18,    GR19H, GR19,    GR20H, GR20,    GR21H, GR21,
	GR22H, GR22,    GR23H, GR23,    GR24H, GR24,    GR25H, GR25,
	GR26H, GR26,    GR27H, GR27,
        //                GR31H, GR31, QQQ

        // Input Registers
	I0H,   I0,      I1H,   I1,      I2H,   I2,      I3H,   I3,
        I4H,   I4,      I5H,   I5,      I6H,   I6,      I7H,   I7,  

        // Local Registers
        L7H,   L7,  
	L8H,   L8,      L9H,   L9,      L10H,  L10,     L11H,  L11,
        L12H,  L12,     L13H,  L13,     L14H,  L14,     L15H,  L15,  

        // Output Registers
	O0H,   O0,      O1H,   O1,      O2H,   O2,      O3H,   O3,
        O4H,   O4,      O5H,   O5,      O6H,   O6,      O7H,   O7
);

// Class for all integer registers
//   exclude GR1, GR28, GR29 as scratch registers
//   exclude L0, L1 to hold previous GR12_SP, PFS
reg_class bits32_reg(
	                             GR2,               GR3,  
//                GR5,               GR6,               GR7,    
	          GR8_RET,           GR9,               GR10,              GR11,
                 //  GR15,
		  GR16,              GR17,              GR18,
                  GR19,              GR20,              GR21,              GR22,
                  GR23,              GR24,              GR25,              GR26,
                  GR27,
                                     // GR31, QQQ


        // Input Registers
	          I0,                I1,                I2,                I3,
                  I4,                I5,                I6,                I7,  

        // Local Registers
                  L7,  
	          L8,                L9,                L10,               L11,
                  L12,               L13,               L14,               L15,  

        // Output Registers
	          O0,                O1,                O2,                O3,
                  O4,                O5,                O6,                O7
);

// Specific Registers
reg_class g8_ret_regI( GR8_RET );

reg_class g30_regL(  GR30H, GR30 );

reg_class  gp_regP(GR1_GPH, GR1_GP );
reg_class ret_regP(GR8_RETH, GR8_RET );
reg_class  o0_regP(    O0H, O0 );
reg_class  o1_regP(    O1H, O1 );
reg_class  o2_regP(    O2H, O2 );
reg_class  o3_regP(    O3H, O3 );
reg_class  o4_regP(    O4H, O4 );
reg_class  o5_regP(    O5H, O5 );
reg_class  o6_regP(    O6H, O6 );
reg_class  o7_regP(    O7H, O7 );
reg_class  g2_regP(   GR2H, GR2 );
reg_class  g3_regP(   GR3H, GR3 );
reg_class g27_regP(  GR27H, GR27 );
reg_class g28_regP(  GR28H, GR28 );
reg_class g29_regP(  GR29H, GR29 );
reg_class g30_regP(  GR30H, GR30 );
reg_class g31_regP(  GR31H, GR31 );

reg_class  l0_regP(    L0H, L0 );
reg_class  l1_regP(    L1H, L1 );
reg_class  l2_regP(    L2H, L2 );
reg_class  l3_regP(    L3H, L3 );
reg_class  l4_regP(    L4H, L4 );
reg_class  l5_regP(    L5H, L5 );

reg_class inline_cache_regs          ( GR27H, GR27 );
reg_class compiler_method_oop_regs   ( GR30H, GR30 );
reg_class interpreter_method_oop_regs( GR27H, GR27 );

// Same for the floating point registers, it is best not to allocate those
// registers above 31 unless needed.
reg_class  fr0_regD(  FR0H, FR0 );
reg_class  fr1_regD(  FR1H, FR1 );

reg_class  fr6_regD(  FR6H, FR6 );
reg_class  fr7_regD(  FR7H, FR7 );
reg_class  fr8_regD(  FR8H, FR8 );
reg_class  fr9_regD(  FR9H, FR9 );
reg_class fr10_regD( FR10H, FR10 );
reg_class fr11_regD( FR11H, FR11 );
reg_class fr12_regD( FR12H, FR12 );
reg_class fr13_regD( FR13H, FR13 );
reg_class fr14_regD( FR14H, FR14 );
reg_class fr15_regD( FR15H, FR15 );

reg_class  fr6_regF( FR6 );
reg_class  fr7_regF( FR7 );
reg_class  fr8_regF( FR8 );
reg_class  fr9_regF( FR9 );
reg_class fr10_regF( FR10 );
reg_class fr11_regF( FR11 );
reg_class fr12_regF( FR12 );
reg_class fr13_regF( FR13 );
reg_class fr14_regF( FR14 );
reg_class fr15_regF( FR15 );

reg_class float_reg(

	// Preserved
//	          FR2,               FR3,               FR4,               FR5,

	// Scratch
                  FR6,               FR7,  

	// Return Values
  	           FR8,              FR9,               FR10,              FR11,
  	           FR12,             FR13,              FR14,              FR15,  

	// Preserved
//	           FR16,             FR17,              FR18,              FR19,
//	           FR20,             FR21,              FR22,              FR23,  
//	           FR24,             FR25,              FR26,              FR27,
//	           FR28,             FR29,              FR30,              FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	           FR32,             FR33,              FR34,              FR35,
	           FR36,             FR37,              FR38,              FR39,  
	           FR40,             FR41,              FR42,              FR43,
	           FR44,             FR45,              FR46,              FR47,  
	           FR48,             FR49,              FR50,              FR51,
	           FR52,             FR53,              FR54,              FR55,  
	           FR56,             FR57,              FR58,              FR59,
                   FR60,             FR61,              FR62,              FR63
);

reg_class float_reg_notmp(

	// Preserved
//	          FR2,               FR3,               FR4,               FR5,

	// Scratch
                  FR6,               FR7,  

	// Return Values
  	           FR8,              
//                                   FR9,               FR10,              FR11,
//	           FR12,             FR13,              FR14,              FR15,  

	// Preserved
//	           FR16,             FR17,              FR18,              FR19,
//	           FR20,             FR21,              FR22,              FR23,  
//	           FR24,             FR25,              FR26,              FR27,
//	           FR28,             FR29,              FR30,              FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	           FR32,             FR33,              FR34,              FR35,
	           FR36,             FR37,              FR38,              FR39,  
	           FR40,             FR41,              FR42,              FR43,
	           FR44,             FR45,              FR46,              FR47,  
	           FR48,             FR49,              FR50,              FR51,
	           FR52,             FR53,              FR54,              FR55,  
	           FR56,             FR57,              FR58,              FR59,
                   FR60,             FR61,              FR62,              FR63
);

reg_class float_reg_notmp13(

	// Preserved
//	          FR2,               FR3,               FR4,               FR5,

	// Scratch
                  FR6,               FR7,  

	// Return Values
  	           FR8,              FR9,               FR10,              FR11,
  	           FR12,
//	                             FR13,              FR14,              FR15,  

	// Preserved
//	           FR16,             FR17,              FR18,              FR19,
//	           FR20,             FR21,              FR22,              FR23,  
//	           FR24,             FR25,              FR26,              FR27,
//	           FR28,             FR29,              FR30,              FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	           FR32,             FR33,              FR34,              FR35,
	           FR36,             FR37,              FR38,              FR39,  
	           FR40,             FR41,              FR42,              FR43,
	           FR44,             FR45,              FR46,              FR47,  
	           FR48,             FR49,              FR50,              FR51,
	           FR52,             FR53,              FR54,              FR55,  
	           FR56,             FR57,              FR58,              FR59,
                   FR60,             FR61,              FR62,              FR63
);

reg_class float_reg_notmp15(

	// Preserved
//	          FR2,               FR3,               FR4,               FR5,

	// Scratch
                  FR6,               FR7,  

	// Return Values
  	           FR8,              FR9,               FR10,              FR11,
  	           FR12,             FR13,              FR14,
//                                                                         FR15,  

	// Preserved
//	           FR16,             FR17,              FR18,              FR19,
//	           FR20,             FR21,              FR22,              FR23,  
//	           FR24,             FR25,              FR26,              FR27,
//	           FR28,             FR29,              FR30,              FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	           FR32,             FR33,              FR34,              FR35,
	           FR36,             FR37,              FR38,              FR39,  
	           FR40,             FR41,              FR42,              FR43,
	           FR44,             FR45,              FR46,              FR47,  
	           FR48,             FR49,              FR50,              FR51,
	           FR52,             FR53,              FR54,              FR55,  
	           FR56,             FR57,              FR58,              FR59,
                   FR60,             FR61,              FR62,              FR63
);

reg_class double_reg(

	// Preserved
//	FR2H,  FR2,     FR3H,  FR3,     FR4H,  FR4,     FR5H,  FR5,

	// Scratch
        FR6H,  FR6,     FR7H,  FR7,  

	// Return Values
  	FR8H,   FR8,    FR9H,  FR9,     FR10H, FR10,    FR11H, FR11,
  	FR12H,  FR12,   FR13H, FR13,    FR14H, FR14,    FR15H, FR15,  

	// Preserved
//	FR16H,  FR16,   FR17H, FR17,    FR18H, FR18,    FR19H, FR19,
//	FR20H,  FR20,   FR21H, FR21,    FR22H, FR22,    FR23H, FR23,  
//	FR24H,  FR24,   FR25H, FR25,    FR26H, FR26,    FR27H, FR27,
//	FR28H,  FR28,   FR29H, FR29,    FR30H, FR30,    FR31H, FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	FR32H,  FR32,   FR33H, FR33,    FR34H, FR34,    FR35H, FR35,
	FR36H,  FR36,   FR37H, FR37,    FR38H, FR38,    FR39H, FR39,  
	FR40H,  FR40,   FR41H, FR41,    FR42H, FR42,    FR43H, FR43,
	FR44H,  FR44,   FR45H, FR45,    FR46H, FR46,    FR47H, FR47,  
	FR48H,  FR48,   FR49H, FR49,    FR50H, FR50,    FR51H, FR51,
	FR52H,  FR52,   FR53H, FR53,    FR54H, FR54,    FR55H, FR55,  
	FR56H,  FR56,   FR57H, FR57,    FR58H, FR58,    FR59H, FR59,
        FR60H,  FR60,   FR61H, FR61,    FR62H, FR62,    FR63H, FR63
);

reg_class double_reg_notmp12(

	// Preserved
//	FR2H,  FR2,     FR3H,  FR3,     FR4H,  FR4,     FR5H,  FR5,

	// Scratch
        FR6H,  FR6,     FR7H,  FR7,  

	// Return Values
  	FR8H,   FR8,    FR9H,  FR9,     FR10H, FR10,    FR11H, FR11,
//	FR12H,  FR12,   FR13H, FR13,    FR14H, FR14,    FR15H, FR15,  

	// Preserved
//	FR16H,  FR16,   FR17H, FR17,    FR18H, FR18,    FR19H, FR19,
//	FR20H,  FR20,   FR21H, FR21,    FR22H, FR22,    FR23H, FR23,  
//	FR24H,  FR24,   FR25H, FR25,    FR26H, FR26,    FR27H, FR27,
//	FR28H,  FR28,   FR29H, FR29,    FR30H, FR30,    FR31H, FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	FR32H,  FR32,   FR33H, FR33,    FR34H, FR34,    FR35H, FR35,
	FR36H,  FR36,   FR37H, FR37,    FR38H, FR38,    FR39H, FR39,  
	FR40H,  FR40,   FR41H, FR41,    FR42H, FR42,    FR43H, FR43,
	FR44H,  FR44,   FR45H, FR45,    FR46H, FR46,    FR47H, FR47,  
	FR48H,  FR48,   FR49H, FR49,    FR50H, FR50,    FR51H, FR51,
	FR52H,  FR52,   FR53H, FR53,    FR54H, FR54,    FR55H, FR55,  
	FR56H,  FR56,   FR57H, FR57,    FR58H, FR58,    FR59H, FR59,
        FR60H,  FR60,   FR61H, FR61,    FR62H, FR62,    FR63H, FR63
);

reg_class double_reg_notmp15(

	// Preserved
//	FR2H,  FR2,     FR3H,  FR3,     FR4H,  FR4,     FR5H,  FR5,

	// Scratch
        FR6H,  FR6,     FR7H,  FR7,  

	// Return Values
  	FR8H,   FR8,
                        FR9H,  FR9,     FR10H, FR10,    FR11H, FR11,
  	FR12H,  FR12,   FR13H, FR13,    FR14H, FR14,
//                                                      FR15H, FR15,  

	// Preserved
//	FR16H,  FR16,   FR17H, FR17,    FR18H, FR18,    FR19H, FR19,
//	FR20H,  FR20,   FR21H, FR21,    FR22H, FR22,    FR23H, FR23,  
//	FR24H,  FR24,   FR25H, FR25,    FR26H, FR26,    FR27H, FR27,
//	FR28H,  FR28,   FR29H, FR29,    FR30H, FR30,    FR31H, FR31,

	// More Scratch (rotatingH, but we'll ignore that)
	FR32H,  FR32,   FR33H, FR33,    FR34H, FR34,    FR35H, FR35,
	FR36H,  FR36,   FR37H, FR37,    FR38H, FR38,    FR39H, FR39,  
	FR40H,  FR40,   FR41H, FR41,    FR42H, FR42,    FR43H, FR43,
	FR44H,  FR44,   FR45H, FR45,    FR46H, FR46,    FR47H, FR47,  
	FR48H,  FR48,   FR49H, FR49,    FR50H, FR50,    FR51H, FR51,
	FR52H,  FR52,   FR53H, FR53,    FR54H, FR54,    FR55H, FR55,  
	FR56H,  FR56,   FR57H, FR57,    FR58H, FR58,    FR59H, FR59,
        FR60H,  FR60,   FR61H, FR61,    FR62H, FR62,    FR63H, FR63
);

// Predicate registers
// *** KLUDGE FOR BRANCH REGISTERS ***
reg_class pr6_reg ( PR6  );
reg_class pr7_reg ( PR7  );
reg_class pr8_reg ( PR8  );
reg_class pr9_reg ( PR9  );
reg_class pr10_reg( PR10 );
// *** KLUDGE FOR BRANCH REGISTERS ***

reg_class predicate_reg(
	PR6,  PR7,  PR8,  PR9,  PR10, PR11, PR12, PR13,
	PR14, PR15
);

// Branch registers
// *** KLUDGE FOR BRANCH REGISTERS ***
reg_class br7_reg   ( BR7, BR7H );
reg_class br6_reg   ( BR6, BR6H );
reg_class br0_reg   ( BR0, BR0H );
// *** KLUDGE FOR BRANCH REGISTERS ***

// reg_class branch_reg(
// 	BR1H,   BR1,    BR2H,  BR2,     BR3H,  BR3,     BR4H,  BR4,
//	BR5H,   BR5,    BR6H,  BR6H,   BR7H,  BR7
// );
// 
// reg_class call_br_reg(
// 	BR7H,   BR7
// );
// 
// reg_class return_reg(
// 	BR0H,   BR7
// );

%}

//----------DEFINITION BLOCK---------------------------------------------------
// Define name --> value mappings to inform the ADLC of an integer valued name
// Current support includes integer values in the range [0, 0x7FFFFFFF]
// Format:
//        int_def  <name>         ( <int_value>, <expression>);
// Generated code in ad_<arch>.hpp
//        #define  <name>   (<expression>)
//        // value == <int_value>
// Generated code in ad_<arch>.cpp adlc_verification()
//        assert( <name> == <int_value>, "Expect (<expression>) to equal <int_value>");
// 
definitions %{

// The default cost (of an ALU instruction).
  int_def  DEFAULT_COST         (    100,      100);

  int_def  HUGE_COST            (1000000,  1000000);

// Integer Memory reads are twice as expensive as run-of-the-mill.
  int_def INT_MEMORY_READ_COST  (    200, DEFAULT_COST * 2 );
  int_def INT_MEMORY_WRITE_COST (    100, DEFAULT_COST);

// Floating Point Memory refs are 9 times as expensive as run-of-the-mill.
  int_def FP_MEMORY_READ_COST   (    900, DEFAULT_COST * 9 );
  int_def FP_MEMORY_WRITE_COST  (    100, DEFAULT_COST);

  int_def FP_OP_COST            (    500, DEFAULT_COST * 5 );
  int_def FP_CMP_COST           (    200, DEFAULT_COST * 2 );

// Branches are also expensive.
  int_def BRANCH_COST           (    300, DEFAULT_COST * 3 );
  int_def CALL_COST             (    300, DEFAULT_COST * 3 );
%}


//----------SOURCE BLOCK-------------------------------------------------------
// This is a block of C++ code which provides values, functions, and
// definitions necessary in the rest of the architecture description
source_hpp %{

%}

source %{
#define __ _masm.

// tertiary op of a LoadP or StoreP encoding
#define REGP_OP false

// Adjust calling sequence of OptoRuntime::rethrow_stub to use G1 not I0.
// Doing this reduces pressure on I0 even in hot paths of the code, and is
// worth about 0.5% on the SPEC geomean.
//#define PD_RETHROW_OOP_REGISTER R_G1_num /*was I0_num before tuning*/


// ****************************************************************************

// REQUIRED FUNCTIONALITY

// !!!!! Special hack to get all type of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.
//       The "return address" is the address of the call instruction, plus 8.

int MachCallStaticJavaNode::ret_addr_offset() {
  return 2 * Pipeline::bundle_unit_size();  // movl;; mov br; call
}

int MachCallDynamicJavaNode::ret_addr_offset() {
  return 3 * Pipeline::bundle_unit_size();  // movl;; movl;; mov br; call
}

int MachCallRuntimeNode::ret_addr_offset() {
  return 6 * Pipeline::bundle_unit_size();  // add; mova;; st8;; movi; add;; nopm; movl; st8; movl;; mov br; call
}

int MachCallNativeNode::ret_addr_offset() {
  return 22 * Pipeline::bundle_unit_size();  // See emit_native_call
}

int MachCallCompiledJavaNode::ret_addr_offset() {
  return 2 * Pipeline::bundle_unit_size();  // add; ld8;; mov br; call
}

int MachCallInterpreterNode::ret_addr_offset() {
  return 3 * Pipeline::bundle_unit_size();  // movl;; mov br; call
}

// Indicate if the safepoint node needs the polling page as an input.
// Since IA64 keeps the polling page in GR5_poll_page_addr
// we don't need the address as input.
bool SafePointNode::needs_polling_address_input() {
  return false;
}

// emit an interrupt that is caught by the debugger (for debugging compiler)
void emit_break(CodeBuffer &cbuf) {
  MacroAssembler _masm(&cbuf);
  // GDB refuses to let us step over a breakpoint it didn't create
#ifdef LINUX
  __ os_breakpoint();
#else
  __ breaki(0x80016);
#endif
}

#ifndef PRODUCT
void MachBreakpointNode::format( PhaseRegAlloc * ) const {
  tty->print("TA");
}
#endif

void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *pc_) const {
  emit_break(cbuf);
}

uint MachBreakpointNode::size(PhaseRegAlloc *pc_) const {
  ShouldNotReachHere(); return 1;
}

void emit_nop(CodeBuffer &cbuf) {
  MacroAssembler _masm(&cbuf);
  __ nopi();
}


void emit_call_reloc(CodeBuffer &cbuf, jint entry_point, relocInfo::relocType rtype, bool set_post_Java_state = false) {
// The method which records debug information at every safepoint
// expects the call to be the first instruction in the snippet as
// it creates a PcDesc structure which tracks the offset of a call
// from the start of the codeBlob. This offset is computed as
// code_end() - code_begin() of the code which has been emitted
// so far.

  warning("emit_call_reloc: KLUDGE");
  MacroAssembler _masm(&cbuf);
//   // The setting of post_Java_state over here is hack and this forces the thread
//   // state also to be set here instead of in the generic code. This needs to be
//   // cleaned up as soon as possible %%%%%%
//   if (set_post_Java_state) {
//     Address post_Java_pc(G2, (address)JavaThread::post_Java_state_offset_in_bytes());
//     Address thread_state_addr(G2, (address)JavaThread::thread_state_offset_in_bytes());
//     Label L;
//     assert(preserve_g2, "using L7 as temp");
//     __ call(L, relocInfo::none);
//     __ delayed()->add(O7, frame::pc_return_offset*wordSize*2 + 3*wordSize + JavaThread::is_pc, L7);
//     __ bind(L);
//     __ st(L7, post_Java_pc);
//     __ set(_thread_in_native, L7);
//     __ st(L7, thread_state_addr);
//   }
//   __ call((address)entry_point, rtype);
//   if (preserve_g2)   __ delayed()->mov(G2, L7);
//   else if (entry_point && (address)entry_point == OptoRuntime::rethrow_stub()) {
//     // The following is a kludge to support a StaticCall to rethrow_stub,
//     // which has an odd calling sequence.
//     switch (PD_RETHROW_OOP_REGISTER) {
//     case R_G1_num: __ delayed()->mov(O0, G1); break;
//     case I0_num: __ delayed()->nop();       break;
//     default:       ShouldNotReachHere();
//     }
//   }
//   else __ delayed()->nop();
//   if (preserve_g2)   __ mov(L7, G2);
//   #ifdef ASSERT
//   if (preserve_g2) {
//     // this is also a native call, so smash the first 8 stack locations,
//     // and the various registers
//     // Note:  [SP+0x40] is sp[callee_aggregate_return_pointer_sp_offset],
//     // while [SP+0x44..0x58] are the argument dump slots.  We also trash
//     // [SP+0x44..0x5c] since the compiler is going to round up the preserve
//     // area to 0mod8--we might as well assert that the odd slot is unused.
//     if (VM_Version::v9_instructions_work()) {
//       __ set((int)0xbaadf00d, G1);
//       __ mov(G1, G5);
//       __ sllx(G1, 32, G1);
//       __ or3(G1, G5, G1);
//       __ mov(G1, G5);
//       __ stx(G1, SP, 0x40);
//       __ stx(G1, SP, 0x48);
//       __ stx(G1, SP, 0x50);
//       __ stx(G1, SP, 0x58);
//     } else {
//       __ set((int)0xbaadf00d, G1);
//       __ st(G1, SP, 0x40);
//       __ st(G1, SP, 0x44);
//       __ st(G1, SP, 0x48);
//       __ st(G1, SP, 0x4c);
//       __ st(G1, SP, 0x50);
//       __ st(G1, SP, 0x54);
//       __ st(G1, SP, 0x58);
//       __ st(G1, SP, 0x5c);
//     }
//   }
//   #endif
}

// //=============================================================================
// //
// // Encodes oop Relocation information into CodeBuffer
// // used by emit_hi_reloc & emit_lo_reloc
// //
// void add_oop_Relocation(CodeBuffer &cbuf, jobject h, int format) {
//   OopRecorder *oop_recorder = cbuf.oop_recorder();
//   assert(oop_recorder != NULL, "CodeBuffer must have OopRecorder");
// 
//   // Create relocation information, record Oop
//   int oop_index = oop_recorder->find_index(h);
//   RelocationHolder rspec = oop_Relocation::spec(oop_index);
// 
//   assert(h == NULL || JNIHandles::resolve(h)->is_perm(), "cannot embed non-perm oops in code");
// 
//   // add Relocation information to the CodeBuffer      
//   cbuf.relocate(cbuf.mark(), rspec, format);
// }

// Use this to add a constant offset to the stack pointer
static void add_offset_to_stack(MacroAssembler &_masm, Register dst, int offset) {
  if( Assembler::is_simm14(offset) )
    __ add( dst, offset, SP );
  else {
    assert(dst != SP, "must not add non-simm14 offset to stack");

    if( Assembler::is_simm22(offset) ) 
      __ mov(  dst, offset );
    else
      __ movl( dst, offset );

    __ add( dst, dst, SP );
  }
}

//=============================================================================

uint MachPrologNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size ) const {
  Compile* C = ra_->C;
  int size = 0;

  // Get frame size in words
  int framesize = C->frame_size_in_words();

  assert(framesize   >=  2, "must have room for scratch area");
  assert(framesize%2 ==  0, "must preserve doubleword alignment");

  // Adjust frame size to bytes
  framesize *= wordSize;

  if( cbuf ) {
    const PredicateRegister reg_stack_overflow      = PR6_SCRATCH;
    MacroAssembler _masm(cbuf);
    __ flush_bundle();

    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them.  But be careful, because
    // some VM calls (such as call site linkage) can use several kilobytes of
    // stack.  But the stack safety zone should account for that.
    // See bugs 4446381, 4468289, 4497237.

    // If we are compiling a stub, skip the stack banging
    if (C->need_stack_bang(framesize)) {
      __ generate_stack_overflow_check(framesize);
    }
    if (C->need_register_stack_bang()) {
      // Check register stack for overflow.
      __ cmp(reg_stack_overflow, PR0, GR6_caller_BSP, GR7_reg_stack_limit, Assembler::higher);

      // If we overflowed register stack, cause an exception by writing to address 0.
      // This will be intercepted in the signal handler and turned into a stack overflow. 
      __ st8(reg_stack_overflow, GR0, GR0);
    }

    __ alloc(GR_Lsave_PFS, 8, 16, 8, 0);
    __ mov(GR_Lsave_SP, SP);

    if (C->stub_function() == NULL) {
      __ mov(GR_Lsave_caller_BSP, GR6_caller_BSP); // Save caller's register stack address
      __ mov(GR6_caller_BSP, AR_BSP);       // Load up BSP to test in our callees
    }

    __ mov(GR_Lsave_RP, BR0);

    if( Assembler::is_simm14(-framesize) )
      __ add(SP, -framesize, SP);
    else {
      __ mov(GR2, -framesize);
      __ add(SP, GR2, SP);
    }

    if (C->save_argument_registers()) {
      // 4815101: spill fp arg regs
      add_offset_to_stack(_masm, GR28, framesize - 16);
      add_offset_to_stack(_masm, GR29, framesize - 32);
      __ stfspill(GR28, FR8, -32);
      __ stfspill(GR29, FR9, -32);
      __ stfspill(GR28, FR10, -32);
      __ stfspill(GR29, FR11, -32);
      __ stfspill(GR28, FR12, -32);
      __ stfspill(GR29, FR13, -32);
      __ stfspill(GR28, FR14);
      __ stfspill(GR29, FR15);
    }
  }

#ifndef PRODUCT
  else if( !do_size ) {
    if (C->need_stack_bang(framesize)) {
      tty->print("! stack bang\n\t");
    }
    if (C->need_register_stack_bang()) {
      tty->print("CMP.gu PR6,PR0,GR6_caller_BSP,GR7_reg_stack_limit\n\t");
      tty->print("(PR6) ST8 [GR0]=GR0 ;;\t! reg stack overflow\n\t");
    }

    tty->print(  "ALLOC  GR_Lsave_PFS=AR.PFS,8,16,8,0\n");
    tty->print("\tMOV    GR_Lsave_SP=GR12_SP\n");

    if (C->stub_function() == NULL) {
      tty->print("\tMOV    GR_Lsave_caller_BSP=GR6_caller_BSP\n");
      tty->print("\tMOV    GR6_caller_BSP=AR.BSP\n");
    }
    tty->print("\tMOV    GR_Lsave_RP=BR0\n");

    if( Assembler::is_simm14(-framesize) )
      tty->print("\tADD    GR12_SP=GR12_SP,%d", -framesize);
    else
      tty->print("\tMOV    GR2=%d\n\tADD    GR12_SP=GR12_SP,GR2", -framesize);

    if (C->save_argument_registers()) {
      tty->print("\t! spill fp arg regs");
    }
  }
#endif
  return size;
}

#ifndef PRODUCT
void MachPrologNode::format( PhaseRegAlloc *ra_ ) const {
  (void)implementation( NULL, ra_, false );
}
#endif

void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  (void)implementation( &cbuf, ra_, false );
}

uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  ShouldNotReachHere(); 
  return 0;
}

int MachPrologNode::reloc() const {
  return 10; // a large enough number
}

//=============================================================================
#ifndef PRODUCT
void MachEpilogNode::format( PhaseRegAlloc *pc_ ) const {
  Compile* C = pc_->C;

  if (C->save_argument_registers()) {
    tty->print("! fill fp arg regs\n\t");
  }

  tty->print_cr("MOVRET BR0=GR_Lsave_RP");

  if (C->stub_function() == NULL) {
    tty->print_cr("\tMOV    GR6_caller_BSP=GR_Lsave_caller_BSP");
  }

  tty->print_cr("\tMOV    GR12_SP=GR_Lsave_SP");
  tty->print_cr("\tMOV    AR.PFS=GR_Lsave_PFS");

  if( do_polling() && SafepointPolling && C->is_method_compilation() ) {
    tty->print_cr("\tLD8    GR31_SCRATCH, [GR5_poll_page_addr]");
  }

}
#endif

void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *pc_) const {
  MacroAssembler _masm(&cbuf);
  Compile* C = pc_->C;

  // Get frame size in words
  int framesize = C->frame_size_in_words() * wordSize;

  if (C->save_argument_registers()) {
    // 4815101: fill fp arg regs
    add_offset_to_stack(_masm, GR28, framesize - 16);
    add_offset_to_stack(_masm, GR29, framesize - 32);
    __ ldffill(FR8, GR28, -32);
    __ ldffill(FR9, GR29, -32);
    __ ldffill(FR10, GR28, -32);
    __ ldffill(FR11, GR29, -32);
    __ ldffill(FR12, GR28, -32);
    __ ldffill(FR13, GR29, -32);
    __ ldffill(FR14, GR28);
    __ ldffill(FR15, GR29);
    __ flush_bundle(); // Can't let fill(s) float below memory stack pop
  }

  __ movret(BR0, GR_Lsave_RP);

  if (C->stub_function() == NULL) {
    // Restore caller's BSP
    __ mov(GR6_caller_BSP, GR_Lsave_caller_BSP);
  }

  __ mov(SP, GR_Lsave_SP);
  __ mov(AR_PFS, GR_Lsave_PFS);
  if( do_polling() && SafepointPolling && C->is_method_compilation() ) {
    __ flush_bundle();
    cbuf.set_mark();
    cbuf.relocate(cbuf.mark(), relocInfo::poll_return_type, 0); 
    __ ld8(GR31_SCRATCH, GR5_poll_page_addr);
    __ flush_bundle();
  }
}

uint MachEpilogNode::size(PhaseRegAlloc *pc_) const {
  ShouldNotReachHere(); 
  return 1; // depend on above assert
}

int MachEpilogNode::reloc() const {
  return 10; // a large enough number
}

const Pipeline * MachEpilogNode::pipeline() const {
  return addP_reg_immL14Node::pipeline_class();
};

int MachEpilogNode::safepoint_offset(void) const {
  return 0;
}

// Figure out which register class each belongs in: rc_int, rc_float, rc_stack
enum RC { rc_bad, rc_int, rc_float, rc_pred, rc_branch, rc_appl, rc_stack };

static enum RC rc_class( OptoReg::Name reg ) {
  if( reg == OptoReg::Bad ) return rc_bad;

  // Is this a general register?
  int limit = 124;
  if( reg < (OptoReg::Name)limit ) return rc_int;

  // Is this a float register?
  limit = 210;
  if( reg < (OptoReg::Name)limit ) return rc_float;

  // Is this a branch register?
  limit = 216;
  if( reg < (OptoReg::Name)limit ) return rc_branch;

  // Is this a predicate register?
  limit = 220;
  if( reg < (OptoReg::Name)limit ) return rc_appl;

  // Is this an application register?
  limit = 231;
  if( reg < (OptoReg::Name)limit ) return rc_pred;

  // Between float regs & stack are the flags regs.
  assert( reg >= SharedInfo::stack0, "blow up if spilling flags" );
  return rc_stack;
}

uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size ) const {
  // Get registers to move 
  OptoReg::Name src_hi = ra_->get_reg_hi(in(1));
  OptoReg::Name src_lo = ra_->get_reg_lo(in(1));
  OptoReg::Name dst_hi = ra_->get_reg_hi(this );
  OptoReg::Name dst_lo = ra_->get_reg_lo(this);

  enum RC src_hi_rc = rc_class(src_hi);
  enum RC src_lo_rc = rc_class(src_lo);
  enum RC dst_hi_rc = rc_class(dst_hi);
  enum RC dst_lo_rc = rc_class(dst_lo);

  assert( src_lo != OptoReg::Bad && dst_lo != OptoReg::Bad, "must move at least 1 register" );

  // Generate spill code!
  if( src_lo == dst_lo && src_hi == dst_hi ) 
    return 0;            // Self copy, no move

  // --------------------------------------
  if( src_lo_rc == rc_stack ) {

    // Memory->Memory Spill. Use GR28 to hold the value
    if( dst_lo_rc == rc_stack ) {
      int src_offset   = ra_->reg2offset(src_lo);
      int dst_offset   = ra_->reg2offset(dst_lo);
      int delta_offset = dst_offset - src_offset;

      if( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi ) {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, src_offset);

          if( Assembler::is_simm9(delta_offset) )
            __ ld8( GR28, GR29, delta_offset );
          else {
            __ ld8( GR28, GR29 );
            add_offset_to_stack(_masm, GR29, dst_offset);
          }
          __ st8( GR29, GR28 );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n", src_offset);
          if( Assembler::is_simm9(delta_offset) )
            tty->print("\tLD8    GR28=[GR29],%d ;;\t// post increment\n", delta_offset);
          else
            tty->print("\tLD8    GR28=[GR29] ;;\n\tADDS   GR29=GR12_SP,%d ;;\n", dst_offset);
          tty->print("\tST8    [GR29]=GR28\n");
        }
      }
      else {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, src_offset);

          if( Assembler::is_simm9(delta_offset) )
            __ ld4( GR28, GR29, delta_offset );
          else {
            __ ld4( GR28, GR29 );
            add_offset_to_stack(_masm, GR29, dst_offset);
          }

          __ st4( GR29, GR28 );
        } else {
          if( Assembler::is_simm14(src_offset) )
            tty->print("ADD     GR29=GR12_SP,%d ;;\n", src_offset);
          else
            tty->print("MOV     GR29=%d ;;\n\tADD     GR29=GR29,SP ;;\n", src_offset);

          if( Assembler::is_simm9(delta_offset) )
            tty->print("\tLD4     GR28=[GR29],%d ;;\t// post increment\n", delta_offset);
          else {
            tty->print("\tLD4     GR28=[GR29]\n\tADD     GR29=%d,SP ;;\n", dst_offset);
          }

          tty->print("\tST4    [GR29]=GR28 ;;");
        }
      }
    }

    // Memory -> Integer Register
    //  NOTE: this does not preserve the NaT bit!!!
    else if( dst_lo_rc == rc_int ) {
      int src_offset = ra_->reg2offset(src_lo);

      if( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi ) {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, src_offset);
          __ ld8( as_Register(Matcher::_regEncode[dst_lo]), GR29 );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n"
                   "\tLD8    %s=[GR29]",
            src_offset, SharedInfo::regName[dst_lo]);
        }
      }
      else {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, src_offset);
          __ ld4( as_Register(Matcher::_regEncode[dst_lo]), GR29 );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n"
                   "\tLD4    %s=[GR29]",
            src_offset, SharedInfo::regName[dst_lo]);
        }
      }
    }

    // Memory -> Float Register
    //  NOTE: this does not preserve extended precision
    else if( dst_lo_rc == rc_float ) {
      int src_offset =  ra_->reg2offset(src_lo);

      if( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi ) {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, src_offset);
          __ ldfd( as_FloatRegister(Matcher::_regEncode[dst_lo]), GR29 );
        } else {
          tty->print("ADDS    GR29=GR12_SP,%d ;;\n\tLDFD    %s=[GR29]",
            src_offset, SharedInfo::regName[dst_lo]);
        }
      }
      else {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, src_offset);
          __ ldfs( as_FloatRegister(Matcher::_regEncode[dst_lo]), GR29 );
        } else {
          tty->print("ADDS    GR29=GR12_SP,%d ;;\n\tLDFS    %s=[GR29]",
            src_offset, SharedInfo::regName[dst_lo]);
        }
      }
    }

    // Memory -> Branch Register, use GR28 to hold as intermediate
    else if( dst_lo_rc == rc_branch ) {
      int src_offset = ra_->reg2offset(src_lo);

      assert( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi, "branch register is 64 bits" );

      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        add_offset_to_stack(_masm, GR29, src_offset);
        __ ld8( GR28, GR29 );
        __ mov( as_BranchRegister(Matcher::_regEncode[dst_lo]), GR28 );
      } else {
        tty->print("ADDS   GR29=GR12_SP,%d ;;\n\tLD8    GR28=[GR29] ;;\n\tMOV    %s=GR28\t\t// int->branch",
          src_offset, SharedInfo::regName[dst_lo]);
      }
    }

    // Memory -> Application Register, use GR28 to hold as intermediate
    else if( dst_lo_rc == rc_appl ) {
      int src_offset = ra_->reg2offset(src_lo);

      assert( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi, "application register is 64 bits" );

      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        add_offset_to_stack(_masm, GR29, src_offset);
        __ ld8( GR28, GR29 );
        __ mov( as_ApplicationRegister(Matcher::_regEncode[dst_lo]), GR28 );
      } else {
        tty->print("ADDS   GR29=GR12_SP,%d ;;\n"
                 "\tLD8    GR28=[GR29] ;;\n"
                 "\tMOV.%c  %s=GR28",
          src_offset,
          // The different application registers can only be accessed by
          // in some cases the specific I or M units - what a pain
          Matcher::_regEncode[dst_lo] < 64 ? 'M' : 'I',
          SharedInfo::regName[dst_lo]);
      }
    } else {
      Unimplemented();
    }
  }
  
  // Source is Integer
  else if( src_lo_rc == rc_int ) {

    // Integer Register -> Memory
    if( dst_lo_rc == rc_stack ) {
      int dst_offset = ra_->reg2offset(dst_lo);

      if( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi ) {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, dst_offset);
          __ st8( GR29, as_Register(Matcher::_regEncode[src_lo]) );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n\tST8    [GR29]=%s",
            dst_offset, SharedInfo::regName[src_lo]);
        }
      }
      else {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, dst_offset);
          __ st4( GR29, as_Register(Matcher::_regEncode[src_lo]) );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n\tST4    [GR29]=%s",
            dst_offset, SharedInfo::regName[src_lo]);
        }
      }
    }

    // Integer Register -> Integer Register
    else if( dst_lo_rc == rc_int ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( as_Register(Matcher::_regEncode[dst_lo]), as_Register(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("MOV    %s=%s", SharedInfo::regName[dst_lo], SharedInfo::regName[src_lo] );
      }
    }

    // Integer Register -> Float Register (preserve integer format)
    //  NOTE: does not preserve NaT
    else if( dst_lo_rc == rc_float ) {
      Unimplemented();
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ setfsig( as_FloatRegister(Matcher::_regEncode[dst_lo]), as_Register(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("SETFSIG %s=%s", SharedInfo::regName[dst_lo], SharedInfo::regName[src_lo]);
      }
    }

    // Integer Register -> Branch Register
    else if( dst_lo_rc == rc_branch ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( as_BranchRegister(Matcher::_regEncode[dst_lo]), as_Register(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("MOV    %s=%s", SharedInfo::regName[dst_lo], SharedInfo::regName[src_lo]); 
      }
    }

    // Integer Register -> Application Register
    else if( dst_lo_rc == rc_appl ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( as_ApplicationRegister(Matcher::_regEncode[dst_lo]), as_Register(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("MOV.%c   %s=%s",
           // The different application registers can only be accessed by
           // in some cases the specific I or M units - what a pain
           Matcher::_regEncode[dst_lo] < 64 ? 'M' : 'I',
           SharedInfo::regName[dst_lo],
           SharedInfo::regName[src_lo]); 
      }
    }
    else
      Unimplemented();
  }

  // Source is Float Register
  else if( src_lo_rc == rc_float ) {

    // Float Register -> Memory
    //  NOTE: does not preserve extended precision
    if( dst_lo_rc == rc_stack ) {
      int dst_offset =  ra_->reg2offset(dst_lo);
      if( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi ) {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, dst_offset);
          __ stfd( GR29, as_FloatRegister(Matcher::_regEncode[src_lo]) );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n\tSTFD   [GR29]=%s",
            dst_offset, SharedInfo::regName[src_lo]);
        }
      }
      else {
        if( cbuf ) {
          MacroAssembler _masm(cbuf);
          add_offset_to_stack(_masm, GR29, dst_offset);
          __ stfs( GR29, as_FloatRegister(Matcher::_regEncode[src_lo]) );
        } else {
          tty->print("ADDS   GR29=GR12_SP,%d ;;\n\tSTFS   [GR29]=%s",
            dst_offset, SharedInfo::regName[src_lo]);
        }
      }
    }

    // Float Register -> Integer Register
    else if( dst_lo_rc == rc_int ) {
      Unimplemented();
    }

    else if( dst_lo_rc == rc_float ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( as_FloatRegister(Matcher::_regEncode[dst_lo]), as_FloatRegister(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("MOV    %s=%s\t\t// float\n", SharedInfo::regName[dst_lo], SharedInfo::regName[src_lo]); 
      }
    }
    else
      Unimplemented();
  }

  // Source is Branch Register
  else if( src_lo_rc == rc_branch ) {

    // Branch Register -> Integer Register
    if( dst_lo_rc == rc_int ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( as_Register(Matcher::_regEncode[dst_lo]), as_BranchRegister(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("MOV    %s=%s\t// branch->int", SharedInfo::regName[dst_lo], SharedInfo::regName[src_lo]); 
      }
    }

    // Branch Register -> Memory
    else if( dst_lo_rc == rc_stack ) {
      int dst_offset = ra_->reg2offset(dst_lo);

      assert( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi, "branch register is 64 bits" );
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        add_offset_to_stack(_masm, GR29, dst_offset);
        __ mov( GR28, as_BranchRegister(Matcher::_regEncode[src_lo]) );
        __ st8( GR29, GR28 );
      } else {
        tty->print("ADDS   GR29=GR12_SP,%d\n\tMOV    GR28=%s ;;\t// branch->int\n\tST8    [GR29]=GR28",
          dst_offset, SharedInfo::regName[src_lo]);
      }
    }

    // Branch Register -> Branch Register (this is hard)
    else if( dst_lo_rc == rc_branch ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( GR28, as_BranchRegister(Matcher::_regEncode[src_lo]) );
        __ mov( as_Register(Matcher::_regEncode[dst_lo]), GR28 );
      } else {
        tty->print("MOV    GR28=%s\t// branch->int\n\tMOV    %s=GR28\t\t// int->branch",
          SharedInfo::regName[src_lo], SharedInfo::regName[dst_lo]); 
      }
    }

    else
      Unimplemented();
  }

  // Source is Application Register
  else if( src_lo_rc == rc_appl ) {

    // Application Register -> Integer Register
    if( dst_lo_rc == rc_int ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( as_Register(Matcher::_regEncode[dst_lo]), as_ApplicationRegister(Matcher::_regEncode[src_lo]) );
      } else {
        tty->print("MOV.%c   %s=%s\t// appl->int",
          // The different application registers can only be accessed by
          // in some cases the specific I or M units - what a pain
          Matcher::_regEncode[src_lo] < 64 ? 'M' : 'I',
          SharedInfo::regName[dst_lo],
          SharedInfo::regName[src_lo]); 
      }
    }

    // Application Register -> Memory
    else if( dst_lo_rc == rc_stack ) {
      int dst_offset =  ra_->reg2offset(dst_lo);
      assert( (src_lo&1)==0 && src_lo+1 == src_hi && (dst_lo&1)==0 && dst_lo+1 == dst_hi, "application register is 64 bits long" );

      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        add_offset_to_stack(_masm, GR29, dst_offset);
        __ mov( GR28, as_ApplicationRegister(Matcher::_regEncode[src_lo]) );
        __ st8( GR29, GR28 );
      } else {
        tty->print("ADDS   GR29=GR12_SP,%d\n"
                   "\tMOV.%c  GR28=%s ;;\n"
                   "\tST8    [GR29]=GR28",
          dst_offset,
          // The different application registers can only be accessed by
          // in some cases the specific I or M units - what a pain
          Matcher::_regEncode[src_lo] < 64 ? 'M' : 'I',
          SharedInfo::regName[src_lo]);
      }
    }

    // Application Register -> Application Register (this is hard)
    else if( dst_lo_rc == rc_appl ) {
      if( cbuf ) {
        MacroAssembler _masm(cbuf);
        __ mov( GR28, as_ApplicationRegister(Matcher::_regEncode[src_lo]) );
        __ mov( as_ApplicationRegister(Matcher::_regEncode[dst_lo]), GR28 );
      } else {
        tty->print("MOV.%c   GR28=%s\t\t// appl->int\n"
                 "\tMOV.%c   %s=GR28\t\t// int->appl",
          // The different application registers can only be accessed by
          // in some cases the specific I or M units - what a pain
          Matcher::_regEncode[src_lo] < 64 ? 'M' : 'I',
          SharedInfo::regName[src_lo],
          Matcher::_regEncode[dst_lo] < 64 ? 'M' : 'I',
          SharedInfo::regName[dst_lo]); 
      }
    }

    else
      Unimplemented();
  }

  // The remaining cannot be spilled (yet)
  else
    Unimplemented();

  return 0;
}

#ifndef PRODUCT
void MachSpillCopyNode::format( PhaseRegAlloc *ra_ ) const {
  implementation( NULL, ra_, false );
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  implementation( &cbuf, ra_, false );
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  return implementation( NULL, ra_, true );
}

//=============================================================================
#ifndef PRODUCT
void MachNopNode::format( PhaseRegAlloc * ) const {
  tty->print("NOP    \t// Pad for loops");
}
#endif

void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc * ) const {
  // No eog() for NOPs, since padding needs to be on bundle boundaries
  // and C2 has no clue about bundles right now.
  // MacroAssembler _masm(&cbuf);
  // __ eog();
  MacroAssembler _masm(&cbuf);
  __ flush_bundle();
  __ nopm(); 
  __ flush_bundle();
}

uint MachNopNode::size(PhaseRegAlloc *pc_) const {
  // Size is kind of fuzzy on ia64 but this is ok because
  // we never shorten branches and we just need a reasonable
  // result. Since our intent is to make sure a nop fills
  // a bundle this is a reasonable result.
  return 1 * Pipeline::bundle_unit_size();  // nop in its own bundle
}

//=============================================================================
#ifndef PRODUCT
void BoxLockNode::format( PhaseRegAlloc *pc_ ) const {
  int offset = pc_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = pc_->get_reg_lo(this);
  assert( Assembler::is_simm14(offset), "frame sizes must be reasonable" );

  if (Assembler::is_simm14(offset))
    tty->print( "ADDS   %s=GR12_SP,%d\t// box node", Matcher::regName[reg], offset);
}
#endif

void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *pc_) const {
  MacroAssembler _masm(&cbuf);
  int offset = pc_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = pc_->get_encode(this);
  assert( Assembler::is_simm14(offset), "frame sizes must be reasonable" );

  if (Assembler::is_simm14(offset))
     __ adds(as_Register(reg), offset, SP);
}

uint BoxLockNode::size(PhaseRegAlloc *pc_) const {
  ShouldNotReachHere(); return 1;
}

//=============================================================================

// emit call stub, compiled java to interpretor
void emit_java_to_interp(CodeBuffer &cbuf ) {

  // Stub is fixed up when the corresponding call is converted from calling
  // compiled code to calling interpreted code.
  // set (empty), G5
  // jmp -1

  MacroAssembler _masm(&cbuf);

  __ flush_bundle();
  cbuf.start_a_stub();

  // static stub relocation stores the instruction address of the call
  cbuf.relocate(cbuf.code_end(), 
        static_stub_Relocation::spec(cbuf.mark()));

  __ mova(as_Register(Matcher::inline_cache_reg_encode()), NULL, relocInfo::oop_type);

  Register method_oop_reg = as_Register(Matcher::compiler_method_oop_reg_encode());

  cbuf.set_mark();
  __ mova(method_oop_reg, (address)-1);
  __ mov(BR7_SCRATCH, method_oop_reg);
  __ br(BR7_SCRATCH);
  __ flush_bundle();

  // Update current stubs pointer and restore code_end.
  cbuf.end_a_stub();
}

// size of call stub, compiled java to interpretor
uint size_java_to_interp() {
  Unimplemented();
  return 5 * wordSize;  // sethi/setlo; sethi; jmp; nop
}

// relocation entries for call stub, compiled java to interpretor
uint reloc_java_to_interp() {
  Unimplemented();
  return 10;  // 4 in emit_java_to_interp + 1 in Java_Static_Call
}

uint offset_start_of_table() {
   return 0; 
}

//=============================================================================
#ifndef PRODUCT
void MachUEPNode::format( PhaseRegAlloc *pc_ ) const {
  OptoReg::Name inline_cache = Matcher::inline_cache_reg();
  OptoReg::Name method_oop   = Matcher::compiler_method_oop_reg();

  tty->print_cr( "---- MachUEPNode ----");
  tty->print_cr( "\tADDS   GR2=I0,%d", oopDesc::klass_offset_in_bytes() );
  tty->print_cr( "\tMOVL   GR3=handle_ic_miss_stub" );

  char * check = "";

  if( !ImplicitNullChecks ) {
    tty->print_cr( "\tCMP.ne PR7,PR6=I0,GR0 ;;" );
    check = "(PR7) ";
  }

  tty->print_cr( "\t%sLD8    %s=[GR2]\t// load actual receiver", check, SharedInfo::regName[method_oop] );
  tty->print_cr( "\tMOV    BR6=GR3 ;;" );
  tty->print_cr( "\t%sCMP.ne PR6,PR0=%s,%s", check, SharedInfo::regName[method_oop], SharedInfo::regName[inline_cache] );
  tty->print   ( "\t(PR6) BR BR6 ;;" );
}
#endif

void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *pc_) const {
  MacroAssembler _masm(&cbuf);
  Register inline_cache_reg = as_Register(Matcher::inline_cache_reg_encode());
  Register method_oop_reg   = as_Register(Matcher::compiler_method_oop_reg_encode());

  // Verify that the registers are disjoint
  assert( inline_cache_reg != method_oop_reg &&
          inline_cache_reg != GR2_SCRATCH &&
          inline_cache_reg != GR3_SCRATCH,
    "conflicting registers in MachUEPNode::emit" );


  // Compute the address of the klass field
  __ add( GR2_SCRATCH, oopDesc::klass_offset_in_bytes(), GR_I0 );

  // Load the address of the ic miss code
  __ mova( GR3_SCRATCH, OptoRuntime::handle_ic_miss_stub(), relocInfo::runtime_call_type );

  // See if the base pointer is NULL
  PredicateRegister Not_Null_Predicate = PR0;

  if( !ImplicitNullChecks ) {
    Not_Null_Predicate = PR7_SCRATCH;
    __ cmp( Not_Null_Predicate, PR6_SCRATCH, GR_I0, GR0, Assembler::notEqual );
  }

  __ eog();

  // Load klass from receiver
  __ ld8( Not_Null_Predicate, method_oop_reg, GR2_SCRATCH );

  // Copy the ic miss address to the branch register
  __ movi( BR6_SCRATCH, GR3_SCRATCH );
  __ eog();

  // Compare against expected klass
  __ cmp( Not_Null_Predicate, PR6_SCRATCH, PR0, method_oop_reg, inline_cache_reg, Assembler::notEqual );

  // Branch to miss code if not the same
  __ br ( PR6_SCRATCH, BR6_SCRATCH, Assembler::spnt );
  __ flush_bundle();
}

uint MachUEPNode::size(PhaseRegAlloc *pc_) const {
  ShouldNotReachHere(); return 0;
}

//=============================================================================
#ifndef PRODUCT
void MachC2IEntriesNode::format( PhaseRegAlloc *pc_ ) const {
  OptoReg::Name ic_reg     = Matcher::inline_cache_reg();
  OptoReg::Name method_oop = Matcher::interpreter_method_oop_reg();

  tty->print_cr( "---- MachC2IEntriesNode ----");
  tty->print_cr( "\tADDS   GR14=I0,%d", oopDesc::klass_offset_in_bytes() );
  tty->print_cr( "\tADDS   GR15=%s,%d", SharedInfo::regName[ic_reg], compiledICHolderOopDesc::holder_klass_offset() );
  tty->print_cr( "\tMOVL   GR16=handle_ic_miss_stub");

  char *check = "";

  if( !ImplicitNullChecks ) {
    tty->print_cr( "\tCMP.ne PR7,PR6=I0,GR0 ;;" );
    check = "(PR7) ";
  }

  tty->print_cr( "\tADDS   %s=%s,%d", SharedInfo::regName[ic_reg], 
                                      SharedInfo::regName[ic_reg],
				      compiledICHolderOopDesc::holder_method_offset() );
  tty->print_cr( "\tLD8    GR2=[GR15]" );          // R2 == ic klass
  tty->print_cr( "\t%sLD8    GR3=[GR14]", check ); // R3 == rcvr klass
  tty->print_cr( "\tMOV    BR6=GR16 ;;" );
  tty->print_cr( "\t%sLD8    %s=[%s]", check, SharedInfo::regName[method_oop], SharedInfo::regName[ic_reg] );
  tty->print_cr( "\t%sCMP.ne PR6,PR0=%s,GR2", check, SharedInfo::regName[method_oop] );
  tty->print   ( "\t(PR6) BR     BR6 ;;" );
}
#endif

void MachC2IEntriesNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *pc_) const {
  MacroAssembler _masm(&cbuf);
  Label L;
  Register ic_reg     = as_Register(Matcher::inline_cache_reg_encode());
  Register method_reg   = as_Register(Matcher::interpreter_method_oop_reg_encode());
  Register ic_klass = GR2_SCRATCH;
  Register ic_klass_addr = GR15_SCRATCH;
  Register rcvr_klass = GR3_SCRATCH;
  Register rcvr_klass_addr = GR14_SCRATCH;

  // Check that the registers are distinct

  assert( ic_reg   != ic_klass,   "registers must be distinct");
  assert( ic_reg   != ic_klass_addr, "registers must be distinct");

  assert( ic_reg   != rcvr_klass,   "registers must be distinct");
  assert( ic_reg   != rcvr_klass_addr, "registers must be distinct");

  // ------ MKH Entry Point, Unverified
  // Receives the MethodKlassHolder in inline_cache_reg
  int disp = oopDesc::klass_offset_in_bytes();

  // Compute the address
  __ add( rcvr_klass_addr, disp, GR_I0 );	// Address of rcvr klass
  __ mova( GR16_SCRATCH, OptoRuntime::handle_ic_miss_stub(), relocInfo::runtime_call_type );
  __ add( ic_klass_addr, compiledICHolderOopDesc::holder_klass_offset(), ic_reg );

  PredicateRegister Not_Null_Predicate = PR0;

  if( !ImplicitNullChecks ) {
    Not_Null_Predicate = PR7_SCRATCH;
    __ cmp( Not_Null_Predicate, PR6_SCRATCH, GR_I0, GR0, Assembler::notEqual );
  }

  __ eog();

  __ ld8( Not_Null_Predicate, rcvr_klass, rcvr_klass_addr );
  __ ld8( ic_klass,   ic_klass_addr );
  __ add( ic_reg, compiledICHolderOopDesc::holder_method_offset(), ic_reg );
  __ movi( BR6_SCRATCH, GR16_SCRATCH );
  __ eog();

  __ ld8( method_reg, ic_reg );
  __ cmp( Not_Null_Predicate, PR6_SCRATCH, PR0, rcvr_klass, ic_klass, Assembler::notEqual );
  __ br( PR6_SCRATCH, BR6_SCRATCH, Assembler::spnt );
  __ flush_bundle();
}

uint MachC2IEntriesNode::size(PhaseRegAlloc *pc_) const {
  ShouldNotReachHere(); return 0;
}


//=============================================================================

#ifndef PRODUCT
void MachC2IcheckICNode::format( PhaseRegAlloc *pc_ ) const {
  OptoReg::Name method_oop = Matcher::inline_cache_reg();

  tty->print_cr( "---- MachC2IcheckICNode ----");
  tty->print_cr( "\tADDS   GR2=%s,%d", SharedInfo::regName[method_oop], in_bytes(methodOopDesc::compiled_code_offset()) );
  tty->print_cr( "\tMOVA   GR3=handle_wrong_method_stub ;;" );
  tty->print_cr( "\tLD8    GR2=[GR2]" );
  tty->print_cr( "\tMOV    BR6=GR3 ;;" );
  tty->print_cr( "\tCMP    PR0,PR6,0,GR2" );
  tty->print   ( "\t(PR6) BR BR6 ;;" );
}
#endif

void MachC2IcheckICNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *pc_) const {  
  const Register method_oop_reg     = as_Register(Matcher::inline_cache_reg_encode());
  const Register compiled_code_addr = GR2_SCRATCH;
  const Register compiled_code      = compiled_code_addr;
  const Register handle_wrong_method= GR3_SCRATCH;

  MacroAssembler _masm(&cbuf);

  __ add(compiled_code_addr, method_oop_reg, in_bytes(methodOopDesc::compiled_code_offset()));
  __ mova(handle_wrong_method, OptoRuntime::handle_wrong_method_stub(), relocInfo::runtime_call_type);

  __ ld8(compiled_code, compiled_code_addr);
  __ mov(BR6_SCRATCH, handle_wrong_method);

  __ cmp(PR0, PR6_SCRATCH, 0, compiled_code, Assembler::equal);
  __ br(PR6_SCRATCH, BR6_SCRATCH, Assembler::spnt);
  __ flush_bundle();
}

uint MachC2IcheckICNode::size(PhaseRegAlloc *pc_) const {
  ShouldNotReachHere(); return 0;
}

// Emit exception handler code.
void emit_exception_handler( CodeBuffer &cbuf ) {
  MacroAssembler _masm(&cbuf);
  // Mark the beginning of the exception handler
  cbuf.set_exception_offset(cbuf.code_size());


  address exception_addr = OptoRuntime::exception_blob() ?
    OptoRuntime::exception_blob()->instructions_begin() : NULL;

  Register target_reg = as_Register(Matcher::compiler_method_oop_reg_encode());

  // __ os_breakpoint();
  __ mova(target_reg, exception_addr, relocInfo::runtime_call_type);
  __ eog();

  __ movi(BR7_SCRATCH, target_reg);
  __ br  (BR7_SCRATCH);
  __ flush_bundle();

  // deoptimization trampoline hides out after normal exception handler
  // deopt blob isn't created early enough so we just do an example template
  // here. 
  __ mova(GR2_SCRATCH, NULL, relocInfo::runtime_call_type);
  __ eog();

  __ movi(BR7_SCRATCH, target_reg);
  __ br  (BR7_SCRATCH);
  __ flush_bundle();
}

uint size_exception_handler() {
  return 4 * Pipeline::bundle_unit_size();  // movl;; movtobr; br
}

int Matcher::regnum_to_fpu_offset(int regnum) {
  Unimplemented();
  return regnum - 128; // The FP registers are in the second chunk
}

#ifdef ASSERT
address last_rethrow = NULL;  // debugging aid for Rethrow encoding
#endif

// JumpTable support
const bool Matcher::jumpTableSupported(void) {
  return false;
}

// This is UltraSparc specific, true just means we have fast l2f conversion
const bool Matcher::convL2FSupported(void) {
  return true;
}

// Is this branch offset short enough that a short branch can be used?
//
// NOTE: If the platform does not provide any short branch variants, then
//       this method should return false for offset 0.
bool Matcher::is_short_branch_offset(int offset) {
  return false;
}

// Should the Matcher clone shifts on addressing modes, expecting them to
// be subsumed into complex addressing expressions or compute them into
// registers?  True for Intel but false for most RISCs
// Itanium is unusual in that it has a shift-and-add instruction
const bool Matcher::clone_shift_expressions = false;

// Is it better to copy float constants, or load them directly from memory?
// Intel can load a float constant from a direct address, requiring no
// extra registers.  Most RISCs will have to materialize an address into a
// register first, so they would do better to copy the constant from stack.
const bool Matcher::rematerialize_float_constants = false;

// If CPU can load and store mis-aligned doubles directly then no fixup is 
// needed.  Else we split the double into 2 integer pieces and move it 
// piece-by-piece.  Only happens when passing doubles into C code as the 
// Java calling convention forces doubles to be aligned.
const bool Matcher::misaligned_doubles_ok = false;

// No-op on SPARC.
void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
}

// Advertise here if the CPU requires explicit rounding operations
// to implement the UseStrictFP mode.
const bool Matcher::strict_fp_requires_explicit_rounding = false;

// Do floats take an entire double register or just half?
const bool Matcher::float_in_double = true;

// Do ints take an entire long register or just half?
// Note that we if-def off of _LP64.
// The relevant question is how the int is callee-saved.  In _LP64
// the whole long is written but de-opt'ing will have to extract
// the relevant 32 bits, in not-_LP64 only the low 32 bits is written.
const bool Matcher::int_in_long = true;

// What is the range of offsets for allocator spill instructions?
// Offsets larger than this will encode to a 'large' instruction and
// offsets same size or smaller will encode to a 'small' instruction.
// On Sparc the 'small' offset is from 0 to 4095; offsets larger than
// this will not have any sane encoding (there's no spare register to
// build up a large offset).  However, 4095 should be plenty large
// enough.  On Intel the 'small' offset is from 0 to 127; 'large' offsets
// are +128 on up.  The allocator will match both large and small versions
// of load/store [SP+offset] instructions, and will clone such instructions
// in fixup_spills and patch in the correct offset.
const int Matcher::short_spill_offset_limit = 8192;

// Return whether or not this register is ever used as an argument.  This
// function is used on startup to build the trampoline stubs in generateOptoStub.  
// Registers not mentioned will be killed by the VM call in the trampoline, and 
// arguments in those registers not be available to the callee.
bool Matcher::can_be_arg( int reg ) {
  if( reg >= I7_num && reg <= I0H_num ) return true;
  if( reg >= FR8_num && reg <= FR15H_num ) return true;
  return false;
}

bool Matcher::is_spillable_arg( int reg ) {
  if( reg >= I7_num && reg <= I0H_num ) return true;
  return false;
}

#if 0
// Which register is used to pass the oop to the exception rethrow stub?
int Matcher::pd_rethrow_oop_register() {
  return PD_RETHROW_OOP_REGISTER;
}

// The spill-handling logic in the register allocator assumes that it
// can copy any register to any other register, and that it can move
// any register to or from memory, by means of ideal Copy<T>, Load<T>,
// and Store<T> operations.  If this is not true, then the following
// routine must be prepared to issue special copy instructions to
// handle the non-idealizable copies.  For example, SPARC calling
// conventions (for native mathods only) require outgoing float values
// to be placed into integer registers.  This cannot be done by ideal
// Copy instructions, which are deprecated.  (The ideal instructions assume 
// that float values are stored only in float registers, and 
// int values in int registers.)
Node* Matcher::pd_check_special_copy(const RegMask &dmask, const RegMask &umask, Node* def, Node* n, uint inpidx) {
  if (!dmask.overlap(umask)) {
    // We sometimes need to move a float value into an int register
    // because of native method calling conventions.  There is no
    // corresponding need to move an int into a float.
    if (Matcher::idealreg2regmask[Op_RegF]->overlap(dmask) &&
	Matcher::idealreg2regmask[Op_RegI]->overlap(umask)) {
      const Type* t = def->bottom_type();
      switch (t->_base) {
      case Type::FloatCon: {
        // We are materializing a constant into an int register.
        Node* con = ConNode::construct(TypeInt::make(jint_cast(t->getf())));
	return match_tree(con);
      }
      case Type::FloatBot: {
	// Load it via a trip through memory.
	SpillCopyNode* spill = new(1) SpillCopyNode(def, dmask, C->FIRST_STACK_mask);
	// When loading it back out of memory, we will produce an int value.
	spill->_type = TypeInt::INT;
	return spill;
      }
      case Type::DoubleBot: {
	// Load it via a trip through memory.
	SpillCopyNode* spill = new(1) SpillCopyNode(def, dmask, C->FIRST_STACK_mask);
	// When loading it back out of memory, we will produce an int value.
	spill->_type = t;
	return spill;
      }
      default: ShouldNotReachHere();
      }
    }
  }
  return NULL;
}
#endif

extern "C" {
  void throw_stack_overflow(void) { fatal("stack overflow"); }
};
%}

//----------ENCODING BLOCK-----------------------------------------------------
// This block specifies the encoding classes used by the compiler to output
// byte streams.  Encoding classes are parameterized macros used by 
// Machine Instruction Nodes in order to generate the bit encoding of the
// instruction.  Operands specify their base encoding interface with the
// interface keyword.  There are currently supported four interfaces,
// REG_INTER, CONST_INTER, MEMORY_INTER, & COND_INTER.  REG_INTER causes an
// operand to generate a function which returns its register number when
// queried.   CONST_INTER causes an operand to generate a function which
// returns the value of the constant when queried.  MEMORY_INTER causes an
// operand to generate four functions which return the Base Register, the
// Index Register, the Scale Value, and the Offset Value of the operand when
// queried.  COND_INTER causes an operand to generate six functions which
// return the encoding code (ie - encoding bits for the instruction)
// associated with each basic boolean condition for a conditional instruction.
//
// Instructions specify two basic values for encoding.  Again, a function
// is available to check if the constant displacement is an oop. They use the
// ins_encode keyword to specify their encoding classes (which must be 
// a sequence of enc_class names, and their parameters, specified in
// the encoding block), and they use the
// opcode keyword to specify, in order, their primary, secondary, and
// tertiary opcode.  Only the opcode sections which a particular instruction
// needs for encoding need to be specified.
encode %{
  enc_class enc_untested %{
#ifdef ASSERT
    MacroAssembler _masm(&cbuf);
    __ untested("encoding");
#endif
  %}

  enc_class emit_eog() %{
    MacroAssembler _masm(&cbuf);
    __ eog();
  %}

  enc_class emit_flush_bundle() %{
    MacroAssembler _masm(&cbuf);
    __ flush_bundle();
  %}

  enc_class emit_safepoint_poll() %{
    MacroAssembler _masm(&cbuf);
    if ( SafepointPolling ) {
      __ flush_bundle();
      cbuf.relocate(cbuf.mark(), relocInfo::poll_type, 0);
      __ ld8(GR31_SCRATCH, GR5_poll_page_addr);
      __ flush_bundle();
    }
  %}

  enc_class emit_absD_reg( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fabs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_absF_reg( fRegF dst, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fabs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_addD_reg_reg( fRegD dst, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ faddd( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg) );
  %}

  enc_class emit_addF_reg_reg( fRegF dst, fRegF src1, fRegF src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fadds( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg) );
  %}

  enc_class emit_addI_reg_imm14( gRegI dst, gRegI src1, immI14 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addI_reg_imm22( gRegI dst, gRegI src1, immI22 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ addl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addI_reg_reg( gRegI dst, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ add( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_addL_reg_imm14( gRegL dst, gRegL src1, immL14 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addL_reg_imm22( gRegL dst, gRegL src1, immL22 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ addl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addL_reg_reg( gRegL dst, gRegL src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ add( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_addP_reg_immI14( gRegP dst, gRegP src1, immI14 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addP_reg_immL14( gRegP dst, gRegP src1, immL14 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addP_reg_immI22( gRegP dst, gRegP src1, immI22 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ addl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addP_reg_immL22( gRegP dst, gRegP src1, immL22 src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ addl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src2$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_addP_reg_reg( gReg dst, gRegP src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ add( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_andI_imm8_reg( gRegI dst, immI8 src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ and3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_andI_31_reg( gRegI dst, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ and3( as_Register($dst$$reg), 31, as_Register($src$$reg) );
  %}

  enc_class emit_andI_63_reg( gRegI dst, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ and3( as_Register($dst$$reg), 63, as_Register($src$$reg) );
  %}

  enc_class emit_andI_reg_reg( gRegI dst, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ and3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_andL_imm8_reg( gRegL dst, immL8 src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ and3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_andL_reg_reg( gRegL dst, gRegL src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ and3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class enc_box_handle( iRegP dst ) %{
    int offset = ra_->reg2offset(ra_->get_reg_lo(in(1)));
    assert( Assembler::is_simm14(offset), "need a fancier encoding" );
    MacroAssembler _masm(&cbuf);
    __ adds( as_Register($dst$$reg), offset, SP );
  %}

  enc_class emit_subD_reg_reg( fRegD dst, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fsubd( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg) );
  %}

  enc_class emit_subF_reg_reg( fRegF dst, fRegF src1, fRegF src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fsubs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg) );
  %}

/*
  enc_class emit_atomic_fetchadd_imm(gRegP dst, gRegP mem, immI14 inc, gRegI tmp) %{
    MacroAssembler _masm(&cbuf);
    Register Rtmp = as_Register($tmp$$reg);
    Register Rmem = as_Register($mem$$reg);
    Register Rdst = as_Register($dst$$reg);

    assert(Rmem != Rtmp && Rmem != Rdst, "");

    Label retry;
    __ bind(retry);
    __ ld8(Rtmp, Rmem);            // Load current Contents of Memory
    __ mov(AR_CCV, Rtmp);          // Load Compare Value application register
    __ add(Rdst, Rtmp, inc);       // Want the new contents to be
    __ cmpxchg8(Rtmp, Rmem, Rdst); // Swap in Rtmp if Compare succeeds
    __ chk(Rtmp, retry);           // Retry if the compare-and-exchange failed
  %}

  enc_class emit_atomic_fetchadd_reg(gRegP dst, gRegP mem, gRegI inc, gRegI tmp) %{
    MacroAssembler _masm(&cbuf);
    Register Rtmp = as_Register($tmp$$reg);
    Register Rmem = as_Register($mem$$reg);
    Register Rdst = as_Register($dst$$reg);
    Register Rinc = as_Register($inc$$reg);

    assert(Rmem != Rtmp && Rinc != Rtmp, "");

    Label retry;
    __ bind(retry);
    __ ld8(Rtmp, Rmem);            // Load current Contents of Memory
    __ mov(AR_CCV, Rtmp);         // Load Compare Value application register
    __ add(Rdst, Rtmp, Rinc);      // Want the new contents to be
    __ cmpxchg8(Rtmp, Rmem, Rdst); // Swap in Rtmp if Compare succeeds
    __ chk(Rtmp, retry);           // Retry if the compare-and-exchange failed
  %}
*/

  enc_class emit_branch( label labl, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ br( as_PredicateRegister($qp$$reg), *($labl$$label), Assembler::dptk );
  %}

  enc_class emit_loop_end( label labl, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ br( as_PredicateRegister($qp$$reg), *($labl$$label), Assembler::sptk );
  %}

  // Compiler ensures base is doubleword aligned and cnt is count of doublewords
  enc_class enc_Clear_Array(gRegI cnt, gRegP base, gr28_gRegP tmp1, gr29_gRegP tmp2, gr30_gRegL tmp3, pr6_pReg success) %{
    MacroAssembler _masm(&cbuf);
    Register            cnt  = as_Register($cnt$$reg);
    Register            base = as_Register($base$$reg);
    Register            tmp1 = as_Register($tmp1$$reg);
    Register            tmp2 = as_Register($tmp2$$reg);
    Register            tmp3 = as_Register($tmp3$$reg);
    PredicateRegister   qp   = as_PredicateRegister($success$$reg);

    Label skip_all;
    Label skip_loop;
    Label loop_start;

    // Divide the count of doublewords by 2 and extend to long
    __ extr( tmp3, cnt, 1, 32-1 );

    // Copy the pointer to a scratch register
    __ mov( tmp1, base );

    // Check for positive number of elements
    __ cmp( qp, PR0, cnt, GR0, Assembler::lessEqual );

    // Loop counts down to zero
    __ sub( tmp3, tmp3, 1 );

    // Copy the pointer, incremented by 8 bytes
    __ add( tmp2, 8, tmp1 );

    __ br( qp, skip_all, Assembler::dpnt );

    // Check for negative trip count
    __ cmp( qp, PR0, tmp3, GR0, Assembler::less );

    // Check for positive number of elements
    __ br( qp, skip_loop, Assembler::dpnt );

    // Could use a brp (branch predict) here

    // Start the loop
    __ bind( loop_start );

    // Clear the doublewords
    __ cmp( qp, PR0, tmp3, GR0, Assembler::notEqual );
    __ st8( tmp1, GR0, 16 );
    __ st8( tmp2, GR0, 16 );
    __ eog();

    __ sub( qp, tmp3, tmp3, 1 );
    __ br( qp, loop_start );

    // End the loop
    __ bind(skip_loop);

    // See if the count is odd (for after the loop)
    __ extr( tmp3, cnt, 0, 1 );

    // Compare vs 0
    __ cmp( qp, PR0, tmp3, GR0, Assembler::notEqual );

    // Conditionally do the clear of the last element
    __ st8( qp, tmp1, GR0 );

    // End the clear operation
    __ bind(skip_all);
  %}

  enc_class enc_String_Compare(gRegI dst_arg, gRegP_notmp str1_arg, gRegP_notmp str2_arg, gr2_gRegP tmp1_arg, gr3_gRegP tmp2_arg, gr28_gRegP tmp3_arg, gr29_gRegP tmp4_arg, gr30_gRegP tmp5_arg, gr31_gRegP tmp6_arg, pr6_pReg pred1_arg, pr7_pReg pred2_arg ) %{
    Label Ldone, Lloop, Lexit;
    MacroAssembler _masm(&cbuf);

    Register          dst  = as_Register($dst_arg$$reg);
    Register          str1 = as_Register($str1_arg$$reg);
    Register          str2 = as_Register($str2_arg$$reg);
    Register          tmp1 = as_Register($tmp1_arg$$reg);
    Register          tmp2 = as_Register($tmp2_arg$$reg);
    Register          tmp3 = as_Register($tmp3_arg$$reg);
    Register          tmp4 = as_Register($tmp4_arg$$reg);
    Register          tmp5 = as_Register($tmp5_arg$$reg);
    Register          tmp6 = as_Register($tmp6_arg$$reg);
    PredicateRegister pr1  = as_PredicateRegister($pred1_arg$$reg);
    PredicateRegister pr2  = as_PredicateRegister($pred2_arg$$reg);

    // Get the first character position in both strings
    int  value_offset = java_lang_String:: value_offset_in_bytes();
    int offset_offset = java_lang_String::offset_offset_in_bytes();
    int  count_offset = java_lang_String:: count_offset_in_bytes();

    // load (jchar*) base address
    __ add( tmp1, value_offset, str1 );
    __ add( tmp2, value_offset, str2 );

    // Compare the string addresses
    __ cmp( pr1, pr2, str1, str2, Assembler::equal );
    __ eog();

    // Load the base address
    __ ld8( pr2, tmp3, tmp1, offset_offset - value_offset );
    __ ld8( pr2, tmp4, tmp2, offset_offset - value_offset );
    __ mov( pr1, dst, 0 );
    __ eog();

    // Get the offset
    __ ld4( pr2, tmp5, tmp1, count_offset - offset_offset );
    __ ld4( pr2, tmp6, tmp2, count_offset - offset_offset );
    __ br ( pr1, Ldone );
    __ eog();

    // compute the pointer to the start of the strings
    __ shladd( tmp3, tmp5, exact_log2(sizeof(jchar)), tmp3 );
    __ shladd( tmp4, tmp6, exact_log2(sizeof(jchar)), tmp4 );
    __ eog();

    // Get the lengths, in elements
    __ ld4( tmp5, tmp1 );
    __ ld4( tmp6, tmp2 );

    // Get the address of the data
    __ add( tmp3, tmp3, arrayOopDesc::base_offset_in_bytes(T_CHAR) );
    __ add( tmp4, tmp4, arrayOopDesc::base_offset_in_bytes(T_CHAR) );
    __ eog();

    // See if the lengths are different, and calculate min
    // Save diff in case we need it for a tie-breaker.
    __ cmp4( pr1, pr2, tmp5, tmp6, Assembler::less );
    __ eog();

    __ mov( pr1, tmp1, tmp5 );
    __ mov( pr2, tmp1, tmp6 );
    __ eog();

    __ sub( tmp2, tmp5, tmp6 );
    __ cmp4( pr1, pr2, tmp1, GR0, Assembler::equal );
    __ eog();

    __ ld2( pr2, tmp5, tmp3, sizeof(jchar) );
    __ ld2( pr2, tmp6, tmp4, sizeof(jchar) );
    __ add( pr2, tmp1, -1, tmp1 );
    __ mov( pr1, dst, tmp2 );
    __ br( pr1, Ldone );

    // Live Regs in Loop: tmp1 tmp3 tmp4 tmp5 tmp6
  __ bind( Lloop );
    __ cmp( pr1, PR0, tmp1, GR0, Assembler::greater );
    __ cmp( pr2, PR0, tmp5, tmp6, Assembler::notEqual );
    __ br ( pr2, Lexit );
    __ eog();

    __ ld2( pr1, tmp5, tmp3, sizeof(jchar) );
    __ ld2( pr1, tmp6, tmp4, sizeof(jchar) );
    __ add( tmp1, -1, tmp1 );
    __ br( pr1, Lloop );

    // Fell thru, return the difference in lengths
    __ mov( dst, tmp2 );
    __ br( Ldone );

    // exited the loop
  __ bind( Lexit );
    __ sub( dst, tmp5, tmp6 );

  __ bind( Ldone );
  %}

  enc_class emit_illtrap() %{
    MacroAssembler _masm(&cbuf);
    __ flush_bundle();

    // The break is forced to be in a bundle by itself
    //   (because I felt like it)
    __ breaki(1);
    __ flush_bundle();
  %}

  enc_class emit_nopb() %{
    MacroAssembler _masm(&cbuf);
    __ nopb();
  %}

  enc_class emit_nopf() %{
    MacroAssembler _masm(&cbuf);
    __ nopf();
  %}

  enc_class emit_nopi() %{
    MacroAssembler _masm(&cbuf);
    __ nopi();
  %}

  enc_class emit_nopm() %{
    MacroAssembler _masm(&cbuf);
    __ nopm();
  %}

  enc_class emit_cmp4_reg_reg( cmpOp cmp, pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), (Assembler::Cmp_Relation)($cmp$$cmpcode) );
  %}

  enc_class emit_cmp4_eq_reg_reg( pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), Assembler::equal);
  %}

  enc_class emit_cmp4_lt_reg_reg( pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), Assembler::less );
  %}

  enc_class emit_cmp4_gt_reg_reg( pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), Assembler::greater );
  %}

  enc_class emit_cmp4u_reg_reg( cmpOpU cmp, pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), (Assembler::Cmp_Relation)($cmp$$cmpcode) );
  %}

  enc_class emit_cmp_reg_reg( cmpOp cmp, pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp ( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), (Assembler::Cmp_Relation)($cmp$$cmpcode) );
  %}

  enc_class emit_cmp_eq_reg_reg( pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp ( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), Assembler::equal);
  %}

  enc_class emit_cmp_lt_reg_reg( pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp ( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), Assembler::less );
  %}

  enc_class emit_cmp_gt_reg_reg( pReg isTrue, pReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp ( as_PredicateRegister($qp$$reg), as_PredicateRegister($isTrue$$reg), as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg), as_Register($src2$$reg), Assembler::greater );
  %}

  enc_class emit_cmp_eq_unc_reg_reg( pReg isTrue, isReg isFalse, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ cmp ( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($isTrue$$reg),
             as_PredicateRegister($isFalse$$reg),
             as_Register($src1$$reg),
             as_Register($src2$$reg),
             Assembler::equal,
             Assembler::Unc );
  %}

  enc_class emit_cmp4_reg_imm( cmpOp cmp, pReg p1, pReg p2, gRegI src1, immI8 src2, pReg qp ) %{
    Assembler::Cmp_Relation cr = Assembler::reverse_relation[$cmp$$cmpcode];

    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($p1$$reg), as_PredicateRegister($p2$$reg),
             (int)$src2$$constant, as_Register($src1$$reg), cr, Assembler::None );
  %}

  enc_class emit_cmp4u_reg_imm( cmpOpU cmp, pReg p1, pReg p2, gRegI src1, immI8 src2, pReg qp ) %{
    Assembler::Cmp_Relation cr = Assembler::reverse_relation[$cmp$$cmpcode];

    MacroAssembler _masm(&cbuf);
    __ cmp4( as_PredicateRegister($qp$$reg), as_PredicateRegister($p1$$reg), as_PredicateRegister($p2$$reg),
             (int)$src2$$constant, as_Register($src1$$reg), cr, Assembler::None );
  %}

  enc_class emit_cmp_reg_imm( cmpOp cmp, pReg p1, pReg p2, gRegI src1, immI8 src2, pReg qp ) %{
    Assembler::Cmp_Relation cr = Assembler::reverse_relation[$cmp$$cmpcode];

    MacroAssembler _masm(&cbuf);
    __ cmp ( as_PredicateRegister($qp$$reg), as_PredicateRegister($p1$$reg), as_PredicateRegister($p2$$reg),
             (int)$src2$$constant, as_Register($src1$$reg), cr, Assembler::None );
  %}


  enc_class emit_ld1( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld1( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ld1_acq( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld1( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg), Assembler::acquired );
  %}

  enc_class emit_ld2( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld2( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ld2_acq( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld2( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg), Assembler::acquired );
  %}

  enc_class emit_ld4( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld4( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ld4_acq( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld4 as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg), Assembler::acquired );
  %}

  enc_class emit_ld4_stack( gRegI dst, stackSlotI mem ) %{
    MacroAssembler _masm(&cbuf);
    __ add( GR29, $mem$$disp, as_Register($mem$$base) );
    __ ld4( as_Register($dst$$reg), GR29 );
  %}

  enc_class emit_ld8( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld8( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ld8_acq( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ld8( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg), Assembler::acquired );
  %}

  enc_class emit_ld8_stack( gRegI dst, stackSlotL mem ) %{
    MacroAssembler _masm(&cbuf);
    __ add( GR29, $mem$$disp, as_Register($mem$$base) );
    __ ld8( as_Register($dst$$reg), GR29 );
  %}

  enc_class emit_ldfs( fRegF dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ldfs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ldfs_acq( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ldfs( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg), Assembler::acquired );
  %}

  enc_class emit_ldfs_stack( fRegF dst, stackSlotF mem ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ ldfs( as_FloatRegister($dst$$reg), GR29 );
  %}

  enc_class emit_ldfd( fRegD dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ldfd( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ldfd_acq( gRegI dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ldfd( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($mem$$reg), Assembler::acquired );
  %}

  enc_class emit_ldfd_stack( fRegD dst, stackSlotD mem ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ ldfd( as_FloatRegister($dst$$reg), GR29 );
  %}

  enc_class emit_ldf8( fRegD dst, memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ ldf8( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_Register($mem$$reg));
  %}

  enc_class emit_ldf8_stack( fRegD dst, stackSlotD mem ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ ldf8( as_FloatRegister($dst$$reg), GR29 );
  %}

  enc_class emit_lfetch( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ lfetch( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), Assembler::ignorefault_exclusive);
  %}

  enc_class emit_mf( pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ mf( as_PredicateRegister($qp$$reg) );
  %}

  enc_class emit_mov_to_br( bRegP dst, gRegP src ) %{
    MacroAssembler _masm(&cbuf);
    __ mov( as_BranchRegister($dst$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_mov_from_br( gRegP dst, bRegP src ) %{
    MacroAssembler _masm(&cbuf);
    __ mov( as_Register($dst$$reg), as_BranchRegister($src$$reg) );
  %}

  enc_class emit_mov_reg( gRegI dst, gRegI src, pReg qp ) %{
    if ($dst$$reg != $src$$reg) {
      MacroAssembler _masm(&cbuf);
      __ add( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), GR0 );
    }
  %}

  enc_class emit_mov_imm14( gRegL dst, immL14 src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src$$constant, GR0 );
  %}

  enc_class emit_mov_immI_1( gRegI dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)1, GR0 );
  %}

  enc_class emit_mov_immI_m1( gRegI dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)(-1), GR0 );
  %}

  enc_class emit_mov_imm_1( gRegL dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)1, GR0 );
  %}

  enc_class emit_mov_imm_m1( gRegL dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ adds( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)-1, GR0 );
  %}

  enc_class emit_mov_imm22( gRegL dst, immL22 src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ addl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src$$constant, GR0 );
  %}

  enc_class emit_movl( gRegL dst, immL src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)$src$$constant );
  %}

  enc_class emit_mova( gRegP dst, immP src ) %{
    MacroAssembler _masm(&cbuf);
    // [RGV] This next line should be generated from ADLC
    if ( _opnds[1]->constant_is_oop() )
      __ mova( as_Register($dst$$reg), (address)$src$$constant, relocInfo::oop_type );
    else
      __ movl( as_Register($dst$$reg), (int64_t)$src$$constant );
  %}

  enc_class emit_movl_float( gRegL dst, immF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    jfloat x = $src$$constant;
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)(*((jint*)&x)) );
  %}

  enc_class emit_movl_double( gRegL dst, immD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    jdouble x = $src$$constant;
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)(*((jlong*)&x)) );
  %}

  enc_class emit_movl_double_half( gRegL dst ) %{
    MacroAssembler _masm(&cbuf);
    jdouble x = 0.5;
    __ movl( as_Register($dst$$reg), (int64_t)(*((jlong*)&x)) );
  %}

  enc_class emit_movl_min_int( gRegL dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)0x80000000 );
  %}

  enc_class emit_movl_max_int( gRegL dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)0x7fffffff );
  %}

  enc_class emit_movl_min_long( gRegL dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)0x8000000000000000 );
  %}

  enc_class emit_movl_max_long( gRegL dst, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ movl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int64_t)0x7fffffffffffffff );
  %}

  enc_class emit_movf( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ mov( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_negabsD_reg( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fnegabs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_negabsF_reg( fRegF dst, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fnegabs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_negD_reg( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fneg( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_negF_reg( fRegF dst, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fneg( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_negI_reg( gRegI dst, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sub( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), GR0, as_Register($src$$reg) );
  %}

  enc_class emit_negL_reg( gRegL dst, gRegL src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sub( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), GR0, as_Register($src$$reg) );
  %}

  enc_class emit_orI_imm8_reg( gRegI dst, immI8 src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ or3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_orI_reg_reg( gRegI dst, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ or3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_orL_imm8_reg( gRegL dst, immL8 src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ or3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_orL_reg_reg( gRegL dst, gRegL src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ or3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_ret() %{
    MacroAssembler _masm(&cbuf);
    __ ret( BR0 );
  %}

  enc_class emit_setfF_reg( fRegF dst, gRegL src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ setfs( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_setfD_reg( fRegD dst, gRegL src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ setfd( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_setfSIG_reg( fRegD dst, gRegL src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ setfsig( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_shl_reg_reg( gRegI dst, gRegI src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ shl( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), as_Register($cnt$$reg) );
  %}

  enc_class emit_shladd_reg_reg(gRegI dst, gRegI src1, gRegI src2, immI_1to4 shift, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ shladd( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src2$$reg), $shift$$constant, as_Register($src1$$reg) );
  %}

  enc_class emit_shlI_reg_imm6( gRegI dst, gRegI src, immI_1to64 cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    if ( (int)$cnt$$constant < 32 )
      __ depz( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg),
               (int)$cnt$$constant, 32 - (int)$cnt$$constant );
    else
      __ and3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), GR0, GR0 );
  %}

  enc_class emit_shlL_reg_imm6( gRegL dst, gRegL src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ depz( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg),
             (int)$cnt$$constant, 64 - (int)$cnt$$constant );
  %}

  enc_class emit_sar_reg_reg( gRegI dst, gRegI src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ shr( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), as_Register($cnt$$reg) );
  %}

  enc_class emit_shru_reg_reg( gRegI dst, gRegI src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ shru( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), as_Register($cnt$$reg) );
  %}

  enc_class emit_shruI_reg_imm6( gRegI dst, gRegI src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    if ( (int)$cnt$$constant < 32 )
      __ extru( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg),
                (int)$cnt$$constant, 32 - (int)$cnt$$constant );
    else
      __ extru( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), 31, 1 );
  %}

  enc_class emit_shruL_reg_imm6( gRegL dst, gRegL src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ extru( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg),
              (int)$cnt$$constant, 64 - (int)$cnt$$constant );
  %}

  enc_class emit_sar_reg_reg( gRegI dst, gRegI src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ shr( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), as_Register($cnt$$reg) );
  %}

  enc_class emit_sarI_reg_imm6( gRegI dst, gRegI src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    if ( (int)$cnt$$constant < 32 )
      __ extr( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg),
               (int)$cnt$$constant, 32 - (int)$cnt$$constant );
    else
      __ extr( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg), 31, 1 );
  %}

  enc_class emit_sarL_reg_imm6( gRegL dst, gRegL src, gRegI cnt, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ extr( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg),
             (int)$cnt$$constant, 64 - (int)$cnt$$constant );
  %}


  enc_class emit_st1( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st1( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_st1_rel( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st1( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_st1_gr0( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st1( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0 );
  %}

  enc_class emit_st1_gr0_rel( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st1( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0, Assembler::ordered_release );
  %}

  enc_class emit_st2( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st2( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_st2_rel( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st2( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_st2_gr0( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st2( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0 );
  %}

  enc_class emit_st2_gr0_rel( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st2( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0, Assembler::ordered_release );
  %}

  enc_class emit_st4( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st4( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_st4_rel( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st4( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_st4_stack( stackSlotI mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add( GR29, $mem$$disp, as_Register($mem$$base) );
    __ st4( GR29, as_Register($src$$reg) );
  %}

  enc_class emit_st4_stack_rel( stackSlotI mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add( GR29, $mem$$disp, as_Register($mem$$base) );
    __ st4( GR29, as_Register($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_st4_gr0( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st4( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0 );
  %}

  enc_class emit_st4_gr0_rel( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st4( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0, Assembler::ordered_release );
  %}

  enc_class emit_st8( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st8( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg) );
  %}

  enc_class emit_st8_rel( memory mem, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st8( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_Register($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_st8_stack( stackSlotL mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add( GR29, $mem$$disp, as_Register($mem$$base) );
    __ st8( GR29, as_Register($src$$reg) );
  %}

  enc_class emit_st8_stack_rel( stackSlotL mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add( GR29, $mem$$disp, as_Register($mem$$base) );
    __ st8( GR29, as_Register($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_st8_gr0( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st8( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0 );
  %}

  enc_class emit_st8_gr0_rel( memory mem, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ st8( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), GR0, Assembler::ordered_release );
  %}

  enc_class emit_stfs( memory mem, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ stfs( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_stfs_rel( memory mem, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ stfs( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_FloatRegister($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_stfs_stack( stackSlotF mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ stfs( GR29, as_FloatRegister($src$$reg) );
  %}

  enc_class emit_stfs_stack_rel( stackSlotF mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ stfs( GR29, as_FloatRegister($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_stfd( memory mem, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ stfd( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_stfd_rel( memory mem, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ stfd( as_PredicateRegister($qp$$reg), as_Register($mem$$reg), as_FloatRegister($src$$reg), Assembler::ordered_release );
  %}

  enc_class emit_stfd_stack( stackSlotD mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ stfd( GR29, as_FloatRegister($src$$reg) );
  %}

  enc_class emit_stfd_stack_rel( stackSlotD mem, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ add ( GR29, $mem$$disp, as_Register($mem$$base) );
    __ stfd( GR29, as_FloatRegister($src$$reg), Assembler::ordered_release );
  %}


  enc_class emit_subI_imm8_reg( gRegI dst, immI8 src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sub( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_subI_reg_reg( gRegI dst, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sub( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_subL_imm8_reg( gRegL dst, immL8 src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sub( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_subL_reg_reg( gRegL dst, gRegL src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sub( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_xorI_imm8_reg( gRegI dst, immI8 src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ xor3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_xorI_reg_reg( gRegI dst, gRegI src1, gRegI src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ xor3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_xorL_imm8_reg( gRegL dst, immL8 src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ xor3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), (int)$src1$$constant, as_Register($src2$$reg) );
  %}

  enc_class emit_xorL_reg_reg( gRegL dst, gRegL src1, gRegL src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ xor3( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg) );
  %}

  enc_class emit_fcmp( cmpOp cmp, pReg pTrue, pReg pFalse, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcmp( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($pTrue$$reg),
             as_PredicateRegister($pFalse$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             (Assembler::Cmp_Relation)($cmp$$cmpcode) );
  %}

  enc_class emit_fcmp_unc( cmpOp cmp, pReg pTrue, pReg pFalse, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcmp( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($pTrue$$reg),
             as_PredicateRegister($pFalse$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             (Assembler::Cmp_Relation)($cmp$$cmpcode),
             Assembler::Unc );
  %}

  enc_class emit_fcmp_le_unc( pReg pTrue, pReg pFalse, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcmp( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($pTrue$$reg),
             as_PredicateRegister($pFalse$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             Assembler::lessEqual,
             Assembler::Unc );
  %}

  enc_class emit_fcmp_lt_unc( pReg pTrue, pReg pFalse, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcmp( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($pTrue$$reg),
             as_PredicateRegister($pFalse$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             Assembler::less,
             Assembler::Unc );
  %}

  enc_class emit_fcmp_gt_unc( pReg pTrue, pReg pFalse, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcmp( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($pTrue$$reg),
             as_PredicateRegister($pFalse$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             Assembler::greater,
             Assembler::Unc );
  %}

  enc_class emit_breaker( ) %{
    emit_break(cbuf);
  %}

  enc_class emit_fcmp_eq_ne_with_unordered( cmpOp cmp_, pReg is_true_, pReg is_false_, fRegD src1_, fRegD src2_ ) %{
    MacroAssembler _masm(&cbuf);
    PredicateRegister is_true  = as_PredicateRegister($is_true_$$reg);
    PredicateRegister is_false = as_PredicateRegister($is_false_$$reg);
    FloatRegister     src1     = as_FloatRegister($src1_$$reg);
    FloatRegister     src2     = as_FloatRegister($src2_$$reg);

    Assembler::Cmp_Relation cmp = (Assembler::Cmp_Relation)($cmp_$$cmpcode);

    if( cmp == Assembler::equal ) {
      __ fcmp( PR0, PR0, is_true, src1, src2, Assembler::unordered );
      __ fcmp( is_true, is_true, PR0, src1, src2, cmp );
    }
    else {
      __ fcmp( PR0, is_true, is_false, src1, src2, Assembler::unordered );
      __ fcmp( is_false, is_true, PR0, src1, src2, cmp );
    }
  %}

  enc_class emit_fcmp_lt_le_with_unordered( cmpOp cmp_, pReg is_true_, pReg is_false_, fRegD src1_, fRegD src2_ ) %{
    MacroAssembler _masm(&cbuf);
    PredicateRegister is_true  = as_PredicateRegister($is_true_$$reg);
    PredicateRegister is_false = as_PredicateRegister($is_false_$$reg);
    FloatRegister     src1     = as_FloatRegister($src1_$$reg);
    FloatRegister     src2     = as_FloatRegister($src2_$$reg);

    Assembler::Cmp_Relation cmp = (Assembler::Cmp_Relation)($cmp_$$cmpcode);

    if( cmp == Assembler::less || cmp == Assembler::lessEqual ) {
      __ fcmp( PR0, is_true, is_false, src1, src2, Assembler::unordered );
      __ fcmp( is_false, is_true, PR0, src1, src2, cmp );
    }
    else {
      __ fcmp( PR0, PR0, is_true, src1, src2, Assembler::unordered );
      __ fcmp( is_true, is_true, PR0, src1, src2, cmp );
    }
  %}

  enc_class emit_fcmp_gt_ge_with_unordered( cmpOp cmp_, pReg is_true_, pReg is_false_, fRegD src1_, fRegD src2_ ) %{
    MacroAssembler _masm(&cbuf);
    PredicateRegister is_true  = as_PredicateRegister($is_true_$$reg);
    PredicateRegister is_false = as_PredicateRegister($is_false_$$reg);
    FloatRegister     src1     = as_FloatRegister($src1_$$reg);
    FloatRegister     src2     = as_FloatRegister($src2_$$reg);

    Assembler::Cmp_Relation cmp = (Assembler::Cmp_Relation)($cmp_$$cmpcode);

    if( cmp == Assembler::greater || cmp == Assembler::greaterEqual ) {
      __ fcmp( PR0, PR0, is_true, src1, src2, Assembler::unordered );
      __ fcmp( is_true, is_true, PR0, src1, src2, cmp );
    }
    else {
      __ fcmp( PR0, is_true, is_false, src1, src2, Assembler::unordered );
      __ fcmp( is_false, is_true, PR0, src1, src2, cmp );
    }
  %}

  enc_class emit_fcmp_unord( pReg is_unordered, pReg is_ordered, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcmp( as_PredicateRegister($qp$$reg),
             as_PredicateRegister($is_unordered$$reg),
             as_PredicateRegister($is_ordered$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             Assembler::unordered );
  %}

  enc_class emit_fcvtSD_reg( fRegD dst, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fmad( as_PredicateRegister($qp$$reg),
             as_FloatRegister($dst$$reg),
             FR1,
             as_FloatRegister($src$$reg),
             FR0 );
  %}

  enc_class emit_fcvtDS_reg( fRegF dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fmas( as_PredicateRegister($qp$$reg),
             as_FloatRegister($dst$$reg),
             FR1,
             as_FloatRegister($src$$reg),
             FR0 );
  %}

  enc_class emit_fcvtFXTrunc_reg( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcvtfx( as_PredicateRegister($qp$$reg),
               as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               true );
  %}

  enc_class emit_fcvtXF_reg( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fcvtxf( as_PredicateRegister($qp$$reg),
               as_FloatRegister($dst$$reg), 
               as_FloatRegister($src$$reg) );
  %}

  enc_class emit_fma_reg_reg_reg( fRegD dst, fRegD src1, fRegD src2, fRegD src3, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fma( as_PredicateRegister($qp$$reg),
            as_FloatRegister($dst$$reg),
            as_FloatRegister($src2$$reg),
            as_FloatRegister($src3$$reg),
            as_FloatRegister($src1$$reg),
            Assembler::sf1 );
  %}

  enc_class emit_fmaD_reg_reg_reg( fRegD dst, fRegD src1, fRegD src2, fRegD src3, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fmad( as_PredicateRegister($qp$$reg),
             as_FloatRegister($dst$$reg),
             as_FloatRegister($src2$$reg),
             as_FloatRegister($src3$$reg),
             as_FloatRegister($src1$$reg) );
  %}

  enc_class emit_fmaF_reg_reg_reg( fRegF dst, fRegF src1, fRegF src2, fRegF src3, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fmas( as_PredicateRegister($qp$$reg),
             as_FloatRegister($dst$$reg),
             as_FloatRegister($src2$$reg),
             as_FloatRegister($src3$$reg),
             as_FloatRegister($src1$$reg) );
  %}

  enc_class emit_fmerges_reg_reg( fRegF dst, fRegF src1, fRegF src2, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ fmerges( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg),
                as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg) );
  %}

  enc_class emit_fmpy_reg_reg( fRegD dst, fRegD src1, fRegD src2, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ fmpy( as_PredicateRegister($qp$$reg),
             as_FloatRegister($dst$$reg),
             as_FloatRegister($src1$$reg),
             as_FloatRegister($src2$$reg),
             Assembler::sf1 );
  %}

  enc_class emit_fmpyD_reg_reg( fRegD dst, fRegD src1, fRegD src2, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ fmpyd( as_PredicateRegister($qp$$reg),
              as_FloatRegister($dst$$reg),
              as_FloatRegister($src1$$reg),
              as_FloatRegister($src2$$reg) );
  %}

  enc_class emit_fmpyF_reg_reg( fRegF dst, fRegF src1, fRegF src2, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ fmpys( as_PredicateRegister($qp$$reg),
              as_FloatRegister($dst$$reg),
              as_FloatRegister($src1$$reg),
              as_FloatRegister($src2$$reg) );
  %}

  enc_class emit_fnma_reg_reg_reg( fRegD dst, fRegD src1, fRegD src2, fRegD src3, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ fnma( as_PredicateRegister($qp$$reg),
             as_FloatRegister($dst$$reg),
             as_FloatRegister($src2$$reg),
             as_FloatRegister($src3$$reg),
             as_FloatRegister($src1$$reg), Assembler::sf1 );
  %}

  enc_class emit_fnmaD_reg_reg_reg( fRegD dst, fRegD src1, fRegD src2, fRegD src3, pReg qp) %{
    MacroAssembler _masm(&cbuf);
    __ fnmad( as_PredicateRegister($qp$$reg),
              as_FloatRegister($dst$$reg),
              as_FloatRegister($src2$$reg),
              as_FloatRegister($src3$$reg),
              as_FloatRegister($src1$$reg) );
  %}

  enc_class emit_fnorm_reg( fRegF dst, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fnorm( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_fnormF_reg( fRegF dst, fRegF src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fnorms( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_fnormD_reg( fRegD dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ fnormd( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_frcpa_reg_reg( fRegD dst, pReg pr, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ frcpa( as_PredicateRegister($qp$$reg),
              as_FloatRegister($dst$$reg),
              as_PredicateRegister($pr$$reg),
              as_FloatRegister($src1$$reg),
              as_FloatRegister($src2$$reg),
              Assembler::sf1 );
  %}

  enc_class emit_fdivd_reg_reg( fRegD dstx, fRegD src1x, fRegD src2x, fRegD tmp1x, fRegD tmp2x, fRegD tmp3x, fRegD tmp4x, pReg prx ) %{
    MacroAssembler _masm(&cbuf);

    FloatRegister     dst  = as_FloatRegister($dstx$$reg);
    FloatRegister     src1 = as_FloatRegister($src1x$$reg);
    FloatRegister     src2 = as_FloatRegister($src2x$$reg);
    FloatRegister     tmp1 = as_FloatRegister($tmp1x$$reg);
    FloatRegister     tmp2 = as_FloatRegister($tmp2x$$reg);
    FloatRegister     tmp3 = as_FloatRegister($tmp3x$$reg);
    FloatRegister     tmp4 = as_FloatRegister($tmp4x$$reg);
    PredicateRegister pr   = as_PredicateRegister($prx$$reg);

    FloatRegister     tmp0 = ( dst != src1 && dst != src2 ) ? dst : tmp1;

    // This is derived from the Algorithm found in the Intel
    // Itanium Achitecture Software Developers Manual,
    // Volume 1: Application Architecture, page 199

    __ frcpa(     tmp0, pr,   src1, src2, Assembler::sf0 );
    __ fmpy ( pr, tmp2, src1, tmp0,       Assembler::sf1 );
    __ fnma ( pr, tmp3, src2, tmp0, FR1,  Assembler::sf1 );
    __ fma  ( pr, tmp2, tmp3, tmp2, tmp2, Assembler::sf1 );
    __ fmpy ( pr, tmp4, tmp3, tmp3,       Assembler::sf1 );
    __ fma  ( pr, tmp1, tmp3, tmp0, tmp0, Assembler::sf1 );
    __ fma  ( pr, tmp2, tmp4, tmp2, tmp2, Assembler::sf1 );
    __ fmpy ( pr, tmp3, tmp4, tmp4,       Assembler::sf1 );
    __ fma  ( pr, tmp1, tmp4, tmp1, tmp1, Assembler::sf1 );
    __ fmad ( pr, tmp2, tmp3, tmp2, tmp2, Assembler::sf1 );
    __ fma  ( pr, tmp1, tmp3, tmp1, tmp1, Assembler::sf1 );
    __ fnmad( pr, tmp4, src2, tmp2, src1, Assembler::sf1 );
    __ fmad ( pr, tmp0, tmp4, tmp1, tmp2, Assembler::sf0 );

    if( tmp0 != dst )
      __ mov( dst,  tmp0 );
  %}

  enc_class emit_fdivf_reg_reg( fRegF dstx, fRegF src1x, fRegF src2x, fRegD tmp1x, fRegD tmp2x, fRegD tmp3x, pReg prx ) %{
    MacroAssembler _masm(&cbuf);

    FloatRegister     dst  = as_FloatRegister($dstx$$reg);
    FloatRegister     src1 = as_FloatRegister($src1x$$reg);
    FloatRegister     src2 = as_FloatRegister($src2x$$reg);
    FloatRegister     tmp1 = as_FloatRegister($tmp1x$$reg);
    FloatRegister     tmp2 = as_FloatRegister($tmp2x$$reg);
    FloatRegister     tmp3 = as_FloatRegister($tmp3x$$reg);
    PredicateRegister pr   = as_PredicateRegister($prx$$reg);

    FloatRegister     tmp0 = ( dst != src1 && dst != src2 ) ? dst : tmp3;

    __ frcpa (     tmp0, pr,   src1, src2, Assembler::sf0 );
    __ fmpy  ( pr, tmp1, src1, tmp0,       Assembler::sf1 );
    __ fnma  ( pr, tmp2, src2, tmp0, FR1,  Assembler::sf1 );
    __ fma   ( pr, tmp1, tmp2, tmp1, tmp1, Assembler::sf1 );
    __ fmpy  ( pr, tmp2, tmp2, tmp2,       Assembler::sf1 );
    __ fma   ( pr, tmp1, tmp2, tmp1, tmp1, Assembler::sf1 );
    __ fmpy  ( pr, tmp2, tmp2, tmp2,       Assembler::sf1 );
    __ fmad  ( pr, tmp1, tmp2, tmp1, tmp1, Assembler::sf1 );
    __ fnorms( pr, tmp0, tmp1,             Assembler::sf0 );

    if( tmp0 != dst )
      __ mov( dst,  tmp0 );
  %}

  enc_class emit_getfD_reg( gRegI dst, fRegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ getfd( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  enc_class emit_getfSIG_reg( gRegI dst, RegD src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ getfsig( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_FloatRegister($src$$reg) );
  %}

  // Sign-extend the Byte to fill the register
  enc_class emit_sxt1_reg( gRegI dst, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sxt1( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg) ); 
  %}

  // Sign-extend the Word to fill the register
  enc_class emit_sxt2_reg( gRegI dst, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sxt2( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg) ); 
  %}

  // Sign-extend the Integer to fill the register
  enc_class emit_sxt4_reg( gRegI dst, gRegI src, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ sxt4( as_PredicateRegister($qp$$reg), as_Register($dst$$reg), as_Register($src$$reg) ); 
  %}

  enc_class emit_xmpyl_reg_reg( fRegD dst, fRegD src1, fRegD src2, pReg qp ) %{
    MacroAssembler _masm(&cbuf);
    __ xmpyl( as_PredicateRegister($qp$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg) );
  %}

  enc_class LdImmPc (gRegI dst, method offset_to_call_return, pReg qp) %{
    // load immediate the pc at return address of call to native code
    MacroAssembler _masm(&cbuf);

    // Place this instruction in a bundle by itself - makes things easier
    __ flush_bundle();
    __ mova(
         as_PredicateRegister($qp$$reg), 
         as_Register($dst$$reg), 
         cbuf.code_end() + MAX2(intptr_t(16), $offset_to_call_return$$method),
         relocInfo::internal_word_type );
    __ flush_bundle();
  %}

  // Zero-extend the Integer to fill the register
  enc_class emit_zxt4_reg( gRegI dst, gRegI src ) %{
    MacroAssembler _masm(&cbuf);
    __ zxt4( as_Register($dst$$reg), as_Register($src$$reg) ); 
  %}

  enc_class enc_checkcast( gRegP klass, gRegP con, Label labl, gRegP temp1, gRegP temp2, pReg temp3 )  %{
    // Fast-path code for the check-cast operation.
    // Check the incoming oop vs the cache in the object's klass.
    // This requires 2 temporary general registers, and 1 temporary predicate register

    MacroAssembler _masm(&cbuf);
    Register          klass_reg = as_Register($klass$$reg);
    Register            con_reg = as_Register(  $con$$reg);
    Register          temp1_reg = as_Register($temp1$$reg);
    Register          temp2_reg = as_Register($temp2$$reg);
    PredicateRegister temp3_reg = as_PredicateRegister($temp3$$reg);

    int c1_offset = sizeof(oopDesc) + Klass::is_a_cache_1_offset_in_bytes();
    int c2_offset = sizeof(oopDesc) + Klass::is_a_cache_2_offset_in_bytes();

// 0
    __ add(temp1_reg, c1_offset, klass_reg);
    __ add(temp2_reg, c2_offset, klass_reg);
    __ ld8(temp1_reg, temp1_reg);
    __ ld8(temp2_reg, temp2_reg);
    __ cmp(           R_P0, temp3_reg, con_reg, temp1_reg, Assembler::equal, Assembler::None);
    __ cmp(temp3_reg, R_P0, temp3_reg, con_reg, temp2_reg, Assembler::equal, Assembler::None);
    __ br( temp3_reg, *($labl$$label) );
  %}

  enc_class rematerialize_tls() %{
    MacroAssembler _masm(&cbuf);
//    __ get_thread();
//    __ verify_thread();
  %}

  enc_class call_epilog() %{
  %}

  enc_class emit_java_static_call(method meth, gRegP target_gr, call_bRegP target_br) %{
    MacroAssembler _masm(&cbuf);

// 0
    __ flush_bundle();
    cbuf.set_mark();

    // Load the call address
    if ( !_method ) {
      __ mova(as_Register($target_gr$$reg), (address)($meth$$method), relocInfo::runtime_call_type);
    } else if (_optimized_virtual) {
      __ mova(as_Register($target_gr$$reg), (address)($meth$$method), relocInfo::opt_virtual_call_type);
    } else {
      __ mova(as_Register($target_gr$$reg), (address)($meth$$method), relocInfo::static_call_type);
    }

// 1
    __ movi(as_BranchRegister($target_br$$reg), as_Register($target_gr$$reg));
    __ call(as_BranchRegister($target_br$$reg));
    __ flush_bundle();

// 2
    if( _method ) // Emit stub for static call
      emit_java_to_interp(cbuf);
  %}

  enc_class emit_java_dynamic_call(method meth, gRegP inline_cache_gr, gRegP jump_gr, bRegP jump_br, gRegP save_rp_gr) %{
    MacroAssembler _masm(&cbuf);

// 0
    // Force the mova to a new bundle so it can be marked
    __ flush_bundle();

    // Move the address of the method inline
    cbuf.set_mark();

    // Generate  "set 0x01, inline_cache_gr", placeholder instruction to load oop-info
    // emit_call_dynamic_prologue( cbuf );
    __ mova(as_Register($inline_cache_gr$$reg), (address)Universe::non_oop_word(), relocInfo::oop_type);
    __ flush_bundle(); // So relocate() for the vcall works

    // Fill in the address for the call
    address  virtual_call_oop_addr = cbuf.mark();
    __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr));

// 1
    __ movl(as_Register($jump_gr$$reg), (intptr_t)$meth$$method);
    __ flush_bundle();

// 2
    // Now generate the call to the assumed address
    __ movi(as_BranchRegister($jump_br$$reg), as_Register($jump_gr$$reg));
    __ call(as_BranchRegister($jump_br$$reg));
    __ flush_bundle();
  %}


  enc_class emit_compiled_call(gRegP oop_gr, gRegP target_gr, bRegP target_br, gRegP save_rp_gr) %{
    MacroAssembler _masm(&cbuf);

    // Force the movl to a new bundle
    __ flush_bundle();

// 0
    // Get the address containing the entry point
    __ add( as_Register($target_gr$$reg), in_bytes(methodOopDesc::from_compiled_code_entry_point_offset()), as_Register($oop_gr$$reg) );
    __ eog();

    // Load the entry point pointer
    __ ld8(as_Register($target_gr$$reg), as_Register($target_gr$$reg));
    __ eog();

// 1
    __ movi(as_BranchRegister($target_br$$reg), as_Register($target_gr$$reg));
    __ call(as_BranchRegister($target_br$$reg));
    __ flush_bundle();
  %}

  enc_class emit_native_call(method meth, inline_cache_gRegP jump_gr, call_bRegP jump_br, gRegP save_rp_gr, gpRegP gp, gr2_gRegP gr2, gr3_gRegP gr3, gRegP save_gp_gr, gRegP save_bsp_gr, ret_regP funcp) %{
    MacroAssembler _masm(&cbuf);

    int pc_offset    = in_bytes(JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
    int fp_offset    = in_bytes(JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_fp_offset());
//    int flush_offset = in_bytes(JavaThread::flushed_windows_offset());
    int sp_offset    = in_bytes(JavaThread::last_Java_sp_offset());
    int state_offset = in_bytes(JavaThread::thread_state_offset());

    Register thread_ptr   = as_Register($gr2$$reg);
    Register thread_value = as_Register($gr3$$reg);

    Register Lsave_GP     = as_Register($save_gp_gr$$reg);
    Register Lsave_BSP    = as_Register($save_bsp_gr$$reg);

    // Place this instruction in a bundle by itself - makes things easier
// 0
    __ flush_bundle();
    __ add(thread_ptr, GR4_thread, pc_offset);
    __ mova(
         thread_value,
         cbuf.code_end() + ( 22 * Pipeline::bundle_unit_size() ),
         relocInfo::internal_word_type );
    __ flush_bundle();

// 1
    // Save the PC at the return
    __ st8(thread_ptr, thread_value, fp_offset - pc_offset);

    // Get the BSP
    __ mov(Lsave_BSP, AR_BSP);

    // Save the GP
    __ mov(Lsave_GP, GP);

    __ flush_bundle();

// 2
    // Save the BSP as the FP
    __ st8(thread_ptr, Lsave_BSP, sp_offset - fp_offset);

    __ flush_bundle();

// 3
    // Save the SP; load a constant
    __ st8(thread_ptr, SP, state_offset - sp_offset, Assembler::ordered_release);
    __ mov(thread_value, _thread_in_native);
    __ flush_bundle();

// 4
    // Store the thread state
    __ st4(thread_ptr, thread_value, Assembler::ordered_release);
    __ eog();

    // Fence because acquire is not ordered wrt release
    __ mf();
    __ flush_bundle();

// 5,6,7

    // Need to push a frame to get current regs flushed to stack.

    __ push_dummy_thin_frame(GR0);	// 3 bundles  5,6,7
    __ flush_bundle();

    // Need temps that survive the push/pop of dummy frame while we flush
    // eventually they wind up in locals.
    const Register tmod_RSC    = GR_RET0;
    const Register tsave_RSC   = GR_RET1;
 
// 8
    __ mov(tsave_RSC, AR_RSC);           // save original value of RSC
    __ movl(tmod_RSC, CONST64(0xFFFFFFFFC000FFFC));    // mask tear point to zero, rse to lazy
    __ flush_bundle();

    const Register flags_addr             = GR2_SCRATCH;
    const Register flushed                = GR3_SCRATCH;

// 9

    __ and3(tmod_RSC, tmod_RSC, tsave_RSC);
    __ add(flushed, GR0, JavaFrameAnchor::flushed);
    __ add(flags_addr, GR4_thread, in_bytes(JavaThread::frame_anchor_offset() + JavaFrameAnchor::flags_offset()));
    __ flush_bundle();

// 10

    __ flushrs();
    __ flush_bundle();


    // Make sure eager RSE is off while we are in native
// 11
    __ mov(AR_RSC, tmod_RSC); 
    __ flush_bundle();
// 12
    __ loadrs();					// invalidate lower frames
    __ flush_bundle();

    // Now the caller's frame (and its call chain) have been invalidated and flushed.
    // We are now protected against Eager being enabled in native code.
    // Even if it goes eager the registers will be reloaded as clean
    // and we will invalidate after the call so no spurious flush should
    // be possible.

// 13
    __ st4(flags_addr, flushed, Assembler::ordered_release);
    __ mf();
    __ flush_bundle();

// 14-18
    __ pop_dummy_thin_frame();   // 5 bundles  14,15,16,17,18
    __ flush_bundle();

    // Now move our RSC state to locals which will survive

    const Register native_method             = GR2_SCRATCH;
    const Register native_method_addr        = GR3_SCRATCH;

// 19
    __ mov(GR_jni_save_RSC, tsave_RSC);
    __ mova(native_method_addr, (address)$meth$$method, relocInfo::runtime_call_type);
    __ flush_bundle();

// 20

    __ mov(GR_jni_mod_RSC, tmod_RSC);
    __ ld8(native_method, native_method_addr, in_bytes(FuncDesc::gp_offset()));
    __ ld8(GP, native_method_addr);                  // Native method GP
    __ flush_bundle();
   
  
// 21

    // Call the native method
    const BranchRegister native_method_br = BR6_SCRATCH;
    __ mov(native_method_br, native_method);
    __ call(native_method_br);                 // off we go
    __ flush_bundle();


    // Now invalidate the lower frames once again so that if Eager happened
    // behind our back we will still be safe and reload when we go back to
    // Java mode.

// 22

    __ mov(AR_RSC, GR_jni_mod_RSC); 
    __ loadrs();					// invalidate lower frames
    __ flush_bundle();

// 23
    // Restore the GP
    __ mov(GP, Lsave_GP);

    // Put RSC back to original state. 
    __ mov(AR_RSC, GR_jni_save_RSC);
    __ flush_bundle();

  %}

  enc_class emit_runtime_call(method meth, gRegP target_gr, bRegP target_br, gpRegP gp, gr2_gRegP gr2, gr3_gRegP gr3, gRegP save_rp_gr, gRegP save_gp_gr, gRegP save_bsp_gr) %{
    MacroAssembler _masm(&cbuf);

    int pc_offset    = in_bytes(JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
    int fp_offset    = in_bytes(JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_fp_offset());
    int flush_offset = in_bytes(JavaThread::frame_anchor_offset() + JavaFrameAnchor::flags_offset());
    int sp_offset    = in_bytes(JavaThread::last_Java_sp_offset());

    FuncDesc *func   = (FuncDesc*)($meth$$method);

    Register       thread_ptr   = as_Register($gr2$$reg);
    Register       thread_value = as_Register($gr3$$reg);

    Register       GP           = as_Register($gp$$reg);
    Register       Lsave_BSP    = as_Register($save_bsp_gr$$reg);
    Register       Lsave_GP     = as_Register($save_gp_gr$$reg);
    Register       Target_GR    = as_Register($target_gr$$reg);
    BranchRegister Target_BR    = as_BranchRegister($target_br$$reg);


    // Place this instruction in a bundle by itself - makes things easier
// 0
    __ flush_bundle();
    __ add(thread_ptr, GR4_thread, pc_offset);
    __ mova(
         thread_value,
         cbuf.code_end() + ( 6 * Pipeline::bundle_unit_size() ),
         relocInfo::internal_word_type );
    __ flush_bundle();

// 1
    // Save the PC at the return
    __ st8(thread_ptr, thread_value, fp_offset - pc_offset);

    // Get the BSP
    __ mov(Lsave_BSP, AR_BSP);

    // Save the GP
    __ mov(Lsave_GP, GP);

    __ flush_bundle();

// 2
    // Save the BSP as the FP
    __ st8(thread_ptr, Lsave_BSP, sp_offset - fp_offset);

    // Load the pointer to the gp (which is not an oop, so we don't need to spin on this instruction)
    __ movl(GP, (intptr_t)(func->gp()));
    __ flush_bundle();

// 3
    // Save the SP
    __ st8(thread_ptr, SP, Assembler::ordered_release);
    __ eog();

    // Fence because acquire is not ordered wrt release
    __ mf();
    __ flush_bundle();

// 4
    // Load the pointer to the method, force a nop for the M slot
    __ nopm();
    __ mova(Target_GR, (address)(func->entry()), relocInfo::runtime_call_type);
    __ flush_bundle();

// 5
    // Move the pointer to a BR, and call indirect
    __ movi(Target_BR, Target_GR);
    __ call(Target_BR);
    __ flush_bundle();

    __ mov(GP, Lsave_GP);
  %}

  enc_class emit_simple_call(method meth, gRegP target_gr, bRegP target_br, gpRegP gp, gRegP lsave_gp_gr) %{
    MacroAssembler _masm(&cbuf);
 
    Register       GP        = as_Register($gp$$reg);
    Register       Lsave_GP  = as_Register($lsave_gp_gr$$reg);
    Register       Target_GR = as_Register($target_gr$$reg);
    BranchRegister Target_BR = as_BranchRegister($target_br$$reg);

    FuncDesc *func = (FuncDesc*)($meth$$method);

// 0
    // Save the RP
    __ mov(Lsave_GP, GP);
    __ flush_bundle();

// 1
    // Start the address
    __ mova(Target_GR, (address)(func->entry()), relocInfo::runtime_call_type);

// 2
    __ movl(GP, (intptr_t)(func->gp()));
    __ flush_bundle();

// 3
    __ movi(Target_BR, Target_GR);
    __ call(Target_BR);
    __ flush_bundle();

// 4
    __ mov(GP, Lsave_GP);
  %}

  enc_class emit_interpreter_call(method meth, gRegP arg0_gr, gRegP target_gr, bRegP target_br) %{
    MacroAssembler _masm(&cbuf);

    Register       Target_GR = as_Register($target_gr$$reg);
    BranchRegister Target_BR = as_BranchRegister($target_br$$reg);

// 0
    // Load a pointer to the start of the "interpreter" stack (prepushed)
    // Since there are two dead words (not slots) below the final arg (and
    // owned by the interpreter/callee) we can point just below the 
    // final arg and everybodies happy
    //
    __ add(as_Register($arg0_gr$$reg), (Compile::out_preserve_stack_slots() - 2) * jintSize, SP);
    __ flush_bundle();

// 1
    __ mova(Target_GR, (address)(((FuncDesc*)($meth$$method))->entry()), relocInfo::runtime_call_type);
    __ flush_bundle();

// 2
    __ mov(Target_BR, Target_GR);
    __ call(Target_BR);
    __ flush_bundle();
  %}

  enc_class emit_pop_frame(gRegP target_gr, bRegP target_br) %{
    MacroAssembler _masm(&cbuf);

    Register       Target_GR = as_Register($target_gr$$reg);
    BranchRegister Target_BR = as_BranchRegister($target_br$$reg);

    // Place this instruction in a bundle by itself - makes things easier
    __ flush_bundle();
    __ mova(Target_GR, cbuf.code_end() + ( 2 * Pipeline::bundle_unit_size() ), relocInfo::internal_word_type);
    __ flush_bundle();

    __ movret(Target_BR, Target_GR);
    __ ret(Target_BR);
    __ flush_bundle();
  %}

  enc_class emit_tail_call(bRegP jump_br) %{
    MacroAssembler _masm(&cbuf);
    __ br(as_BranchRegister($jump_br$$reg));
    __ flush_bundle();
  %}

  enc_class emit_PartialSubtypeCheck(gRegP jump_gr, bRegP jump_br) %{
    MacroAssembler _masm(&cbuf);
    __ mova(as_Register($jump_gr$$reg), StubRoutines::ia64::partial_subtype_check(), relocInfo::runtime_call_type);
    __ movi(as_BranchRegister($jump_br$$reg), as_Register($jump_gr$$reg));
    __ call(as_BranchRegister($jump_br$$reg));
    __ flush_bundle();
  %}

  enc_class emit_rethrow(gRegP jump_gr, bRegP jump_br) %{
    MacroAssembler _masm(&cbuf);
    __ mova(as_Register($jump_gr$$reg), OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
    __ movi(as_BranchRegister($jump_br$$reg), as_Register($jump_gr$$reg));
    __ br  (as_BranchRegister($jump_br$$reg));
    __ flush_bundle();
  %}

  // Note: registers for oop, mark, box may be modified
  enc_class emit_compiler_fast_lock(cmpOpU cmp, gRegP oop_arg, gRegP mark_arg, gRegP box_arg, gRegP scratch1_arg, gRegP scratch2_arg, pReg pr_arg, Label target) %{

    MacroAssembler _masm(&cbuf);
    assert( oopDesc::mark_offset_in_bytes() == 0, "offset of _mark is not 0" );

    PredicateRegister pr       = as_PredicateRegister($pr_arg$$reg);
    Register          scratch1 = as_Register($scratch1_arg$$reg);
    Register          scratch2 = as_Register($scratch2_arg$$reg);
    Register          mark     = as_Register($mark_arg$$reg);
    Register          box      = as_Register($box_arg$$reg);
    Register          oop      = as_Register($oop_arg$$reg);

    Label             done;

    Assembler::Cmp_Relation
                      code     = (Assembler::Cmp_Relation)($cmp$$cmpcode);

    // Load markOop from oop into mark
    __ ld8( mark, oop );
    __ eog();

    // Set mark to markOop | markOopDesc::unlocked_value
    __ or3( mark, markOopDesc::unlocked_value, mark );

    // Load Compare Value application register
    __ mov( AR_CCV, mark );
    __ eog();

    // Compute the address of the box's lock
    __ add( scratch1, BasicLock::displaced_header_offset_in_bytes(), box );
    __ eog();

    // Initialize the box (must happen before we update the object mark)
    __ st8( scratch1, mark );
    __ eog();

    // Fence.  We must do this both because we don't know where preceding unlocks are (so
    // we need a storeload barrier) and because we just did a volatile store for which the
    // fence is the release and because the store must complete before the cmpxchg.  If we
    // didn't need the storeload, we could get away with a release here instead of fence.
    __ mf();
    __ eog();

    // Compare object markOop with mark and if equal exchange scratch1 with object markOop
    __ cmpxchg8( scratch1, oop, box, Assembler::acquire );
    __ eog();

    // If the compare-and-exchange succeeded, then we found an unlocked object and we
    // have now locked it.  But if the values are not equal, then we failed, and
    // need to take the slow path.
    __ cmp( pr, PR0, mark, scratch1, Assembler::equal );

    if( code == Assembler::notEqual )
      __ br( pr, done );
    else
      __ br( pr, *($target$$label) );

    // These can be done in parallel, the registers are scratch.  Do this even
    // if the compare-and-exchange succeeded.
    __ sub ( scratch1, scratch1, SP );
    __ mov ( scratch2, ~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place );

    // We did not find an unlocked object, so see if this is a recursive case
    __ and3( scratch1, scratch2, scratch1 );
    __ add ( scratch2, BasicLock::displaced_header_offset_in_bytes(), box );

    __ st8 ( scratch2, scratch1, Assembler::ordered_release );
    __ cmp ( pr, PR0, scratch1, GR0, code );
    __ br  ( pr, *($target$$label) );

    if( code == Assembler::notEqual )
      __ bind( done );
  %}

  enc_class emit_compiler_fast_unlock(cmpOpU cmp, gRegP oop_arg, gRegP mark_arg, gRegP box_arg, gRegP scratch1_arg, gRegP scratch2_arg, pReg predicate_arg, Label target) %{

    MacroAssembler _masm(&cbuf);
    assert( oopDesc::mark_offset_in_bytes() == 0, "offset of _mark is not 0" );

    PredicateRegister predicate = as_PredicateRegister($predicate_arg$$reg);
    Register          scratch1  = as_Register($scratch1_arg$$reg);
    Register          scratch2  = as_Register($scratch2_arg$$reg);
    Register          mark      = as_Register($mark_arg$$reg);
    Register          box       = as_Register($box_arg$$reg);
    Register          oop       = as_Register($oop_arg$$reg);

    Label unlocked;

    Assembler::Cmp_Relation
                      code      = (Assembler::Cmp_Relation)($cmp$$cmpcode);

    // Find the lock address and load the displaced header from the stack.
    __ add( scratch1, BasicLock::displaced_header_offset_in_bytes(), box );

    __ ld8( mark, scratch1 );

    __ cmp( predicate, PR0, mark, GR0, Assembler::equal );

    // If the displaced header is zero, we have a recursive unlock.
    if( code == Assembler::notEqual )
      __ br ( predicate, unlocked );
    else
      __ br ( predicate, *($target$$label) );

    __ mov( AR_CCV, box );

    __ cmpxchg8( scratch2, oop, mark, Assembler::release );

    __ cmp( predicate, PR0, box, scratch2, code );
    __ br ( predicate, *($target$$label) );

    if( code == Assembler::notEqual )
      __ bind( unlocked );
   %}

  enc_class emit_cmpxchg8_bool(gRegI dst, gRegP ptr, gRegP old_val, gRegP new_val, gRegP tmp, pReg pr6, pReg pr7) %{
    MacroAssembler _masm(&cbuf);

    PredicateRegister pr6     = as_PredicateRegister($pr6$$reg);
    PredicateRegister pr7     = as_PredicateRegister($pr7$$reg);
    Register          dst     = as_Register($dst$$reg);
    Register          ptr     = as_Register($ptr$$reg);
    Register          tmp     = as_Register($tmp$$reg);
    Register          old_val = as_Register($old_val$$reg);
    Register          new_val = as_Register($new_val$$reg);

    // Load Compare Value application register
    __ mov( AR_CCV, old_val );

    // Compare and exchange
    __ cmpxchg8( tmp, ptr, new_val, Assembler::acquire );

    // Indicate success or failure
    __ cmp( pr6, pr7, tmp, old_val, Assembler::equal );
    __ mov( pr6, dst, 1 );
    __ mov( pr7, dst, 0 );
   %}

  // For JSR-166. This is just a guess about how this should work - dl

  enc_class emit_cmpxchg_bool(gRegI dst, gRegP ptr, gRegI old_val, gRegI new_val, gRegP tmp, pReg pr6, pReg pr7) %{
    MacroAssembler _masm(&cbuf);

    PredicateRegister pr6     = as_PredicateRegister($pr6$$reg);
    PredicateRegister pr7     = as_PredicateRegister($pr7$$reg);
    Register          dst     = as_Register($dst$$reg);
    Register          ptr     = as_Register($ptr$$reg);
    Register          tmp     = as_Register($tmp$$reg);
    Register          old_val = as_Register($old_val$$reg);
    Register          new_val = as_Register($new_val$$reg);

    // Zero extend old_val because cmpxchg4 will zero extend the memory operand
    __ zxt4(old_val, old_val);

    // Load Compare Value application register
    __ mov( AR_CCV, old_val );

    // Compare and exchange
    __ cmpxchg4( tmp, ptr, new_val, Assembler::acquire );

    // Indicate success or failure
    __ cmp4( pr6, pr7, tmp, old_val, Assembler::equal );
    __ mov( pr6, dst, 1 );
    __ mov( pr7, dst, 0 );
   %}

%}

//----------FRAME--------------------------------------------------------------
// Definition of frame structure and management information.
//
//  S T A C K   L A Y O U T    Allocators stack-slot number
//                             |
//  G  Owned by    |        |  v
//  r   CALLER     |        |
//  o     |        +--------+ 
//  w     |        |outgoing|        outgoing parameters
//  t     |        | params |          not in registers
//  h     |        +--------+ 
//        |        |scratch |        scratch area
//  |     V        | area   |          16 bytes
//  |   -----------+--------+---->
//  V     ^        | local  |        local storage
//        |        |storage |        
//        |        +--------+
//        |        |  dyn   |        dynamic allocation
//        |        | alloc  |
//     Owned by    +--------+
//       SELF      | frame  |        frame marker
//        |        | marker |          for unwinding
//        |        +--------+
//        |        |outgoing|        outgoing parameters
//        |        | params |
//        |        +--------+
//        |        |scratch |        scratch area
//        V        | area   |          16 bytes
//      -----------+--------+---->

frame %{

//----------FRAME--------------------------------------------------------------
// Definition of frame structure and management information.
//
//  S T A C K   L A Y O U T    Allocators stack-slot number
//                             |   (to get allocators register number
//  G  Owned by    |        |  v    add SharedInfo::stack0)
//  r   CALLER     |        |
//  o     |        +--------+      pad to even-align allocators stack-slot 
//  w     V        |  pad0  |        numbers; owned by CALLER
//  t   -----------+--------+----> Matcher::_in_arg_limit, unaligned
//  h     ^        |   in   |  5   
//        |        |  args  |  4   Holes in incoming args owned by SELF
//  |     |        |        |  3
//  |     |        +--------+
//  V     |        | old out|      Empty on Intel, window on Sparc
//        |    old |preserve|      Must be even aligned.
//        |     SP-+--------+----> Matcher::_old_SP, even aligned
//        |        |   in   |  3   area for Intel ret address
//     Owned by    |preserve|      Empty on Sparc.
//       SELF      +--------+
//        |        |  pad2  |  2   pad to align old SP
//        |        +--------+  1
//        |        | locks  |  0
//        |        +--------+----> SharedInfo::stack0, even aligned  
//        |        |  pad1  | 11   pad to align new SP
//        |        +--------+
//        |        |        | 10
//        |        | spills |  9   spills
//        V        |        |  8   (pad0 slot for callee)
//      -----------+--------+----> Matcher::_out_arg_limit, unaligned
//        ^        |  out   |  7   
//        |        |  args  |  6   Holes in outgoing args owned by CALLEE
//     Owned by    +--------+
//      CALLEE     | new out|  6   Empty on Intel, window on Sparc
//        |    new |preserve|      Must be even-aligned.
//        |     SP-+--------+----> Matcher::_new_SP, even aligned
//        |        |        |
//
// Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is 
//         known from SELF's arguments and the Java calling convention.
//         Region 6-7 is determined per call site.
// Note 2: If the calling convention leaves holes in the incoming argument 
//         area, those holes are owned by SELF.  Holes in the outgoing area
//         are owned by the CALLEE.  Holes should not be nessecary in the
//         incoming area, as the Java calling convention is completely under
//         the control of the AD file.  Doubles can be sorted and packed to
//         avoid holes.  Holes in the outgoing arguments may be nessecary for
//         varargs C calling conventions.
// Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is 
//         even aligned with pad0 as needed.
//         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
//         region 6-11 is even aligned; it may be padded out more so that
//         the region from SP to FP meets the minimum stack alignment.
// Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
//         alignment.  Region 11, pad1, may be dynamically extended so that
//         SP meets the minimum alignment.

  // What direction does stack grow in (assumed to be same for native & Java)
  stack_direction(TOWARDS_LOW);

  // These two registers define part of the calling convention 
  // between compiled code and the interpreter.
  inline_cache_reg(GR27);              // Inline Cache Register
  interpreter_arg_ptr_reg(I0);         // Argument pointer for I2C adapters
  compiler_method_oop_reg(GR30);       // Temporary in compiled entry-points
  interpreter_method_oop_reg(GR27);    // Method Oop Register when calling interpreter

  // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
  cisc_spilling_operand_name(indOffset);

  // Number of stack slots consumed by a Monitor enter
  sync_stack_slots(2);

  // Compiled code's Frame Pointer
  frame_pointer(GR12_SP);

  // Interpreter stores its frame pointer in a register which is 
  // stored to the stack by I2CAdaptors.
  // I2CAdaptors convert from interpreted java to compiled java.
//  interpreter_frame_pointer(GR12_SP);
  // %%% is interpreter_frame_pointer needed for sparc?

  // Stack alignment requirement
  stack_alignment(7);            // Log of alignment size in bits (128-bit -> 7)

  // Number of stack slots between incoming argument block and the start of
  // a new frame.  The PROLOG must add this many slots to the stack.  The
  // EPILOG must remove this many slots.  
  in_preserve_stack_slots(0);

  // Number of stack slots reserved just above SELF's SP.
  // After a call, these remain between outgoing parameters and callee's frame.
  // These are the 16 words at %sp[0..15] on entry to the method,
  // so they are really %fp[0..15] after the SAVE.  The post-save
  // register window (%sp[0..15]) is declared here implicitly.
  // Extra stack slots required by the C ABI are declared by the
  // C calling convention; they are irrelevant to Java.
  // out_preserve_stack_slots(frame::register_save_words);
   out_preserve_stack_slots(frame::register_save_slots);

  // Number of outgoing stack slots killed above the out_preserve_stack_slots
  // for calls to C.  Supports the var-args backing area for register parms.
  // varargs_C_out_slots_killed(frame::varargs_offset);
  varargs_C_out_slots_killed(0);

  // The after-PROLOG location of the return address.  Location of
  // return address specifies a type (REG or STACK) and a number
  // representing the register number (i.e. - use a register name) or
  // stack slot.
  return_addr(REG BR0);          // Ret Addr is in register BR0

  // Body of function which returns an integer array locating
  // arguments either in registers or in stack slots.  Passed an array
  // of ideal registers called "sig" and a "length" count.  Stack-slot
  // offsets are based on outgoing arguments, i.e. a CALLER setting up
  // arguments for a CALLEE.  Incoming stack arguments are
  // automatically biased by the preserve_stack_slots field above.
  calling_convention %{           

    // Must map argument stack index to single or double argument register
    static const MachRegisterNumbers In_ArgReg[8] = {
      I0_num, I1_num, I2_num, I3_num, I4_num, I5_num, I6_num, I7_num };

    static const MachRegisterNumbers Out_ArgReg[8] = {
      O0_num, O1_num, O2_num, O3_num, O4_num, O5_num, O6_num, O7_num };

    static const MachRegisterNumbers F_ArgReg[8] = {
      FR8_num, FR9_num, FR10_num, FR11_num, FR12_num, FR13_num, FR14_num, FR15_num };

    // Convention is to pack the first 8 int/oop args into the first 8
    // input registers (I0-GR39), extras spill to the stack.  Pack
    // the first 8 float args into FR8-FR15, extras spill to the stack.
    // same registers as they fit, else spill to the stack.
    uint stk_reg = 0;
    uint flt_reg = 0;
    uint int_reg = 0;
    uint j;

    // Do the signature layout
    for( j = 0; j < length && int_reg < 8; j++) {
      switch( sig[j].ideal_reg() ) {
      case Op_RegI:
	sig[j].set1(is_outgoing ? Out_ArgReg[int_reg] : In_ArgReg[int_reg]);
        int_reg++;
        break;
      case Op_RegL:
        assert( j+1 < length && !sig[j+1].ideal_reg(), "expecting half" );
      case Op_RegP:
	sig[j].set2(is_outgoing ? Out_ArgReg[int_reg] : In_ArgReg[int_reg]);
        int_reg++;
        break;
      case Op_RegF:
	sig[j].set1(F_ArgReg[flt_reg++]);
        int_reg++;
        break;
      case Op_RegD:
        assert( j+1 < length && !sig[j+1].ideal_reg(), "expecting half" );
	sig[j].set2(F_ArgReg[flt_reg++]);
        int_reg++;
        break;
      case 0:  // Halves of longs and doubles
        sig[j].set_bad();
        break;
      default:
        ShouldNotReachHere();
      }
    }

    for( ; j < length; j++) {
      switch( sig[j].ideal_reg() ) {
      case Op_RegI:
      case Op_RegF:
	sig[j].set1(SharedInfo::stack2reg(stk_reg));
        stk_reg += 2;
        break;
      case Op_RegL:
      case Op_RegD:
        assert( !sig[j+1].ideal_reg(), "expecting half" );
      case Op_RegP:
	sig[j].set2(SharedInfo::stack2reg(stk_reg));
        stk_reg += 2;
        break;
      case 0:  // Halves of longs and doubles
        sig[j].set_bad();
        break;
      default:
        ShouldNotReachHere();
      }
    }
  %}


  c_calling_convention %{
    // Must map argument stack index to single or double argument register
    static const MachRegisterNumbers Out_ArgReg[8] = {
      O0_num, O1_num, O2_num, O3_num, O4_num, O5_num, O6_num, O7_num };

    static const MachRegisterNumbers F_ArgReg[8] = {
      FR8_num, FR9_num, FR10_num, FR11_num, FR12_num, FR13_num, FR14_num, FR15_num };

    // Convention is to pack the first 8 int/oop args into the first 8
    // input registers (I0-GR39), extras spill to the stack.  Pack
    // the first 8 float args into FR8-FR15, extras spill to the stack.
    // same registers as they fit, else spill to the stack.
    uint stk_reg = 0;
    uint flt_reg = 0;
    uint int_reg = 0;
    uint j;

    // Do the signature layout
    for( j = 0; j < length && int_reg < 8; j++) {
      switch( sig[j].ideal_reg() ) {
      case Op_RegI:
	sig[j].set1(Out_ArgReg[int_reg++]);
        break;
      case Op_RegL:
        assert( j+1 < length && !sig[j+1].ideal_reg(), "expecting half" );
      case Op_RegP:
	sig[j].set2(Out_ArgReg[int_reg++]);
        break;
      case Op_RegF:
	sig[j].set1(F_ArgReg[flt_reg++]);
        int_reg++;
        break;
      case Op_RegD:
        assert( j+1 < length && !sig[j+1].ideal_reg(), "expecting half" );
	sig[j].set2(F_ArgReg[flt_reg++]);
        int_reg++;
        break;
      case 0:  // Halves of longs and doubles
        sig[j].set_bad();
        break;
      default:
        ShouldNotReachHere();
      }
    }

    for( ; j < length; j++) {
      switch( sig[j].ideal_reg() ) {
      case Op_RegI:
      case Op_RegF:
	sig[j].set1(SharedInfo::stack2reg(stk_reg));
        stk_reg += 2;
        break;
      case Op_RegL:
      case Op_RegD:
        assert( !sig[j+1].ideal_reg(), "expecting half" );
      case Op_RegP:
	sig[j].set2(SharedInfo::stack2reg(stk_reg));
        stk_reg += 2;
        break;
      case 0:  // Halves of longs and doubles
        sig[j].set_bad();
        break;
      default:
        ShouldNotReachHere();
      }
    }
  %}

  // Location of compiled Java return values.  Same as C
  return_value %{
    assert( ideal_reg >= Op_RegI && ideal_reg <= Op_RegL, "only return normal values" );
    static int lo_out[Op_RegL+1] = { 0, 0, GR8_RET_num,  GR8_RET_num,  FR8_num,      FR8_num,  GR8_RET_num  };
    static int hi_out[Op_RegL+1] = { 0, 0, OptoReg::Bad, GR8_RETH_num, OptoReg::Bad, FR8H_num, GR8_RETH_num };
    static int lo_in [Op_RegL+1] = { 0, 0, GR8_RET_num,  GR8_RET_num,  FR8_num,      FR8_num,  GR8_RET_num  };
    static int hi_in [Op_RegL+1] = { 0, 0, OptoReg::Bad, GR8_RETH_num, OptoReg::Bad, FR8H_num, GR8_RETH_num };
    return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
                        (is_outgoing?lo_out:lo_in)[ideal_reg] );
  %}

%}


//----------ATTRIBUTES---------------------------------------------------------
//----------Operand Attributes-------------------------------------------------
op_attrib op_cost(1);          // Required cost attribute

//----------Instruction Attributes---------------------------------------------
ins_attrib ins_cost(DEFAULT_COST); // Required cost attribute
ins_attrib ins_size(41);       // Required size attribute (in bits)
ins_attrib ins_pc_relative(0); // Required PC Relative flag
ins_attrib ins_short_branch(0); // Required flag: is this instruction a
                                // non-matching short branch variant of some
							    // long branch?

//----------OPERANDS-----------------------------------------------------------
// Operand definitions must precede instruction definitions for correct parsing
// in the ADLC because operands constitute user defined types which are used in
// instruction definitions.

//----------Simple Operands----------------------------------------------------
// Immediate Operands
// Integer Immediate: 32-bit
operand immI() %{
  match(ConI);

  op_cost(5);
  // formats are generated automatically for constants and base registers
  format %{ %}                
  interface(CONST_INTER);
%}

// Integer Immediate: 22-bit
operand immI22() %{
  predicate(Assembler::is_simm22(n->get_int()));
  match(ConI);

  op_cost(50);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: 14-bit
operand immI14() %{
  predicate(Assembler::is_simm14(n->get_int()));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: 8-bit
operand immI8() %{
  predicate(Assembler::is_simm8(n->get_int()));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: 8-bit
operand immI8m1() %{
  predicate(Assembler::is_simm8(n->get_int()-1));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: 0-bit
operand immI_0() %{
  predicate(n->get_int() == 0);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: 1
operand immI_1() %{
  predicate(n->get_int() == 1);
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Unsigned (positive) Integer Immediate: 1,2,3,4 for shift-n-add
operand immI_1to4() %{
  predicate(n->get_int() >= 1 && n->get_int() <= 4);
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Unsigned (positive) Integer Immediate: 6-bit
operand immI_1to64() %{
  predicate(Assembler::is_shift_constant(n->get_int()));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: the value 255
operand immI_255() %{
  predicate( n->get_int() == 255 );
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate: 64-bit
operand immP() %{
  match(ConP);

  op_cost(50);
  // formats are generated automatically for constants and base registers
  format %{ %}                
  interface(CONST_INTER);
%}

operand immP0() %{
  predicate(n->get_ptr() == 0);
  match(ConP);

  op_cost(5);
  format %{ %}                
  interface(CONST_INTER);
%}

operand immL() %{
  match(ConL);

  op_cost(50);
  // formats are generated automatically for constants and base registers
  format %{ %}                
  interface(CONST_INTER);
%}

operand immL_0() %{
  predicate(n->get_long() == 0L);
  match(ConL);

  op_cost(0);
  // formats are generated automatically for constants and base registers
  format %{ %}                
  interface(CONST_INTER);
%}

// Long Immediate: 8-bit
operand immL8() %{
  predicate((-128L <= n->get_long()) && (n->get_long() <= 127L));
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Immediate: 8-bit
operand immL8m1() %{
  predicate((-127L <= n->get_long()) && (n->get_long() <= 128L));
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate: 14-bit
operand immL14() %{
  predicate((-8192L <= n->get_long()) && (n->get_long() <= 8191L));
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate: 22-bit
operand immL22() %{
  predicate((-2097152L <= n->get_long()) && (n->get_long() <= 2097151L));
  match(ConL);

  op_cost(25);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate
operand immD() %{
  match(ConD);

  op_cost(40);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate: 0
operand immD_0() %{
  predicate((((ConDNode*)n)->type() == TypeD::ZERO));
  match(ConD);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate: 1
operand immD_1() %{
  predicate((((ConDNode*)n)->type() == TypeD::ONE));
  match(ConD);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate: 2
operand immD_2() %{
  predicate((n->getd() == 2.0));
  match(ConD);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate
operand immF() %{
  match(ConF);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate, not denormalized
operand immF_not_denorm() %{
  predicate( fabs((double)n->getf() + ia64_double_zero) >= 1.175494351e-38 );
  match(ConF);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate: 0
operand immF_0() %{
  predicate((((ConFNode*)n)->type() == TypeF::ZERO));
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate: 1
operand immF_1() %{
  predicate((((ConFNode*)n)->type() == TypeF::ONE));
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate: 2
operand immF_2() %{
  predicate((n->getf() == 2.0));
  match(ConF);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Integer Register Operands

// Integer Register
operand gRegI() %{
  constraint(ALLOC_IN_RC(bits32_reg));
  match(RegI);
  match(g23RegI);
  match(g8retRegI);

  format %{ %}
  interface(REG_INTER);
%}

// // Register for 0
// operand g0RegI() %{
//   constraint(ALLOC_IN_RC(gr0_reg));
//   match(RegI);
// 
//   format %{ %}
//   interface(REG_INTER);
// %}

// Register for 22 bit immediate
operand g23RegI() %{
  constraint(ALLOC_IN_RC(imm22_32reg));
  match(RegI);

  format %{ %}
  interface(REG_INTER);
%}

// Integer Register Return Value
operand g8retRegI() %{
  constraint(ALLOC_IN_RC(g8_ret_regI));
  match(gRegI);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand sp_or_gRegP() %{
  constraint(ALLOC_IN_RC(bits64_sp_reg));
  match(RegP);

  match(retRegP);
  match(o0RegP);
  match(o1RegP);
  match(o2RegP);
  match(o3RegP);
  match(o4RegP);
  match(o5RegP);
  match(o6RegP);
  match(o7RegP);
  match(gRegP_notmp);
  match(gr2_gRegP);
  match(gr3_gRegP);
  match(g23RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gRegP() %{
  constraint(ALLOC_IN_RC(bits64_reg));
  match(RegP);

  match(retRegP);
  match(o0RegP);
  match(o1RegP);
  match(o2RegP);
  match(o3RegP);
  match(o4RegP);
  match(o5RegP);
  match(o6RegP);
  match(o7RegP);
  match(gRegP_notmp);
  match(gr2_gRegP);
  match(gr3_gRegP);
  match(g23RegP);

  format %{ %}
  interface(REG_INTER);
%}

operand gRegP_notmp() %{
  constraint(ALLOC_IN_RC(bits64_reg_notmp));
  match(RegP);

  match(retRegP);
  match(o0RegP);
  match(o1RegP);
  match(o2RegP);
  match(o3RegP);
  match(o4RegP);
  match(o5RegP);
  match(o6RegP);
  match(o7RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 0
operand retRegP() %{
  constraint(ALLOC_IN_RC(ret_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr2_gRegP() %{
  constraint(ALLOC_IN_RC(g2_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr3_gRegP() %{
  constraint(ALLOC_IN_RC(g3_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr28_gRegP() %{
  constraint(ALLOC_IN_RC(g28_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr29_gRegP() %{
  constraint(ALLOC_IN_RC(g29_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr30_gRegP() %{
  constraint(ALLOC_IN_RC(g30_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr31_gRegP() %{
  constraint(ALLOC_IN_RC(g31_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for 22 bit immediate
operand g23RegP() %{
  constraint(ALLOC_IN_RC(imm22_64reg));
  match(RegP);
  match(gr2_gRegP);
  match(gr3_gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for GR1_GP
operand gpRegP() %{
  constraint(ALLOC_IN_RC(gp_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register (preserve BSP)
operand Lsave_BSP_gRegP() %{
  constraint(ALLOC_IN_RC(l3_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register (preserve RP)
operand Lsave_RP_gRegP() %{
  constraint(ALLOC_IN_RC(l2_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register (preserve GP)
operand Lsave_GP_gRegP() %{
  constraint(ALLOC_IN_RC(l5_regP));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 0
operand o0RegP() %{
  constraint(ALLOC_IN_RC(o0_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 1
operand o1RegP() %{
  constraint(ALLOC_IN_RC(o1_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 2
operand o2RegP() %{
  constraint(ALLOC_IN_RC(o2_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 3
operand o3RegP() %{
  constraint(ALLOC_IN_RC(o3_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 4
operand o4RegP() %{
  constraint(ALLOC_IN_RC(o4_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 5
operand o5RegP() %{
  constraint(ALLOC_IN_RC(o5_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 6
operand o6RegP() %{
  constraint(ALLOC_IN_RC(o6_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Register for Output Register 7
operand o7RegP() %{
  constraint(ALLOC_IN_RC(o7_regP));
  match(gRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Long Register
operand gRegL() %{
  constraint(ALLOC_IN_RC(bits64_reg));
  match(RegL);
  match(gr30_gRegL);

  format %{ %}
  interface(REG_INTER);
%}

// Register for 22 bit immediate
operand g23RegL() %{
  constraint(ALLOC_IN_RC(imm22_64reg));
  match(RegL);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand gr30_gRegL() %{
  constraint(ALLOC_IN_RC(g30_regL));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Float register operands
operand fRegD() %{
  constraint(ALLOC_IN_RC(double_reg));
  match(RegD);
  match(fRegD_notmp15);
  match(fRegD_notmp12);
  match(fr6_fRegD);
  match(fr7_fRegD);
  match(fr8_fRegD);
  match(fr9_fRegD);
  match(fr10_fRegD);
  match(fr11_fRegD);
  match(fr12_fRegD);
  match(fr13_fRegD);
  match(fr14_fRegD);
  match(fr15_fRegD);

  format %{ %}
  interface(REG_INTER);
%}

operand fRegD_notmp15() %{
  constraint(ALLOC_IN_RC(double_reg_notmp15));
  match(RegD);
  match(fr6_fRegD);
  match(fr7_fRegD);
  match(fr8_fRegD);
  match(fr9_fRegD);
  match(fr10_fRegD);
  match(fr11_fRegD);
  match(fr12_fRegD);
  match(fr13_fRegD);
  match(fr14_fRegD);

  format %{ %}
  interface(REG_INTER);
%}

operand fRegD_notmp12() %{
  constraint(ALLOC_IN_RC(double_reg_notmp12));
  match(RegD);
  match(fr6_fRegD);
  match(fr7_fRegD);
  match(fr8_fRegD);
  match(fr9_fRegD);
  match(fr10_fRegD);
  match(fr11_fRegD);

  format %{ %}
  interface(REG_INTER);
%}

operand fr6_fRegD() %{
  constraint(ALLOC_IN_RC(fr6_regD));
  match(fRegD);

  format %{ "FR6" %}
  interface(REG_INTER);
%}

operand fr7_fRegD() %{
  constraint(ALLOC_IN_RC(fr7_regD));
  match(fRegD);

  format %{ "FR7" %}
  interface(REG_INTER);
%}

operand fr8_fRegD() %{
  constraint(ALLOC_IN_RC(fr8_regD));
  match(fRegD);

  format %{ "FR8" %}
  interface(REG_INTER);
%}

operand fr9_fRegD() %{
  constraint(ALLOC_IN_RC(fr9_regD));
  match(fRegD);

  format %{ "FR9" %}
  interface(REG_INTER);
%}

operand fr10_fRegD() %{
  constraint(ALLOC_IN_RC(fr10_regD));
  match(fRegD);

  format %{ "FR10" %}
  interface(REG_INTER);
%}

operand fr11_fRegD() %{
  constraint(ALLOC_IN_RC(fr11_regD));
  match(fRegD);

  format %{ "FR11" %}
  interface(REG_INTER);
%}

operand fr12_fRegD() %{
  constraint(ALLOC_IN_RC(fr12_regD));
  match(fRegD);

  format %{ "FR12" %}
  interface(REG_INTER);
%}

operand fr13_fRegD() %{
  constraint(ALLOC_IN_RC(fr13_regD));
  match(fRegD);

  format %{ "FR13" %}
  interface(REG_INTER);
%}

operand fr14_fRegD() %{
  constraint(ALLOC_IN_RC(fr14_regD));
  match(fRegD);

  format %{ "FR14" %}
  interface(REG_INTER);
%}

operand fr15_fRegD() %{
  constraint(ALLOC_IN_RC(fr15_regD));
  match(fRegD);

  format %{ "FR15" %}
  interface(REG_INTER);
%}

operand fRegF() %{
  constraint(ALLOC_IN_RC(float_reg));
  match(RegF);

  match(fRegF_notmp);
  match(fRegF_notmp13);
  match(fRegF_notmp15);
  match(fr6_fRegF);
  match(fr7_fRegF);
  match(fr8_fRegF);
  match(fr9_fRegF);
  match(fr10_fRegF);
  match(fr11_fRegF);
  match(fr12_fRegF);
  match(fr13_fRegF);
  match(fr14_fRegF);
  match(fr15_fRegF);

  format %{ %}
  interface(REG_INTER);
%}

operand fRegF_notmp15() %{
  constraint(ALLOC_IN_RC(float_reg_notmp15));
  match(RegF);

  match(fr6_fRegF);
  match(fr7_fRegF);
  match(fr8_fRegF);
  match(fr9_fRegF);
  match(fr10_fRegF);
  match(fr11_fRegF);
  match(fr12_fRegF);
  match(fr13_fRegF);
  match(fr14_fRegF);

  format %{ %}
  interface(REG_INTER);
%}

operand fRegF_notmp13() %{
  constraint(ALLOC_IN_RC(float_reg_notmp13));
  match(RegF);

  match(fr6_fRegF);
  match(fr7_fRegF);
  match(fr8_fRegF);
  match(fr9_fRegF);
  match(fr10_fRegF);
  match(fr11_fRegF);
  match(fr12_fRegF);

  format %{ %}
  interface(REG_INTER);
%}

operand fRegF_notmp() %{
  constraint(ALLOC_IN_RC(float_reg_notmp));
  match(RegF);

  match(fr6_fRegF);
  match(fr7_fRegF);
  match(fr8_fRegF);

  format %{ %}
  interface(REG_INTER);
%}

operand fr6_fRegF() %{
  constraint(ALLOC_IN_RC(fr6_regF));
  match(fRegF);

  format %{ "FR6" %}
  interface(REG_INTER);
%}

operand fr7_fRegF() %{
  constraint(ALLOC_IN_RC(fr7_regF));
  match(fRegF);

  format %{ "FR7" %}
  interface(REG_INTER);
%}

operand fr8_fRegF() %{
  constraint(ALLOC_IN_RC(fr8_regF));
  match(fRegF);

  format %{ "FR8" %}
  interface(REG_INTER);
%}

operand fr9_fRegF() %{
  constraint(ALLOC_IN_RC(fr9_regF));
  match(fRegF);

  format %{ "FR9" %}
  interface(REG_INTER);
%}

operand fr10_fRegF() %{
  constraint(ALLOC_IN_RC(fr10_regF));
  match(fRegF);

  format %{ "FR10" %}
  interface(REG_INTER);
%}

operand fr11_fRegF() %{
  constraint(ALLOC_IN_RC(fr11_regF));
  match(fRegF);

  format %{ "FR11" %}
  interface(REG_INTER);
%}

operand fr12_fRegF() %{
  constraint(ALLOC_IN_RC(fr12_regF));
  match(fRegF);

  format %{ "FR12" %}
  interface(REG_INTER);
%}

operand fr13_fRegF() %{
  constraint(ALLOC_IN_RC(fr13_regF));
  match(fRegF);

  format %{ "FR13" %}
  interface(REG_INTER);
%}

operand fr14_fRegF() %{
  constraint(ALLOC_IN_RC(fr14_regF));
  match(fRegF);

  format %{ "FR14" %}
  interface(REG_INTER);
%}

operand fr15_fRegF() %{
  constraint(ALLOC_IN_RC(fr15_regF));
  match(fRegF);

  format %{ "FR15" %}
  interface(REG_INTER);
%}

// Predicate Register
operand pReg() %{
  constraint(ALLOC_IN_RC(predicate_reg));
  match(RegFlags);
  match(pr6_pReg);
  match(pr7_pReg);
  match(pr8_pReg);
  match(pr9_pReg);
  match(pr10_pReg);

  format %{ "PRxx" %}
  interface(REG_INTER);
%}

// Predicate Register 6
operand pr6_pReg() %{
  constraint(ALLOC_IN_RC(pr6_reg));
  match(RegFlags);
  match(pReg);

  format %{ "PR6" %}
  interface(REG_INTER);
%}

// Predicate Register 7
operand pr7_pReg() %{
  constraint(ALLOC_IN_RC(pr7_reg));
  match(RegFlags);
  match(pReg);

  format %{ "PR7" %}
  interface(REG_INTER);
%}

// Predicate Register 8
operand pr8_pReg() %{
  constraint(ALLOC_IN_RC(pr8_reg));
  match(RegFlags);
  match(pReg);

  format %{ "PR8" %}
  interface(REG_INTER);
%}

// Predicate Register 9
operand pr9_pReg() %{
  constraint(ALLOC_IN_RC(pr9_reg));
  match(RegFlags);
  match(pReg);

  format %{ "PR9" %}
  interface(REG_INTER);
%}

// Predicate Register 10
operand pr10_pReg() %{
  constraint(ALLOC_IN_RC(pr10_reg));
  match(RegFlags);
  match(pReg);

  format %{ "PR10" %}
  interface(REG_INTER);
%}

// Return Register
operand return_bRegP() %{
  constraint(ALLOC_IN_RC(br0_reg));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Branch Register
operand scratch_bRegP() %{
  constraint(ALLOC_IN_RC(br6_reg));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Branch Register
operand call_bRegP() %{
  constraint(ALLOC_IN_RC(br7_reg));
  match(RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Method Register
operand inline_cache_gRegP(gRegP reg) %{
  constraint(ALLOC_IN_RC(inline_cache_regs));
  match(reg);
  format %{ %}
  interface(REG_INTER);
%}

operand compiler_method_oop_regP(gRegP reg) %{
  constraint(ALLOC_IN_RC(compiler_method_oop_regs));
  match(reg);
  format %{ %}
  interface(REG_INTER);
%}

operand interpreter_method_oop_regP(gRegP reg) %{
  constraint(ALLOC_IN_RC(interpreter_method_oop_regs));
  match(reg);
  format %{ %}
  interface(REG_INTER);
%}

//----------Complex Operands---------------------------------------------------
// Indirect Memory Reference
operand indirect(gRegP reg) %{
  constraint(ALLOC_IN_RC(bits64_reg));
  match(reg);

  op_cost(100);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0x0);
    scale(0x0);
    disp(0x0);
  %}
%}

//----------Conditional Branch Operands----------------------------------------
// Comparison Op  - This is the operation of the comparison, and is limited to
//                  the following set of codes:
//                  L (<), LE (<=), G (>), GE (>=), E (==), NE (!=)
//
// Other attributes of the comparison, such as unsignedness, are specified
// by the comparison instruction that sets a condition code flags register.
// That result is represented by a flags operand whose subtype is appropriate
// to the unsignedness (etc.) of the comparison.
//
// Later, the instruction which matches both the Comparison Op (a Bool) and
// the flags (produced by the Cmp) specifies the coding of the comparison op
// by matching a specific subtype of Bool operand below, such as cmpOpU.

operand cmpOp() %{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal        (0x0);
    not_equal    (0x1);
    less         (0x2);
    less_equal   (0x3);
    greater      (0x4);
    greater_equal(0x5);
  %}
%}

operand cmpOpU() %{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal        (0x0);
    not_equal    (0x1);
    less         (0x6);
    less_equal   (0x7);
    greater      (0x8);
    greater_equal(0x9);
  %}
%}


//----------Special Memory Operands--------------------------------------------
// Stack Slot Operand - This operand is used for loading and storing temporary
//                      values on the stack where a match requires a value to
//                      flow through memory.
operand stackSlotI(sRegI reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  op_cost(100);
  //match(RegI);
  format %{ "$reg" %}
  interface(MEMORY_INTER) %{
    base(0xC);   // SP
    index(0x0);
    scale(0x0);
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotP(sRegP reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  op_cost(100);
  //match(RegP);
  format %{ "$reg" %}
  interface(MEMORY_INTER) %{
    base(0xC);   // SP
    index(0x0);
    scale(0x0);
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotF(sRegF reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  op_cost(100);
  //match(RegF);
  format %{ "$reg" %}
  interface(MEMORY_INTER) %{
    base(0xC);   // SP
    index(0x0);
    scale(0x0);
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotD(sRegD reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  op_cost(100);
  //match(RegD);
  format %{ "$reg" %}
  interface(MEMORY_INTER) %{
    base(0xC);   // SP
    index(0x0);
    scale(0x0);
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotL(sRegL reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  op_cost(100);
  //match(RegL);
  format %{ "$reg" %}
  interface(MEMORY_INTER) %{
    base(0xC);   // SP
    index(0x0);
    scale(0x0);
    disp($reg);  // Stack Offset
  %}
%}

// Operands for expressing Control Flow
// NOTE:  Label is a predefined operand which should not be redefined in
//        the AD file.  It is generically handled within the ADLC.

//----------OPERAND CLASSES----------------------------------------------------
// Operand Classes are groups of operands that are used to simplify
// instruction definitions by not requiring the AD writer to specify seperate
// instructions for every form of operand when the instruction accepts
// multiple operand types with the same basic encoding and format.  The classic
// case of this is memory operands.
opclass memory( indirect );

//----------PIPELINE-----------------------------------------------------------
pipeline %{

//----------ATTRIBUTES---------------------------------------------------------
attributes %{
  fixed_size_instructions;           // Fixed size instructions
  max_instructions_per_bundle =  3;  // Up to 3 instructions per bundle
  bundle_unit_size            = 16;  // A bundle is 16 bytes long
  max_bundles_per_cycle       =  2;  // Supports 2 bundles per cycle
  instruction_fetch_unit_size = 16;  // The processor fetches two lines
  instruction_fetch_units     =  2;  // of 16 bytes

  // List of nop instructions
  nops( Nop_I0, Nop_I1, Nop_M0, Nop_M1, Nop_B0, Nop_B1, Nop_B2, Nop_F0, Nop_F1 );
%}

//----------RESOURCES----------------------------------------------------------
// Resources are the functional units available to the machine
resources( M0, M1, I0, I1, A0, A1, A2, A3, F0, F1, B0, B1, B2, X0, X1,
    M    = M0 | M1,
    I    = I0 | I1,
    F    = F0 | F1,
    B    = B0 | B1 | B2,
    X    = X0 | X1,
    IALU = A0 | A1 | A2 | A3
);

//----------PIPELINE DESCRIPTION-----------------------------------------------
// Pipeline Description specifies the stages in the machine's pipeline

pipe_desc(
    IPG,
    FET,
    ROT,	// Rotate
    EXP,	// Expand
    REN,	// Rename
    WLD,
    REG,	// Read Register
    EXE,	// Execute
    DET,	// Detect Exceptions
    WRB		// Write Back
);

//----------PIPELINE CLASSES---------------------------------------------------
// Pipeline Classes describe the stages in which input and output are
// referenced by the hardware pipeline.

// Nop class(es)
pipe_class ialu_nop_I0() %{
    I0     : EXE;
%}

pipe_class ialu_nop_I1() %{
    I1     : EXE;
%}

pipe_class ialu_nop_M0() %{
    M0     : EXE;
%}

pipe_class ialu_nop_M1() %{
    M1     : EXE;
%}

pipe_class ialu_nop_B0() %{
    B0     : EXE;
%}

pipe_class ialu_nop_B1() %{
    B1     : EXE;
%}

pipe_class ialu_nop_B2() %{
    B2     : EXE;
%}

pipe_class ialu_nop_F0() %{
    F0     : EXE;
%}

pipe_class ialu_nop_F1() %{
    F1     : EXE;
%}

// (pReg) BR
pipe_class BR_pr(label labl) %{
    single_instruction;
    B      : EXE;
%}

// LDF reg = mem (for s/d data types) - 9 cycles latency for level 2 cache hit
pipe_class fr_LDF_mem(fRegD dst, memory mem) %{
    single_instruction;
    dst    : EXE(write)+8;
    mem    : WLD(read);
    M      : EXE;
%}

// Compare Float
pipe_class pr_pr_FCMP_fr_fr(pReg p1, pReg p2, fRegD src1, fRegD src2) %{
    single_instruction;
    p1     : EXE(write);
    p2     : EXE(write);
    src1   : REG(read);
    src2   : REG(read);
    F      : EXE;
%}

pipe_class pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr(cmpOp cmp, fRegD src1, immD_0 src2, label labl, pr6_pReg pr1) %{
    multiple_bundles; instruction_count(1);
    src1   : REG(read);
    pr1    : EXE(write);
    F      : EXE;
//  F      : EXE+2;
//  B      : EXE+4;
%}

pipe_class pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr(cmpOp cmp, fRegD src1, fRegD src2, label labl, pr6_pReg pr1) %{
    multiple_bundles; instruction_count(1);
    src1   : REG(read);
    src2   : REG(read);
    pr1    : EXE(write);
    F      : EXE;
//  F      : EXE+2;
//  B      : EXE+4;
%}

pipe_class pr_pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr(cmpOp cmp, fRegD src1, fRegD src2, label labl, pr6_pReg pr1, pr7_pReg pr2) %{
    multiple_bundles; instruction_count(1);
    src1   : REG(read);
    src2   : REG(read);
    pr1    : EXE(write);
    pr2    : EXE(write);
    F      : EXE;
//  F      : EXE+2;
//  B      : EXE+4;
%}

pipe_class pr_pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr(cmpOp cmp, fRegD src1, immD_0 src2, label labl, pr6_pReg pr1, pr7_pReg pr2) %{
    multiple_bundles; instruction_count(1);
    src1   : REG(read);
    pr1    : EXE(write);
    pr2    : EXE(write);
    F      : EXE;
//  F      : EXE+2;
//  B      : EXE+4;
%}

pipe_class pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr(gRegI dst, cmpOp cmp, gRegI src, fRegD in1, fRegD in2, pr6_pReg pr) %{
    multiple_bundles; instruction_count(1);
    in1    : REG(read);
    in2    : REG(read);
    pr     : EXE(write);
    pr     : EXE(write)+1;
    dst    : EXE(write)+2;
    F      : EXE;
//  F      : EXE+1;
//  IALU   : EXE+2;
%}

// Convert Float to Fixed - 7 cycles latency
pipe_class fr_FCVTFX_fr(fRegD dst, fRegD src) %{
    single_instruction;
    dst    : EXE(write)+6;
    src    : WLD(read);
%}

pipe_class gr_IALU_imm__pr_pr_FCMP_fr_fr__gr_IALU_imm__pr_FCMP_fr_fr_pr__pr_FCMP_fr_fr_pr__gr_IALU_imm__gr_IALU_imm(gRegI dst, fRegF src1, fRegF src2, pr6_pReg pr1, pr7_pReg pr2, pr8_pReg pr3, pr9_pReg pr4 ) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+4;
    src1   : REG(read);
    src2   : REG(read);
    F      : EXE;
    IALU   : EXE;
//  F      : EXE+2;
//  F      : EXE+2;
//  IALU   : EXE+2;
//  IALU   : EXE+4;
//  IALU   : EXE+4;
%}

// Convert Float to Fixed - 7 cycles latency
pipe_class fr_FCVTFX_fr_pr(fRegD dst, fRegD src, pReg qp) %{
    single_instruction;
    dst    : EXE(write)+6;
    src    : WLD(read);
    qp     : REG(read);
    F      : EXE;
%}

// (pReg) FMAC fReg = fReg, fReg : 5 cycle latency
pipe_class fr_FMAC_fr_fr(fRegD dst, fRegD src1, fRegD src2) %{
    single_instruction;
    dst    : EXE(write)+4;
    src1   : REG(read);
    src2   : REG(read);
    F      : EXE;
%}

// (pReg) FMAC fReg = fReg, fReg, fReg : 5 cycle latency
pipe_class fr_FMAC_fr_fr_fr(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
    single_instruction;
    dst    : EXE(write)+4;
    src1   : REG(read);
    src2   : REG(read);
    src3   : REG(read);
    F      : EXE;
%}

// (pReg) FMAC fReg = fReg, fReg : 5 cycle latency (special case w/ 1 operand used twice)
pipe_class fr_FMAC_fr(fRegD dst, fRegD src) %{
    single_instruction;
    dst    : EXE(write)+4;
    src    : REG(read);
    F      : EXE;
%}

// (pReg) IALU gReg = gReg, gReg : 1 cycle latency
pipe_class gr_IALU_gr_gr(gRegI dst, gRegI src1, gRegI src2) %{
    single_instruction;
    dst    : EXE(write);
    src1   : REG(read);
    src2   : REG(read);
    IALU   : EXE;
%}

// (pReg) IALU gReg = gReg, imm14 : 1 cycle latency
pipe_class gr_IALU_gr_imm(gRegI dst, gRegI src1, immI14 src2) %{
    single_instruction;
    dst    : EXE(write);
    src1   : REG(read);
    IALU   : EXE;
%}

// IALU (mov) reg = reg operation
pipe_class gr_IALU_pr(gRegI dst, pReg qp) %{
    single_instruction;
    dst    : EXE(write);
    qp     : REG(read);
    IALU   : EXE;
%}

// IALU (mov) reg = reg operation
pipe_class gr_IALU_gr(gRegI dst, gRegI src) %{
    single_instruction;
    dst    : EXE(write);
    src    : REG(read);
    IALU   : EXE;
%}

// IALU (movl) reg = imm operation
pipe_class gr_IALU_imm(gRegI dst, immI src) %{
    single_instruction;
    dst    : EXE(write);
    IALU   : EXE;
%}

pipe_class gr_IALU_gr__pr_ICMP_gr_gr__pr_ICMP_gr_gr__gr_IALU_imm__gr_IALU_imm(gRegI dst, gRegL src1, gRegL src2, pReg pr1, pReg pr2 ) %{
    multiple_bundles;
    dst    : EXE(write)+1;
    src1   : REG(read);
    src2   : REG(read);
    IALU   : EXE;
    IALU   : EXE;
    IALU   : EXE;
    IALU   : DET; // Really EXE+1
    IALU   : DET; // Really EXE+1
%}

// (pReg) ICMP pReg, pReg = gReg, gReg : 1 cycle latency
pipe_class pr_pr_ICMP_gr_gr(pReg pTrue, pReg pFalse, gRegI src1, gRegI src2) %{
    single_instruction;
    pTrue  : EXE(write);
    pFalse : EXE(write);
    src1   : REG(read);
    src2   : REG(read);
    IALU   : EXE;
%}

pipe_class pr_pr_ICMP_gr_gr_pr(pReg pTrue, pReg pFalse, gRegI src1, gRegI src2, pReg qp) %{
    single_instruction;
    pTrue  : EXE(write);
    pFalse : EXE(write);
    src1   : REG(read);
    src2   : REG(read);
    qp     : REG(read);
    IALU   : EXE;
%}

pipe_class pr_ICMP_gr_gr_pr(pReg pTrue, gRegI src1, gRegI src2, pReg qp) %{
    single_instruction;
    pTrue  : EXE(write);
    src1   : REG(read);
    src2   : REG(read);
    qp     : REG(read);
    IALU   : EXE;
%}

// (pReg) ICMP pReg, pReg = gReg, gReg : 1 cycle latency
pipe_class pr_pr_ICMP_gr_gr__BR_pr(cmpOp cmp, gRegI src1, gRegI src2, label labl) %{
    instruction_count(2);
    src1   : REG(read);
    src2   : REG(read);
    IALU   : EXE;
    B      : EXE;
%}

pipe_class pr_pr_ICMP_gr_gr__gr_IALU_gr(cmpOp cmp, gRegI dst, gRegI src, gRegI in1, gRegI in2, pReg pr) %{
    multiple_bundles; instruction_count(1);
    in1    : REG(read);
    in2    : REG(read);
    dst    : EXE(write)+1;
    IALU   : EXE;
    IALU   : DET; // Really EXE+1
%}

pipe_class pr_pr_ICMP_gr_gr__gr_IALU_imm(cmpOp cmp, gRegI dst, immI14 src, gRegI in1, gRegI in2) %{
    multiple_bundles; instruction_count(1);
    in1    : REG(read);
    in2    : REG(read);
    dst    : EXE(write)+1;
    IALU   : EXE;
    IALU   : DET; // Really EXE+1
%}

pipe_class pr_pr_ICMP_gr_imm__gr_IALU_imm(cmpOp cmp, gRegI dst, immI14 src, gRegI in1, immI_0 in2) %{
    multiple_bundles; instruction_count(1);
    in1    : REG(read);
    dst    : EXE(write)+1;
    IALU   : EXE;
    IALU   : DET; // Really EXE+1
%}

pipe_class pr_pr_ICMP_gr_gr__fr_FMISC_fr(cmpOp cmp, fRegF dst, fRegF src, gRegI in1, gRegI in2) %{
    multiple_bundles; instruction_count(1);
    in1    : REG(read);
    in2    : REG(read);
    src    : REG(read)+1;
    dst    : EXE(write)+1;
    IALU   : EXE;
    F      : DET; // Really EXE+1
%}

pipe_class pr_pr_ICMP_gr__gr_IALU_gr__gr_IALU_gr(gRegI dst, gRegI src) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+1;
    src    : REG(read);
    IALU   : EXE; // One IALU operation  in 1st cycle
    IALU   : DET; // Two IALU operations in 2nd cycle
    IALU   : DET;
%}

pipe_class pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_gr(gRegI dst, gRegL src1, gRegL src2, pReg pr1, pReg pr2 ) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+1;
    src1   : REG(read);
    src2   : REG(read);
    IALU   : EXE; // One IALU operation  in 1st cycle
    IALU   : DET; // Two IALU operations in 2nd cycle
    IALU   : DET;
%}

pipe_class pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_gr_1(gRegI dst, gRegI src1, gRegI src2, gRegI src3, pReg pr1, pReg pr2 ) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+1;
    src1   : REG(read);
    src2   : REG(read);
    src3   : REG(read)+1;
    IALU   : EXE; // One IALU operation  in 1st cycle
    IALU   : DET; // Two IALU operations in 2nd cycle
    IALU   : DET;
%}

pipe_class pr_pr_ICMP_gr_imm__gr_IALU_gr__gr_IALU_gr( gRegI dst, gRegI src1, immI_0 zero, gRegI src2, pr6_pReg pr6, pr7_pReg pr7 ) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+1;
    src1   : REG(read);
    src2   : REG(read)+1;
    IALU   : EXE; // One IALU operation  in 1st cycle
    IALU   : DET; // Two IALU operations in 2nd cycle
    IALU   : DET;
%}

pipe_class pr_pr_ICMP_gr_imm__gr_IALU_gr_gr__gr_IALU_gr( gRegI dst, gRegI src1, immI_0 zero, gRegI src2, gRegI src3, pr6_pReg pr6, pr7_pReg pr7 ) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+1;
    src1   : REG(read);
    src2   : REG(read)+1;
    src3   : REG(read)+1;
    IALU   : EXE; // One IALU operation  in 1st cycle
    IALU   : DET; // Two IALU operations in 2nd cycle
    IALU   : DET;
%}

pipe_class pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_imm(gRegI dst, gRegI src, pr6_pReg pr6, pr7_pReg pr7 ) %{
    multiple_bundles; instruction_count(2);
    dst    : EXE(write)+1;
    src    : REG(read);
    IALU   : EXE; // One IALU operation  in 1st cycle
    IALU   : DET; // Two IALU operations in 2nd cycle
    IALU   : DET;
%}

// // (pReg) ICMP pReg, pReg = gReg, imm: 1 cycle latency
// pipe_class pr_pr_ICMP_gr_imm(pReg dst, gRegI src1, immI8 src2) %{
//     single_instruction;
//     dst    : EXE(write);
//     src1   : REG(read);
//     IALU   : EXE;
// %}

// (pReg) ICMP pReg, pReg = gReg, imm: 1 cycle latency
pipe_class pr_pr_ICMP_gr_imm__BR_pr(cmpOp cmp, gRegI src1, immI8 src2, label labl) %{
    instruction_count(2);
    src1   : REG(read);
    IALU   : EXE;
    B      : EXE;
%}

// (pReg) ISHF gReg = gReg, imm6 : 1 cycle latency
pipe_class gr_ISHF_gr_imm(gRegI dst, gRegI src1, immI_1to64 src2) %{
    single_instruction;
    dst    : EXE(write);
    src1   : REG(read);
    I      : EXE;
    IALU   : EXE;
%}

// (pReg) MMSHF gReg = gReg, gReg : 2 cycle latency
pipe_class gr_MMSHF_gr_gr(gRegI dst, gRegI src1, gRegI src2) %{
    single_instruction;
    dst    : EXE(write)+1;
    src1   : REG(read);
    src2   : REG(read);
    I      : EXE;
    IALU   : EXE;
%}

// NOP (Integer)
pipe_class NOP_A() %{
    single_instruction;
    IALU   : EXE;
%}
pipe_class  pipe_native_call(method meth, inline_cache_gRegP gr, call_bRegP br, Lsave_RP_gRegP Lsave_RP, gpRegP gp, gr2_gRegP gr2, gr3_gRegP gr3, Lsave_GP_gRegP Lsave_GP) %{
    instruction_count(2); multiple_bundles; force_serialization;
    gr      : EXE(write)+1;
    gr      : REG(read)+1;
    gr2     : EXE(write)+1;
    gr2     : EXE(read) +2;
    gr3     : EXE(write)+1;
    gr3     : EXE(read) +2;
    br      : EXE(write)+2;
    gr2     : EXE(write)+3;
    gr2     : EXE(read) +4;
    X       : DET;  // really EXE+1
    X       : DET;  // really EXE+1
    M       : DET;  // really EXE+1
    I       : WRB;  // really EXE+2
    B       : WRB;  // really EXE+2
%}

pipe_class  pipe_runtime_call(method meth, inline_cache_gRegP gr, call_bRegP br, Lsave_RP_gRegP Lsave_RP, gpRegP gp, gr2_gRegP gr2, gr3_gRegP gr3, Lsave_GP_gRegP Lsave_GP) %{
    instruction_count(2); multiple_bundles; force_serialization;
    gr      : EXE(write)+1;
    gr      : REG(read)+1;
    gr2     : EXE(write)+1;
    gr2     : EXE(read) +2;
    gr3     : EXE(write)+1;
    gr3     : EXE(read) +2;
    br      : EXE(write)+2;
    gr2     : EXE(write)+3;
    gr2     : EXE(read) +4;
    X       : DET;  // really EXE+1
    X       : DET;  // really EXE+1
    M       : DET;  // really EXE+1
    I       : WRB;  // really EXE+2
    B       : WRB;  // really EXE+2
%}

pipe_class  pipeline_simple_call(method meth, inline_cache_gRegP gr, call_bRegP br, Lsave_RP_gRegP save_rp, gpRegP gp) %{
    instruction_count(2); multiple_bundles;
    gr      : EXE(write);
    gr      : REG(read)+1;
    br      : EXE(write);
    X       : EXE;
    I       : DET;  // really EXE+1
    IALU    : DET;  // really EXE+1
    B       : DET;  // really EXE+1
%}

pipe_class  pipeline_java_static_call(method meth, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp_gr) %{
    instruction_count(2); multiple_bundles;
    save_rp_gr : EXE(write);
    target_gr  : EXE(write)+1;
    target_gr  : REG(write)+2;
    target_br  : EXE(write)+2;
    target_br  : EXE(read) +2;
    I          : EXE;
    X          : DET;  // really EXE+1
    I          : WRB;  // really EXE+2
    B          : WRB;  // really EXE+2
%}

pipe_class  pipeline_compiled_call(method meth, interpreter_method_oop_regP oop_gr, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp_gr) %{
    instruction_count(2); multiple_bundles;
    oop_gr     : REG(read);
    target_gr  : EXE(write);
    save_rp_gr : EXE(write)+1;
    target_br  : EXE(write)+2;
    I          : EXE;
    M          : DET;  // really EXE+1
    I          : DET;  // really EXE+1
    I          : WRB;  // really EXE+2
    B          : WRB;  // really EXE+2
%}

pipe_class  pipeline_interpreter_call(method meth, o0RegP arg0, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp) %{
    instruction_count(2); multiple_bundles;
    arg0      : EXE(write);
    save_rp   : EXE(write);
    target_gr : EXE(write)+1;
    target_gr : REG(read) +2;
    target_br : EXE(write)+2;
    I         : EXE;
    I         : EXE;
    X         : DET;  // really EXE+1
    I         : WRB;  // really EXE+2
    B         : WRB;  // really EXE+2
%}

pipe_class  pipeline_rethrow_exception() %{
    instruction_count(2); multiple_bundles;
//  m       : EXE(write);
//  br      : EXE(write)+1;
    X       : EXE;
    I       : DET;  // really EXE+1
    B       : DET;  // really EXE+1
%}

pipe_class  pipeline_partial_subtype_check(g8retRegI index, o0RegP sub, o1RegP super, inline_cache_gRegP gr, call_bRegP br) %{
    instruction_count(2); multiple_bundles;
    gr      : EXE(write);
    gr      : REG(read)+1;
    br      : EXE(write);
    X       : EXE;
    I       : DET;  // really EXE+1
    IALU    : DET;  // really EXE+1
    B       : DET;  // really EXE+1
%}

pipe_class  pipeline_java_dynamic_call(method meth, inline_cache_gRegP inline_cache_gr, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp_gr) %{
    instruction_count(2); multiple_bundles;
    save_rp_gr      : EXE(write);
    inline_cache_gr : EXE(write)+1;
    target_gr       : EXE(write)+2;
    target_gr       : REG(write)+3;
    target_br       : EXE(write)+3;
    I               : EXE;
    X               : DET; // really EXE+1
    X               : WRB; // really EXE+2
%}

pipe_class pipeline_tail_call(gRegP jump_gr, inline_cache_gRegP method_oop, call_bRegP br) %{
    instruction_count(2);
    jump_gr : REG(read);
    br      : EXE(write);
    I       : EXE;
    IALU    : EXE;
    B       : EXE;
%}
    
// pipe_class pipeline_tail_jump(gRegP jump_gr, inline_cache_gRegP ex_oop, call_bRegP br) %{
pipe_class pipeline_tail_jump(gRegP jump_gr, retRegP ex_oop, call_bRegP br) %{
    instruction_count(2);
    jump_gr : REG(read);
    br      : EXE(write);
    I       : EXE;
    IALU    : EXE;
    B       : EXE;
%}
    
// (pReg) XMA fReg = fReg, fReg : 7 cycle latency
pipe_class fr_XMA_fr_fr(fRegD dst, fRegD src1, fRegD src2) %{
    single_instruction;
    dst    : EXE(write)+6;
    src1   : REG(read);
    src2   : REG(read);
    F      : EXE;
%}

pipe_class long_fp_op() %{
    instruction_count(1);
    force_serialization;
    fixed_latency(50);
    F      : EXE;
%}

pipe_class long_memory_op() %{
    instruction_count(1);
    force_serialization;
    fixed_latency(11);
    M      : EXE;
    IALU   : EXE;
%}

// Check-cast
pipe_class checktype( gRegP klass, gRegP con, gRegP temp1, gRegP temp2, gRegP temp3, gRegP temp4 ) %{
    klass : EXE(read);
    con   : EXE(read);
    temp1 : EXE(write);
    temp1 : EXE(read)+1;
    temp1 : EXE(write)+3;
    temp1 : EXE(read)+3;
    temp2 : EXE(write);
    temp2 : EXE(read)+1;
    temp2 : EXE(write)+3;
    temp1 : EXE(read)+4;
    temp3 : EXE(write)+4;
    temp3 : EXE(write)+5;
    temp3 : EXE(read)+5;
    IALU  : EXE(1);
    IALU  : EXE(1);
//  M     : EXE(1)+1;
//  M     : EXE(1)+1;
//  IALU  : EXE(1)+3;
//  IALU  : EXE(1)+4;
//  B     : EXE(1)+4;
%}

// FMISC (fabs) reg = reg operation
pipe_class fr_FMISC_fr(fRegD dst, fRegD src) %{
    single_instruction;
    dst    : EXE(write)+4;	// 5 cycle latency
    src    : REG(read);
    F      : EXE;
%}

// FMISC (frcpa) reg = reg, reg operation
pipe_class fr_FMISC_fr_fr(fRegD dst, fRegD src1, fRegD src2) %{
    single_instruction;
    dst    : EXE(write)+4;	// 5 cycle latency
    src1   : REG(read);
    src2   : REG(read);
    F      : EXE;
%}

// FRFR
pipe_class gr_FRFR_fr(fRegD dst, gRegI src) %{
    single_instruction;
    dst    : EXE(write)+8;	// 9 cycle latency
    src    : REG(read);
    M      : EXE;
%}

pipe_class gr_FRFR_fr_pr(fRegD dst, gRegI src, pReg qp) %{
    single_instruction;
    dst    : EXE(write)+8;	// 9 cycle latency
    src    : REG(read);
    qp     : REG(read);
    M      : EXE;
%}

// TOFR
pipe_class fr_TOFR_gr(fRegD dst, gRegI src) %{
    single_instruction;
    dst    : EXE(write)+8;	// 9 cycle latency
    src    : REG(read);
    M      : EXE;
%}

// ILOG (and, andcm, or, xor) reg = reg-reg operation
pipe_class gr_ILOG_gr_gr(gRegI dst, gRegI src1, gRegI src2) %{
    single_instruction;
    dst    : EXE(write);
    src1   : REG(read);
    src2   : REG(read);
    IALU   : EXE;
%}

// IALU (and, andcm, or, xor) reg = reg-imm operation
pipe_class gr_ILOG_gr_imm(gRegI dst, gRegI src1, immI src2) %{
    single_instruction;
    dst    : EXE(write);
    src1   : REG(read);
    IALU   : EXE;
%}

// IALU (and, andcm, or, xor) reg = reg operation
pipe_class gr_ILOG_gr(gRegI dst, gRegI src) %{
    single_instruction;
    dst    : EXE(write);
    src    : REG(read);
    IALU   : EXE;
%}

// LD (ld) reg = mem operation (assumes cache hit)
pipe_class gr_LD_mem(gRegI dst, memory mem) %{
    single_instruction;
    dst    : EXE(write)+1;	// 2 cycle latency
    mem    : WLD(read);	        // address read is required early
    M      : EXE;
%}

// LD (ld) reg = mem, mask operation (assumes cache hit)
pipe_class gr_LD_mem_imm(gRegI dst, memory mem, immI8 bytemask) %{
    single_instruction;
    dst    : EXE(write)+1;	// 2 cycle latency
    mem    : WLD(read);	        // address read is required early
    M      : EXE;
%}

// LFETCH (lfetch) mem operation (prefetch)
pipe_class LFETCH_mem(memory mem) %{
    single_instruction;
    mem    : WLD(read);	        // address read is required early
    M      : EXE;
%}

// LONG (movl) reg = imm
pipe_class gr_LONG_I_imm(gRegI dst, immI src) %{
    single_instruction;
    dst    : EXE(write);
    X      : EXE;
%}

pipe_class gr_LONG_I_pr__gr_LONG_I_pr(gRegI dst, pReg p1, pReg p2) %{
    instruction_count(2);
    dst    : EXE(write);
    p1     : REG(read);
    p2     : REG(read);
    X      : EXE;
%}

// ST (st) mem = reg operation
pipe_class mem_ST_gr(memory mem, gRegI src) %{
    single_instruction;
    mem    : WLD(read);
    src    : REG(read);
    M      : EXE;
%}

// ST (st) mem = imm0 operation
pipe_class mem_ST_imm(memory mem, immI src) %{
    single_instruction;
    mem    : WLD(read);
    M      : EXE;
%}

// STF (stff, stfd) mem = reg
pipe_class mem_STF_fr(memory mem, fRegD src) %{
    single_instruction;
    mem    : WLD(read);
    src    : REG(read);
    M      : EXE;
%}

// SYST_M
pipe_class SYST_M() %{
    single_instruction;
    M      : EXE;
%}

// XTD (zxt, sxt) reg = reg operation
pipe_class gr_XTD_gr(gRegI dst, gRegI src) %{
    single_instruction;
    dst    : EXE(write);
    src    : REG(read);
    IALU   : EXE;
%}

pipe_class gr_XTD_gr_pr(gRegI dst, gRegI src, pReg qp) %{
    single_instruction;
    dst    : EXE(write);
    src    : REG(read);
    qp     : REG(read);
    IALU   : EXE;
%}

pipe_class empty() %{
    IALU   : EXE;     // Need something
%}

pipe_class empty_fp(fRegD src) %{
    src    : REG(read);
%}

pipe_class empty_ptr(gRegP src) %{
    src    : REG(read);
%}

pipe_class convD2I_pipe(gRegI dst, fRegD src, fr6_fRegD tmp1, gr30_gRegL tmp2, pr6_pReg p6, pr7_pReg p7, pr8_pReg p8, pr9_pReg p9, pr10_pReg p10) %{
    src    : REG(read);
    dst    : EXE(write)+20;
    F      : EXE;
%}

define %{
   MachNop = NOP_A; 
%}

%}

//----------INSTRUCTIONS-------------------------------------------------------

instruct box_handle( gRegP dst, stackSlotP src) %{
  match( Set dst (Box src) );
  ins_cost(DEFAULT_COST);
  format %{ "ADDS   $dst=$src\t// box node" %}
  ins_encode( enc_box_handle( dst ) );
  ins_pipe(gr_IALU_gr_imm);
%}


//------------Special Stack Slot instructions - no match rules-----------------
instruct stkI_to_fRegF(fRegF dst, stackSlotI src) %{
  // No match rule to avoid chain rule match.
  effect(DEF dst, USE src);
  ins_cost(FP_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n"
          "\tLDFS   $dst=[GR29]\t! stk -> fRegF" %}
  ins_encode( emit_ldfs_stack( dst, src ) );
  ins_pipe(fr_LDF_mem);
%}

instruct stkL_to_fRegD(fRegD dst, stackSlotL src) %{
  // No match rule to avoid chain rule match.
  effect(DEF dst, USE src);
  ins_cost(FP_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n"
          "\tLDFD   $dst=[GR29]\t// stk -> fRegD" %}
  ins_encode( emit_ldfd_stack( dst, src ) );
  ins_pipe(fr_LDF_mem);
%}

instruct fRegF_to_stkI(stackSlotI dst, fRegF src) %{
  // No match rule to avoid chain rule match.
  effect(DEF dst, USE src);
  ins_cost(FP_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n"
          "\tSTFS   [GR29]=$src\t// fRegF -> stkI" %}
  ins_encode( emit_stfs_stack( dst, src ) );
  ins_pipe(mem_STF_fr);
%}

instruct fRegD_to_stkL(stackSlotL dst, fRegD src) %{
  // No match rule to avoid chain rule match.
  effect(DEF dst, USE src);
  ins_cost(FP_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n"
          "\tSTFD   [GR29]=$src\t// fRegD -> stkL" %}
  ins_encode( emit_stfd_stack( dst, src ) );
  ins_pipe(mem_STF_fr);
%}

//---------- Chain stack slots between similar types --------

// Load integer from stack slot
instruct stkI_to_regI( gRegI dst, stackSlotI src) %{
  match(Set dst src);
  ins_cost(INT_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n"
          "\tLD4    $dst=[GR29]\t// stk -> gr (int)" %}
  ins_encode( emit_ld4_stack( dst, src ) );
  ins_pipe(gr_LD_mem);
%}

// Store integer to stack slot
instruct regI_to_stkI(stackSlotI dst, gRegI src) %{
  match(Set dst src);
  effect(DEF dst, USE src);
  ins_cost(INT_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n"
          "\tST4    [GR29]=$src\t// gr->stk (int)" %}
  ins_encode( emit_st4_stack( dst, src ) );
  ins_pipe(mem_ST_gr);
%}

// Load long from stack slot
instruct stkL_to_regL( gRegL dst, stackSlotL src) %{
  match(Set dst src);
  ins_cost(INT_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n"
          "\tLD8    $dst=[GR29]\t// stk -> gr (long)" %}
  ins_encode( emit_ld8_stack( dst, src ) );
  ins_pipe(gr_LD_mem);
%}

// Store long to stack slot
instruct regL_to_stkL(stackSlotL dst, gRegL src) %{
  match(Set dst src);
  ins_cost(INT_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n"
          "\tST8    [GR29]=$src\t// gr -> stk (long)" %}
  ins_encode( emit_st8_stack( dst, src ) );
  ins_pipe(mem_ST_gr);
%}

// Load pointer from stack slot, 64-bit encoding
instruct stkP_to_regP( gRegP dst, stackSlotP src ) %{
  match(Set dst src);
  ins_cost(MEMORY_REF_COST);
  ins_cost(INT_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n"
          "\tLD8    $dst=[GR29]\t// stk -> gr (ptr)" %}
  ins_encode( emit_ld8_stack( dst, src ) );
  ins_pipe(gr_LD_mem);
%}

// Store pointer to stack slot
instruct regP_to_stkP(stackSlotP dst, gRegP src) %{
  match(Set dst src);
  ins_cost(INT_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n"
          "\tST8    [GR29]=$src\t// gr -> stk (ptr)" %}
  ins_encode( emit_st8_stack( dst, src ) );
  ins_pipe(mem_ST_gr);
%}

//------------Special Nop instructions for bundling - no match rules-----------
// Nop using the I0 functional unit
instruct Nop_I0() %{
  ins_cost(0);

  format %{ "NOP    // I Pipeline" %}
  ins_encode( emit_nopi() );
  ins_pipe(ialu_nop_I0);
%}

// Nop using the I1 functional unit
instruct Nop_I1() %{
  ins_cost(0);

  format %{ "NOP    // I Pipeline" %}
  ins_encode( emit_nopi() );
  ins_pipe(ialu_nop_I1);
%}

// Nop using the M0 functional unit
instruct Nop_M0() %{
  ins_cost(0);

  format %{ "NOP    // M Pipeline" %}
  ins_encode( emit_nopm() );
  ins_pipe(ialu_nop_M0);
%}

// Nop using the M1 functional unit
instruct Nop_M1() %{
  ins_cost(0);

  format %{ "NOP    // M Pipeline" %}
  ins_encode( emit_nopm() );
  ins_pipe(ialu_nop_M1);
%}

// Nop using the B0 functional unit
instruct Nop_B0() %{
  ins_cost(0);

  format %{ "NOP    // B Pipeline" %}
  ins_encode( emit_nopb() );
  ins_pipe(ialu_nop_B0);
%}

// Nop using the B1 functional unit
instruct Nop_B1() %{
  ins_cost(0);

  format %{ "NOP    // B Pipeline" %}
  ins_encode( emit_nopb() );
  ins_pipe(ialu_nop_B1);
%}

// Nop using the B2 functional unit
instruct Nop_B2() %{
  ins_cost(0);

  format %{ "NOP    // B Pipeline" %}
  ins_encode( emit_nopb() );
  ins_pipe(ialu_nop_B2);
%}

// Nop using the F0 functional unit
instruct Nop_F0() %{
  ins_cost(0);

  format %{ "NOP    // F Pipeline" %}
  ins_encode( emit_nopf() );
  ins_pipe(ialu_nop_F0);
%}

// Nop using the F1 functional unit
instruct Nop_F1() %{
  ins_cost(0);

  format %{ "NOP    // F Pipeline" %}
  ins_encode( emit_nopf() );
  ins_pipe(ialu_nop_F1);
%}

//----------Load/Store/Move Instructions---------------------------------------

//----------Load Instructions--------------------------------------------------
// Load Byte (8bit signed)

// KLUDGE
//   instruct loadB_1(gRegI dst, indirect mem) %{
//     format %{ "LD1     $dst=$mem\t// byte" %}
//     effect(DEF dst, USE mem);
// 
//     ins_encode( emit_ld1( dst, mem, PR0 ) );
//     ins_pipe(gr_LD_mem);
//   %}
//     
//   instruct loadB_2(gRegI dst, gRegI src) %{
//     format %{ "SXT1    $dst=$src\t// byte->int" %}
//     effect(DEF dst, USE src);
//     
//     ins_encode( emit_sxt1_reg( dst, src, PR0 ) );
//     ins_pipe(gr_XTD_gr);
//   %}
// 
// instruct loadB(gRegI dst, indirect mem) %{
//   match(Set dst (LoadB mem));
//   ins_cost(INT_MEMORY_READ_COST + DEFAULT_COST);
// 
//   expand %{
//     gRegI tmp;
//     loadB_1(tmp, mem);
//     loadB_2(dst, tmp);
//   %}
// %}

instruct loadB(gRegI dst, indirect mem) %{
  match(Set dst (LoadB mem));
  ins_cost(INT_MEMORY_READ_COST + DEFAULT_COST);
  format %{ "LD1     $dst=$mem\t// byte\n\t"
            "SXT1    $dst=$dst\t// byte->int" %}
  ins_encode( emit_ld1( dst, mem, PR0 ), emit_sxt1_reg( dst, dst, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Byte (8bit UNsigned)
instruct loadUB(gRegI dst, memory mem, immI_255 bytemask) %{
  match(Set dst (AndI (LoadB mem) bytemask));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD1    $dst=$mem" %}
  ins_encode( emit_ld1( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Char (16 bit unsigned)
instruct loadC(gRegI dst, memory mem) %{
  match(Set dst (LoadC mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD2    $dst=$mem" %}
  ins_encode( emit_ld2( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Integer (32 bit signed)
instruct loadI(gRegI dst, memory mem) %{
  match(Set dst (LoadI mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD4    $dst=$mem" %}
  ins_encode( emit_ld4( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Long
instruct loadL(gRegL dst, memory mem) %{
  match(Set dst (LoadL mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8    $dst=$mem\t// long" %}
  ins_encode( emit_ld8( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Long
instruct loadL_unaligned(gRegL dst, memory mem) %{
  match(Set dst (LoadL_unaligned mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8    $dst=$mem\t// unaligned long" %}
  ins_encode( emit_ld8( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Range
instruct loadRange(gRegI dst, memory mem) %{
  match(Set dst (LoadRange mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD4    $dst=$mem\t// range" %}
  ins_encode( emit_ld4( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Pointer
instruct loadP(gRegP dst, memory mem) %{
  match(Set dst (LoadP mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8    $dst=$mem\t// ptr" %}
  ins_encode( emit_ld8( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Klass Pointer
instruct loadKlass(gRegP dst, memory mem) %{
  match(Set dst (LoadKlass mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8    $dst=$mem\t// class" %}
  ins_encode( emit_ld8( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Short (16 bit signed)

// KLUDGE
//   instruct loadS_1(gRegI dst, indirect mem) %{
//     format %{ "LD2     $dst=$mem\t// short" %}
//     effect(DEF dst, USE mem);
// 
//     ins_encode( emit_ld2( dst, mem, PR0 ) );
//     ins_pipe(gr_LD_mem);
//   %}
// 
//   instruct loadS_2(gRegI dst, gRegI src) %{
//     format %{ "SXT2    $dst=$src\t// short" %}
//     effect(DEF dst, USE src);
// 
//     ins_encode( emit_sxt2_reg( dst, src, PR0 ) );
//     ins_pipe(gr_XTD_gr);
//   %}
// 
// instruct loadS(gRegI dst, indirect mem) %{
//   match(Set dst (LoadS mem));
//   ins_cost(INT_MEMORY_READ_COST + DEFAULT_COST);
// 
//   expand %{
//     gRegI tmp;
//     loadS_1(tmp, mem);
//     loadS_2(dst, tmp);
//   %}
// %}

instruct loadS(gRegI dst, indirect mem) %{
  match(Set dst (LoadS mem));
  ins_cost(INT_MEMORY_READ_COST + DEFAULT_COST);
  format %{ "LD2     $dst=$mem\t// short\n\t"
            "SXT2    $dst=$dst\t\t// short" %}
  ins_encode( emit_ld2( dst, mem, PR0 ), emit_sxt2_reg( dst, dst, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// Load Double
instruct loadD(fRegD dst, memory mem) %{
    match(Set dst (LoadD mem));
    ins_cost(FP_MEMORY_READ_COST);

    format %{ "LDFD    $dst=$mem" %}
    ins_encode( emit_ldfd( dst, mem, PR0 ) );
    ins_pipe(fr_LDF_mem);
%}

// Load Double Unaligned
instruct loadD_unaligned(fRegD dst, memory mem) %{
    match(Set dst (LoadD_unaligned mem));
    ins_cost(FP_MEMORY_READ_COST);

    format %{ "LDFD    $dst=$mem\t// unaligned" %}
    ins_encode( emit_ldfd( dst, mem, PR0 ) );
    ins_pipe(fr_LDF_mem);
%}

// Load Float
instruct loadF(fRegF dst, memory mem) %{
  match(Set dst (LoadF mem));
  ins_cost(FP_MEMORY_READ_COST);

  format %{ "LDFS   $dst=$mem" %}
  ins_encode( emit_ldfs( dst, mem, PR0 ) );
  ins_pipe(fr_LDF_mem);
%}

// Load Constant
instruct loadConI( gRegI dst, immI src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST * 2);
  format %{ "MOVL   $dst=$src" %}
  ins_encode( emit_movl( dst, src, PR0 ) );
  ins_pipe( gr_LONG_I_imm );
%}

instruct loadConI22( g23RegI dst, immI22 src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST*3/2);
  format %{ "MOVS    $dst=$src\t// 22 bit" %}
  ins_encode( emit_mov_imm22( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct loadConI14( gRegI dst, immI14 src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST);
  format %{ "MOV    $dst=$src\t\t// 14 bit" %}
  ins_encode( emit_mov_imm14( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct loadConP(gRegP dst, immP src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST * 2);
  format %{ "MOVL   $dst=$src\t// ptr" %}
  ins_encode( emit_mova( dst, src ) );
  ins_pipe(gr_LONG_I_imm);
%}

instruct loadConP0(gRegP dst, immP0 src) %{
  match(Set dst src);
  format %{ "MOV    $dst=$src\t\t// null ptr" %}
  ins_encode( emit_mov_imm14( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

// Load return address of the following native call into a register
instruct loadConPC(gRegP dst, method offset_to_call_return) %{
  match(Set dst (LoadPC));
  ins_cost(DEFAULT_COST * 2);
  effect(USE offset_to_call_return);
  format %{ "MOVL   $dst=R_PC+$offset_to_call_return\t! Load PC" %}
  ins_encode( LdImmPc(dst, offset_to_call_return, PR0 ) );
  ins_pipe(gr_LONG_I_imm);
%}

instruct loadConL( gRegL dst, immL src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST * 2);
  
  format %{ "MOVL   $dst=$src\t// long" %}
  ins_encode( emit_movl( dst, src, PR0 ) );
  ins_pipe(gr_LONG_I_imm);
%}

instruct loadConL22( g23RegL dst, immL22 src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST*3/2);

  format %{ "MOV    $dst=$src\t// long, 22 bits" %}
  ins_encode( emit_mov_imm22( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct loadConL14( gRegL dst, immL14 src) %{
  match(Set dst src);
  ins_cost(DEFAULT_COST);

  format %{ "MOV    $dst=$src\t\t// long" %}
  ins_encode( emit_mov_imm14( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct loadConF0(fRegF dst, immF_0 src) %{
  match(Set dst src);
  format %{ "FMOV   $dst=FR0\t\t// double" %}
  ins_encode( emit_movf( dst, FR0, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

instruct loadConF1(fRegF dst, immF_1 src) %{
  match(Set dst src);
  format %{ "FMOV   $dst=FR1\t\t// double" %}
  ins_encode( emit_movf( dst, FR1, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

instruct loadConF2(fRegF dst, immF_2 src) %{
  match(Set dst src);
  format %{ "FADDF  $dst=FR1,FR1" %}
  ins_encode( emit_addF_reg_reg( dst, FR1, FR1, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

  instruct loadConF_1(gRegI dst, immF src) %{
    format %{ "MOVL   $dst=$src\t// float constant" %}
    effect(DEF dst, USE src);

    ins_encode( emit_movl_float( dst, src, PR0 ) );
    ins_pipe(gr_LONG_I_imm);
  %}

  instruct loadConF_2(fRegF dst, gRegI src) %{
    format %{ "SETFS  $dst=$src" %}
    effect(DEF dst, USE src);

    ins_encode( emit_setfF_reg( dst, src, PR0 ) );
    ins_pipe(fr_TOFR_gr);
  %}

  instruct loadConF_3(fRegF dst, fRegF src) %{
    format %{ "FNORM  $dst=$src" %}
    effect(DEF dst, USE src);

    ins_encode( emit_fnorm_reg( dst, src, PR0 ) );
    ins_pipe(fr_TOFR_gr);
  %}

instruct loadConF(fRegF dst, immF_not_denorm src) %{
  match(Set dst src);
  ins_cost(FP_MEMORY_READ_COST + DEFAULT_COST);
  effect(USE src);

  expand %{
    gRegI tmp;
    loadConF_1(tmp, src);
    loadConF_2(dst, tmp);
  %}
%}

instruct loadConF_denorm(fRegF dst, immF src) %{
  match(Set dst src);
  ins_cost(FP_OP_COST + FP_MEMORY_READ_COST + DEFAULT_COST);
  effect(USE src);

  expand %{
    gRegI tmp;
    loadConF_1(tmp, src);
    loadConF_2(dst, tmp);
    loadConF_3(dst, dst);
  %}
%}

instruct loadConD0(fRegD dst, immD_0 src) %{
  match(Set dst src);
  format %{ "FMOV   $dst=FR0\t\t// double" %}
  ins_encode( emit_movf( dst, FR0, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

instruct loadConD1(fRegD dst, immD_1 src) %{
  match(Set dst src);
  format %{ "FMOV   $dst=FR1\t\t// double" %}
  ins_encode( emit_movf( dst, FR1, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

instruct loadConD2(fRegD dst, immD_2 src) %{
  match(Set dst src);
  format %{ "FADDD  $dst=FR1,FR1" %}
  ins_encode( emit_addD_reg_reg( dst, FR1, FR1, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

  instruct loadConD_1(gRegL dst, immD src) %{
    format %{ "MOVL   $dst=$src\t\t// double constant" %}
    effect(DEF dst, USE src);
    ins_encode( emit_movl_double( dst, src, PR0 ) );
    ins_pipe(gr_LONG_I_imm);
  %}

  instruct loadConD_2(fRegD dst, gRegL src) %{
    format %{ "SETFD  $dst=$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_setfD_reg( dst, src, PR0 ) );
    ins_pipe(fr_TOFR_gr);
  %}

instruct loadConD(fRegD dst, immD src) %{
  match(Set dst src);
  ins_cost(FP_MEMORY_READ_COST + DEFAULT_COST);
  effect(USE src);

  expand %{
    gRegL tmp;
    loadConD_1(tmp, src);
    loadConD_2(dst, tmp);
  %}
%}

// Prefetch.  Safe to execute with invalid address.
instruct prefetch( memory mem ) %{
  match(Prefetch mem);
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "PREFETCH $mem\t// Prefetch write-many (and read)" %}
  ins_encode( emit_lfetch( mem, PR0 ) );
  ins_pipe(LFETCH_mem);
%}

//----------Store Instructions-------------------------------------------------
// Store Byte
instruct storeB(memory mem, gRegI src) %{
  match(Set mem (StoreB mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST1    $mem=$src\t// byte" %}
  ins_encode( emit_st1( mem, src, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

instruct storeB0(memory mem, immI_0 src) %{
  match(Set mem (StoreB mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST1    $mem=GR0\t// byte" %}
  ins_encode( emit_st1_gr0( mem, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

instruct storeCM0(memory mem, immI_0 src) %{
  match(Set mem (StoreCM mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST1.REL $mem=GR0\t// CMS card-mark byte 0" %}
  ins_encode( emit_st1_gr0_rel( mem, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// Store Char/Short
instruct storeC(memory mem, gRegI src) %{
  match(Set mem (StoreC mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST2    $mem=$src\t// char" %}
  ins_encode( emit_st2( mem, src, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

instruct storeC0(memory mem, immI_0 src) %{
  match(Set mem (StoreC mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST2    $mem=GR0\t// ptr" %}
  ins_encode( emit_st2_gr0( mem, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// Store Integer
instruct storeI(memory mem, gRegI src) %{
  match(Set mem (StoreI mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST4    $mem=$src" %}
  ins_encode( emit_st4( mem, src, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

instruct storeI0(memory mem, immI_0 src) %{
  match(Set mem (StoreI mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST4    $mem=GR0" %}
  ins_encode( emit_st4_gr0( mem, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// Store Long
instruct storeL(memory mem, gRegL src) %{
  match(Set mem (StoreL mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST8    $mem=$src\t// long" %}
  ins_encode( emit_st8( mem, src, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// Store Long
instruct storeL0(memory mem, immL_0 src) %{
  match(Set mem (StoreL mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST8    $mem=GR0\t// long" %}
  ins_encode( emit_st8_gr0( mem, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// // Store Integer from float register (used after fstoi)
// instruct storeI_Freg(memory mem, fRegF src) %{
//   match(Set mem (StoreI mem src));
//   ins_cost(INT_MEMORY_READ_COST);
// 
//   format %{ "STW    $mem=$src ; after fstoi/fdtoi" %}
//   // Primary opcode is manual's op3 & secondary is bits 31-30
//   opcode(Assembler::stf_op3, Assembler::ldst_op); 
//   ins_encode( form3_mem_reg( mem, src ) );
//   ins_pipe(fstoreF_mem_reg);
// %}

// Store Pointer
instruct storeP(memory mem, sp_or_gRegP src) %{
  match(Set mem (StoreP mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST8    $mem=$src\t// ptr" %}
  ins_encode( emit_st8( mem, src, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// Store Pointer
instruct storeP0(memory mem, immP0 src) %{
  match(Set mem (StoreP mem src));
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST8    $mem=GR0\t// ptr" %}
  ins_encode( emit_st8_gr0( mem, PR0 ) );
  ins_pipe(mem_ST_gr);
%}

// Store Double
instruct storeD(memory mem, fRegD src) %{
  match(Set mem (StoreD mem src));
  ins_cost(FP_MEMORY_WRITE_COST);

  format %{ "STFD   $mem=$src\t\t// double" %}
  ins_encode( emit_stfd( mem, src, PR0 ) );
  ins_pipe(mem_STF_fr);
%}

instruct storeD0(memory mem, immD_0 src) %{
  match(Set mem (StoreD mem src));
  ins_cost(FP_MEMORY_WRITE_COST);

  format %{ "STFD   $mem=FR0\t\t// double" %}
  ins_encode( emit_stfd( mem, FR0, PR0 ) );
  ins_pipe(mem_STF_fr);
%}

instruct storeD1(memory mem, immD_1 src) %{
  match(Set mem (StoreD mem src));
  ins_cost(FP_MEMORY_WRITE_COST);

  format %{ "STFD   $mem=FR1\t\t// double" %}
  ins_encode( emit_stfd( mem, FR1, PR0 ) );
  ins_pipe(mem_STF_fr);
%}

// Store Float 
instruct storeF(memory mem, fRegF src) %{
  match(Set mem (StoreF mem src));
  ins_cost(FP_MEMORY_WRITE_COST);

  format %{ "STFS   $mem=$src\t// single" %}
  ins_encode( emit_stfs( mem, src, PR0 ) );
  ins_pipe(mem_STF_fr);
%}

instruct storeF0(memory mem, immF_0 src) %{
  match(Set mem (StoreF mem src));
  ins_cost(FP_MEMORY_WRITE_COST);

  format %{ "STFS   $mem=FR0\t// single" %}
  ins_encode( emit_stfs( mem, FR0, PR0 ) );
  ins_pipe(mem_STF_fr);
%}

instruct storeF1(memory mem, immF_1 src) %{
  match(Set mem (StoreF mem src));
  ins_cost(FP_MEMORY_WRITE_COST);

  format %{ "STFS   $mem=FR1\t// single" %}
  ins_encode( emit_stfs( mem, FR1, PR0 ) );
  ins_pipe(mem_STF_fr);
%}

//----------Mem-Mem Instructions-----------------------------------------------
// The incredibly rare memory to memory move.  These things exist because it
// saves another round through the allocator to patch 'em up here.  They are
// very rare, so can be somewhat slow.  At some point we will fix the
// allocator to reserve a spare stack slot for a temporary spill.  The
// expected encoding is something like "save register to reserved slot; load
// src location; store into dst location; restore register".

// // MemMove
// instruct memmove( memory dst, memory src) %{
//   match(MemMove dst src);
//  
//   ins_cost(DEFAULT_COST*3); 
//   format %{ "MEMMOVE $dst=$src" %}
//   ins_encode( memmove_encode( dst, src ) );
//   ins_pipe(memmove);
// %}

//----------MemBar Instructions-----------------------------------------------
// Memory barrier flavors

//instruct membar_acquire() %{
//  match(MemBarAcquire);
//  ins_cost(4 * INT_MEMORY_READ_COST);
//
//  format %{ "MF\t\t\t// MEMBAR-acquire" %}
//  ins_encode( emit_mf( PR0 ) );
//  ins_pipe(long_memory_op);
//%}
instruct membar_acquire(gr2_gRegP dst) %{
  match(MemBarAcquire);
  effect(KILL dst);
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8.ACQ GR2=[GR12_SP]\t// MEMBAR-acquire" %}
  ins_encode( emit_ld8_acq( GR2, GR12_SP, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

instruct membar_acquire_lock(gr2_gRegP dst) %{
  match(MemBarAcquire);
  predicate(Matcher::prior_fast_lock(n));
  effect(KILL dst);
  ins_cost(0);

  format %{ "MEMBAR-acquire (CAS in prior FastLock so empty encoding)" %}
  ins_encode( );
  ins_pipe(empty);
%}

instruct membar_release() %{
  match(MemBarRelease);
  ins_cost(INT_MEMORY_WRITE_COST);

  format %{ "ST8.REL [GR12_SP]=GR0\t// MEMBAR-release" %}
  ins_encode( emit_st8_rel( GR12_SP, GR0, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

instruct membar_release_lock() %{
  match(MemBarRelease);
  predicate(Matcher::post_fast_unlock(n));
  ins_cost(0);

  format %{ "MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)" %}
  ins_encode( );
  ins_pipe(empty);
%}

instruct membar_volatile() %{
  match(MemBarVolatile);
  ins_cost(4 * INT_MEMORY_READ_COST);

  format %{ "MF\t\t// MEMBAR-volatile" %}
  ins_encode( emit_mf( PR0 ) );
  ins_pipe(long_memory_op);
%}

instruct membar_CPUOrder() %{
  match(MemBarCPUOrder);
  ins_cost(0);

  format %{ "MEMBAR-CPUOrder (IA64 processors are self-consistent so empty encoding) " %}
  ins_encode( );
  ins_pipe(empty);
%}


//----------Register Move Instructions-----------------------------------------
instruct roundDouble_nop(fRegD dst) %{
  match(Set dst (RoundDouble dst));
  ins_cost(0);
  ins_encode( );
  ins_pipe(empty);
%}

instruct roundFloat_nop(fRegF dst) %{
  match(Set dst (RoundFloat dst));
  ins_cost(0);
  ins_encode( );
  ins_pipe(empty);
%}

// Cast Long to Pointer
instruct castL2P(gRegP dst, gRegL src) %{
  match(Set dst (CastL2P src));

  format %{ "MOV    $dst=$src\t// long->ptr" %}
  ins_encode( emit_mov_reg( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr);
%}

// Cast Pointer to Long
instruct castP2L(gRegL dst, gRegP src) %{
  match(Set dst (CastP2L src));

  format %{ "MOV    $dst=$src\t// ptr->long" %}
  ins_encode( emit_mov_reg( dst, src, PR0 ) );
  ins_pipe(gr_IALU_gr);
%}

instruct regD_to_stkD(stackSlotD dst, fRegD src) %{
  // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
  match(Set dst src);   // chain rule
  ins_cost(FP_MEMORY_WRITE_COST);
  format %{ "STFD   $dst=$src\t// fRegD -> stkD" %}
  ins_encode( emit_stfd_stack( dst, src ) );
  ins_pipe(mem_STF_fr);
%}

instruct regF_to_stkF(stackSlotF dst, fRegF src) %{
  // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
  match(Set dst src);   // chain rule
  ins_cost(FP_MEMORY_WRITE_COST);
  format %{ "STFS   $dst=$src\t// fRegS -> stkS" %}
  ins_encode( emit_stfs_stack( dst, src ) );
  ins_pipe(mem_STF_fr);
%}


//----------Conditional_store--------------------------------------------------
// Conditional-store of the updated heap-top.
// Used during allocation of the shared heap.

// LoadP-locked.  Same as a regular pointer load when used with a compare-swap
instruct loadPLocked(gRegP dst, memory mem) %{
  match(Set dst (LoadPLocked mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8   $dst=$mem,ACQUIRE\t// ptr" %}
  ins_encode( emit_ld8_acq( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// LoadL-locked.  Same as a regular long load when used with a compare-swap
instruct loadLLocked(gRegL dst, memory mem) %{
  match(Set dst (LoadLLocked mem));
  ins_cost(INT_MEMORY_READ_COST);

  format %{ "LD8   $dst=$mem,ACQUIRE\t// long" %}
  ins_encode( emit_ld8_acq( dst, mem, PR0 ) );
  ins_pipe(gr_LD_mem);
%}

// StoreP-conditional. Does a compare-and-swap, returns boolean for success
instruct storePConditional( gRegI dst, gRegP ptr, gRegP oldval, gRegP newval, gr30_gRegP tmp, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (StorePConditional ptr (Binary oldval newval)));
  effect( KILL tmp, KILL pr6, KILL pr7 );
  ins_cost(CALL_COST);

  format %{ "MOV       AR_CCV=$oldval\t// StorePConditional\n"
          "\tCMPXCHG8  GR30=[$ptr],$newval,Assembler::acquire\n"
          "\tCMP.EQ    PR6,PR7=GR30,$oldval\n"
          "\t(PR6) MOV dst=1\n"
          "\t(PR7) MOV dst=0" %}
  ins_encode( emit_cmpxchg8_bool(dst, ptr, oldval, newval, GR30, PR6, PR7) );
  ins_pipe( long_memory_op );
%}

// StoreL-conditional. Does a compare-and-swap, returns boolean for success
instruct storeLConditional( gRegI dst, gRegP ptr, gRegL oldval, gRegL newval, gr30_gRegL tmp, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (StoreLConditional ptr (Binary oldval newval)));
  effect( KILL tmp, KILL pr6, KILL pr7 );
  ins_cost(CALL_COST);

  format %{ "MOV       AR_CCV=$oldval\t// StorePConditional\n"
          "\tCMPXCHG8  GR30=[$ptr],$newval,Assembler::acquire\n"
          "\tCMP.EQ    PR6,PR7=GR30,$oldval\n"
          "\t(PR6) MOV dst=1\n"
          "\t(PR7) MOV dst=0" %}
  ins_encode( emit_cmpxchg8_bool(dst, ptr, oldval, newval, GR30, PR6, PR7) );
  ins_pipe( long_memory_op );
%}

// JSR-166 variants.

// CompareAndSwapP. Does a compare-and-swap, returns boolean for success
instruct compareAndSwapP( gRegI dst, gRegP ptr, gRegP oldval, gRegP newval, gr30_gRegP tmp, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (CompareAndSwapP ptr (Binary oldval newval)));
  effect( KILL tmp, KILL pr6, KILL pr7 );
  ins_cost(CALL_COST);

  format %{ "MOV       AR_CCV=$oldval\t// CompareAndSwapP\n"
          "\tCMPXCHG8  GR30=[$ptr],$newval,Assembler::acquire\n"
          "\tCMP.EQ    PR6,PR7=GR30,$oldval\n"
          "\t(PR6) MOV dst=1\n"
          "\t(PR7) MOV dst=0" %}
  ins_encode( emit_cmpxchg8_bool(dst, ptr, oldval, newval, GR30, PR6, PR7) );
  ins_pipe( long_memory_op );
%}

// CompareAndSwapL. Does a compare-and-swap, returns boolean for success
instruct compareAndSwapL( gRegI dst, gRegP ptr, gRegL oldval, gRegL newval, gr30_gRegL tmp, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (CompareAndSwapL ptr (Binary oldval newval)));
  effect( KILL tmp, KILL pr6, KILL pr7 );
  ins_cost(CALL_COST);

  format %{ "MOV       AR_CCV=$oldval\t// CompareAndSwapL\n"
          "\tCMPXCHG8  GR30=[$ptr],$newval,Assembler::acquire\n"
          "\tCMP.EQ    PR6,PR7=GR30,$newval\n"
          "\t(PR6) MOV dst=1\n"
          "\t(PR7) MOV dst=0" %}
  ins_encode( emit_cmpxchg8_bool(dst, ptr, oldval, newval, GR30, PR6, PR7) );
  ins_pipe( long_memory_op );
%}

// CompareAndSwapI. Does a compare-and-swap, returns boolean for success
instruct compareAndSwapI( gRegI dst, gRegP ptr, gRegI oldval, gRegI newval, gr30_gRegL tmp, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (CompareAndSwapI ptr (Binary oldval newval)));
  effect( KILL tmp, KILL pr6, KILL pr7 );
  ins_cost(CALL_COST);

  format %{ "ZXT4      $oldval=$oldval\t// CompareAndSwapI\n"
           "\tMOV       AR_CCV=$oldval\t// CompareAndSwapI\n"
          "\tCMPXCHG4   GR30=[$ptr],$newval,Assembler::acquire\n"
          "\tCMP4.EQ    PR6,PR7=GR30,$newval\n"
          "\t(PR6) MOV dst=1\n"
          "\t(PR7) MOV dst=0" %}
  ins_encode( emit_cmpxchg_bool(dst, ptr, oldval, newval, GR30, PR6, PR7) );
  ins_pipe( long_memory_op );
%}


//----------Conditional Move---------------------------------------------------
// Conditional move
instruct cmovII_reg_reg_reg(cmpOp cmp, gRegI in1, gRegI in2, gRegI src, gRegI dst, pr6_pReg pr) %{
  match(Set dst (CMoveI (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,$in2 ;;\n\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovII_reg_reg_imm(cmpOp cmp, gRegI in1, gRegI in2, gRegI dst, immI14 src, pr6_pReg pr) %{
  match(Set dst (CMoveI (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,$in2 ;;\n\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_imm14( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_imm);
%}

instruct cmovII_reg_zero_imm(cmpOp cmp, gRegI in1, immI_0 in2, gRegI dst, immI14 src, pr6_pReg pr) %{
  match(Set dst (CMoveI (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,GR0 ;;\n\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, GR0, PR0 ), emit_mov_imm14( dst, src, PR6) );
  ins_pipe(pr_pr_ICMP_gr_imm__gr_IALU_imm);
%}

instruct cmovLI_reg(cmpOp cmp, gRegL in1, gRegL in2, gRegI dst, gRegI src, pr6_pReg pr) %{
  match(Set dst (CMoveI (Binary cmp (CmpL in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// long\n\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovPI_reg(cmpOpU cmp, gRegP in1, gRegP in2, gRegI dst, gRegI src, pr6_pReg pr) %{
  match(Set dst (CMoveI (Binary cmp (CmpP in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// ptr\n\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovDI_reg_lt_le(cmpOp cmp, fRegD in1, fRegD in2, gRegI dst, gRegI src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveI (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDI_reg_gt_ge(cmpOp cmp, fRegD in1, fRegD in2, gRegI dst, gRegI src, pr6_pReg ord) %{
  match(Set dst (CMoveI (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDI_reg_eq_ne(cmpOp cmp, fRegD in1, fRegD in2, gRegI dst, gRegI src, pr6_pReg ord) %{
  match(Set dst (CMoveI (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFI_reg_lt_le(cmpOp cmp, fRegF in1, fRegF in2, gRegI dst, gRegI src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveI (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFI_reg_gt_ge(cmpOp cmp, fRegF in1, fRegF in2, gRegI dst, gRegI src, pr6_pReg ord) %{
  match(Set dst (CMoveI (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFI_reg_eq_ne(cmpOp cmp, fRegF in1, fRegF in2, gRegI dst, gRegI src, pr6_pReg ord) %{
  match(Set dst (CMoveI (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovIL_reg(cmpOp cmp, gRegI in1, gRegI in2, gRegL dst, gRegL src, pr6_pReg pr) %{
  match(Set dst (CMoveL (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,$in2 ;;\n\t(PR6) MOV    $dst=$src\t// long" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovLL_reg(cmpOp cmp, gRegL in1, gRegL in2, gRegL dst, gRegL src, pr6_pReg pr) %{
  match(Set dst (CMoveL (Binary cmp (CmpL in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// long\n\t(PR6) MOV    $dst=$src\t// long" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovPL_reg(cmpOpU cmp, gRegP in1, gRegP in2, gRegL dst, gRegL src, pr6_pReg pr) %{
  match(Set dst (CMoveL (Binary cmp (CmpP in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// ptr\n\t(PR6) MOV    $dst=$src\t// long" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovDL_reg_lt_le(cmpOp cmp, fRegD in1, fRegD in2, gRegL dst, gRegL src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveL (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDL_reg_gt_ge(cmpOp cmp, fRegD in1, fRegD in2, gRegL dst, gRegL src, pr6_pReg ord) %{
  match(Set dst (CMoveL (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDL_reg_eq_ne(cmpOp cmp, fRegD in1, fRegD in2, gRegL dst, gRegL src, pr6_pReg ord) %{
  match(Set dst (CMoveL (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFL_reg_lt_le(cmpOp cmp, fRegF in1, fRegF in2, gRegL dst, gRegL src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveL (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFL_reg_gt_ge(cmpOp cmp, fRegF in1, fRegF in2, gRegL dst, gRegL src, pr6_pReg ord) %{
  match(Set dst (CMoveL (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFL_reg_eq_ne(cmpOp cmp, fRegF in1, fRegF in2, gRegL dst, gRegL src, pr6_pReg ord) %{
  match(Set dst (CMoveL (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovIP_reg(cmpOp cmp, gRegI in1, gRegI in2, gRegP dst, gRegP src, pr6_pReg pr) %{
  match(Set dst (CMoveP (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,$in2 ;;\n\t(PR6) MOV    $dst=$src\t// ptr" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovLP_reg(cmpOp cmp, gRegL in1, gRegL in2, gRegP dst, gRegP src, pr6_pReg pr) %{
  match(Set dst (CMoveP (Binary cmp (CmpL in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// long\n\t(PR6) MOV    $dst=$src\t// ptr" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovPP_reg(cmpOpU cmp, gRegP in1, gRegP in2, gRegP dst, gRegP src, pr6_pReg pr) %{
  match(Set dst (CMoveP (Binary cmp (CmpP in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// ptr\n\t(PR6) MOV    $dst=$src\t// ptr" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_mov_reg( dst, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr);
%}

instruct cmovDP_reg_lt_le(cmpOp cmp, fRegD in1, fRegD in2, gRegP dst, gRegP src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveP (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src\t! ptr" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDP_reg_gt_ge(cmpOp cmp, fRegD in1, fRegD in2, gRegP dst, gRegP src, pr6_pReg ord) %{
  match(Set dst (CMoveP (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src\t! ptr" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDP_reg_eq_ne(cmpOp cmp, fRegD in1, fRegD in2, gRegP dst, gRegP src, pr6_pReg ord) %{
  match(Set dst (CMoveP (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src\t! ptr" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFP_reg_lt_le(cmpOp cmp, fRegF in1, fRegF in2, gRegP dst, gRegP src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveP (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src\t! ptr" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFP_reg_gt_ge(cmpOp cmp, fRegF in1, fRegF in2, gRegP dst, gRegP src, pr6_pReg ord) %{
  match(Set dst (CMoveP (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src\t! ptr" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFP_reg_eq_ne(cmpOp cmp, fRegF in1, fRegF in2, gRegP dst, gRegP src, pr6_pReg ord) %{
  match(Set dst (CMoveP (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) MOV    $dst=$src\t! ptr" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_mov_reg( dst, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovIF_reg(cmpOp cmp, gRegI in1, gRegI in2, fRegF dst, fRegF src, pr6_pReg pr) %{
  match(Set dst (CMoveF (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,$in2 ;;\n\t(PR6) FMOV   $dst=$src\t\t// float" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__fr_FMISC_fr);
%}

instruct cmovLF_reg(cmpOp cmp, gRegL in1, gRegL in2, fRegF dst, fRegF src, pr6_pReg pr) %{
  match(Set dst (CMoveF (Binary cmp (CmpL in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// long\n\t(PR6) FMOV   $dst=$src\t\t// float" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__fr_FMISC_fr);
%}

instruct cmovPF_reg(cmpOpU cmp, gRegP in1, gRegP in2, fRegF dst, fRegF src, pr6_pReg pr) %{
  match(Set dst (CMoveF (Binary cmp (CmpP in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// ptr\n\t(PR6) FMOV   $dst=$src\t\t// float" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__fr_FMISC_fr);
%}

instruct cmovDF_reg_lt_le(cmpOp cmp, fRegD in1, fRegD in2, fRegF dst, fRegF src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveF (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDF_reg_gt_ge(cmpOp cmp, fRegD in1, fRegD in2, fRegF dst, fRegF src, pr6_pReg ord) %{
  match(Set dst (CMoveF (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDF_reg_eq_ne(cmpOp cmp, fRegD in1, fRegD in2, fRegF dst, fRegF src, pr6_pReg ord) %{
  match(Set dst (CMoveF (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFF_reg_lt_le(cmpOp cmp, fRegF in1, fRegF in2, fRegF dst, fRegF src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveF (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFF_reg_gt_ge(cmpOp cmp, fRegF in1, fRegF in2, fRegF dst, fRegF src, pr6_pReg ord) %{
  match(Set dst (CMoveF (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFF_reg_eq_ne(cmpOp cmp, fRegF in1, fRegF in2, fRegF dst, fRegF src, pr6_pReg ord) %{
  match(Set dst (CMoveF (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovID_reg(cmpOp cmp, gRegI in1, gRegI in2, fRegD dst, fRegD src, pr6_pReg pr) %{
  match(Set dst (CMoveD (Binary cmp (CmpI in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.$cmp PR6,PR0=$in1,$in2 ;;\n\t(PR6) FMOV   $dst=$src\t\t// double" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__fr_FMISC_fr);
%}

instruct cmovLD_reg(cmpOp cmp, gRegL in1, gRegL in2, fRegD dst, fRegD src, pr6_pReg pr) %{
  match(Set dst (CMoveD (Binary cmp (CmpL in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// long\n\t(PR6) FMOV   $dst=$src\t\t// double" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__fr_FMISC_fr);
%}

instruct cmovPD_reg(cmpOpU cmp, gRegP in1, gRegP in2, fRegD dst, fRegD src, pr6_pReg pr) %{
  match(Set dst (CMoveD (Binary cmp (CmpP in1 in2)) (Binary dst src)));
  effect(KILL pr);
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.$cmp PR6,PR0=$in1,$in2 ;;\t// ptr\n\t(PR6) FMOV   $dst=$src\t\t// double" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, in1, in2, PR0 ), emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__fr_FMISC_fr);
%}

instruct cmovDD_reg_lt_le(cmpOp cmp, fRegD in1, fRegD in2, fRegD dst, fRegD src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveD (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDD_reg_gt_ge(cmpOp cmp, fRegD in1, fRegD in2, fRegD dst, fRegD src, pr6_pReg ord) %{
  match(Set dst (CMoveD (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovDD_reg_eq_ne(cmpOp cmp, fRegD in1, fRegD in2, fRegD dst, fRegD src, pr6_pReg ord) %{
  match(Set dst (CMoveD (Binary cmp (CmpD in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFD_reg_lt_le(cmpOp cmp, fRegF in1, fRegF in2, fRegD dst, fRegD src, pr6_pReg unord, pr7_pReg ord) %{
  match(Set dst (CMoveD (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL unord, KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR6,PR7=$in1,$in2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFD_reg_gt_ge(cmpOp cmp, fRegF in1, fRegF in2, fRegD dst, fRegD src, pr6_pReg ord) %{
  match(Set dst (CMoveD (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

instruct cmovFD_reg_eq_ne(cmpOp cmp, fRegF in1, fRegF in2, fRegD dst, fRegD src, pr6_pReg ord) %{
  match(Set dst (CMoveD (Binary cmp (CmpF in1 in2)) (Binary dst src)));
  effect(KILL ord);
  ins_cost(DEFAULT_COST * 2);
  predicate( _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq ||
             _kids[0]->_kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );

  ins_cost(DEFAULT_COST + FP_CMP_COST * 2);
  format %{ "FCMP.UNORD PR0,PR6=$in1,$in2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$in1,$in2 ;;\n"
          "\t(PR6) FMOV   $dst=$src" %}
  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, in1, in2 ),
              emit_fmerges_reg_reg( dst, src, src, PR6 ) );
  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__pr_IALU_gr );
%}

//----------OS and Locking Instructions----------------------------------------
// This name is KNOWN by the ADLC and cannot be changed.
// The ADLC forces a 'TypeRawPtr::BOTTOM' output type
// for this guy.
instruct tlsLoadP(gRegP dst) %{
  match(Set dst (ThreadLocal));
  ins_cost(HUGE_COST);
  effect(DEF dst);

  format %{ "MOV    $dst=GR4_TLS\t// tlsLoad" %}
  ins_encode( emit_mov_reg( dst, GR4_TLS, PR0 ) );
  ins_pipe( gr_IALU_gr );
%}

instruct TLS(gRegP dst) %{
  match(Set dst (ThreadLocal));
  ins_cost(HUGE_COST); // don't use this unless we have to

  expand %{
    tlsLoadP(dst);
  %}
%}

instruct checkCastPP( gRegP dst) %{
  match(Set dst (CheckCastPP dst));
  format %{ "#checkcastPP of $dst" %}
  ins_encode( /*empty encoding*/ );
  ins_pipe(empty_ptr);
%}

instruct castPP( gRegP dst ) %{
  match(Set dst (CastPP dst));
  format %{ "#castPP of $dst" %}
  ins_encode( /*empty encoding*/ );
  ins_pipe(empty_ptr);
%}

//----------Arithmetic Instructions--------------------------------------------
// Addition Instructions
// Register Addition
instruct addI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
  match(Set dst (AddI src1 src2));

  format %{ "ADD    $dst=$src1,$src2" %}
  ins_encode( emit_addI_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_gr);
%}

// Immediate Addition
instruct addI_reg_imm14(gRegI dst, gRegI src1, immI14 src2) %{
  match(Set dst (AddI src1 src2));

  format %{ "ADDS   $dst=$src1,$src2" %}
  ins_encode( emit_addI_reg_imm14( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct addI_reg_imm22(gRegI dst, g23RegI src1, immI22 src2) %{
  match(Set dst (AddI src1 src2));
  ins_cost((DEFAULT_COST * 3)/2);

  format %{ "ADDL   $dst=$src1,$src2" %}
  ins_encode( emit_addI_reg_imm22( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

// Pointer Register Addition
instruct addP_reg_reg(gRegP dst, gRegP src1, gRegL src2) %{
  match(Set dst (AddP src1 src2));
 
  format %{ "ADD    $dst=$src1,$src2\t// ptr" %}
  ins_encode( emit_addP_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_gr);
%}

// Pointer Immediate Addition
instruct addP_reg_immL14(gRegP dst, gRegP src1, immL14 src2) %{
  match(Set dst (AddP src1 src2));

  format %{ "ADDS   $dst=$src1,$src2\t// ptr" %}
  ins_encode( emit_addP_reg_immL14( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct addP_reg_immL22(gRegP dst, g23RegP src1, immL22 src2) %{
  match(Set dst (AddP src1 src2));
  ins_cost((DEFAULT_COST * 3)/2);

  format %{ "ADDL   $dst=$src1,$src2\t// ptr" %}
  ins_encode( emit_addP_reg_immL22( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

// Long Addition
instruct addL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
  match(Set dst (AddL src1 src2));

  format %{ "ADD    $dst=$src1,$src2\t// long" %}
  ins_encode( emit_addL_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_gr);
%}

// Long Immediate Addition
instruct addL_reg_imm14(gRegL dst, gRegL src1, immL14 src2) %{
  match(Set dst (AddL src1 src2));

  format %{ "ADDS   $dst=$src1,$src2\t// long" %}
  ins_encode( emit_addL_reg_imm14( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct addL_reg_imm22(gRegL dst, g23RegL src1, immL22 src2) %{
  match(Set dst (AddL src1 src2));
  ins_cost((DEFAULT_COST * 3)/2);

  format %{ "ADDL   $dst=$src1,$src2\t// long" %}
  ins_encode( emit_addL_reg_imm22( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

//---------------------
// Subtraction Instructions
// Register Subtraction
instruct subI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
  match(Set dst (SubI src1 src2));
  effect(DEF dst, USE src1, USE src2);

  format %{ "SUB    $dst=$src1,$src2" %}
  ins_encode( emit_subI_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_gr);
%}

// Immediate Subtraction
instruct subI_imm8_reg(gRegI dst, immI8 src1, gRegI src2) %{
  match(Set dst (SubI src1 src2));

  format %{ "SUB    $dst=$src1,$src2" %}
  ins_encode( emit_subI_imm8_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

instruct subI_zero_reg(gRegI dst, immI_0 zero, gRegI src2) %{
  match(Set dst (SubI zero src2));

  format %{ "SUB    $dst=GR0,$src2" %}
  ins_encode( emit_subI_reg_reg( dst, GR0, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

// Long subtraction
instruct subL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
  match(Set dst (SubL src1 src2));
  format %{ "SUB    $dst=$src1,$src2\t// long" %}
  ins_encode( emit_subL_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_gr);
%}

// Long Immediate Subtraction
instruct subL_imm8_reg(gRegL dst, immL8 src1, gRegL src2) %{
  match(Set dst (SubL src1 src2));

  format %{ "SUB    $dst=$src1,$src2\t// long" %}
  ins_encode( emit_subL_imm8_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

// Long negation
instruct negL_reg_reg(gRegL dst, immL_0 zero, gRegL src2) %{
  match(Set dst (SubL zero src2));

  format %{ "SUB    $dst=GR0,$src2\t// long" %}
  ins_encode( emit_subL_reg_reg( dst, GR0, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_imm);
%}

// Multiplication Instructions
// Integer Multiplication
//   instruct mulI_reg_reg_1(fRegD dst, gRegI src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct mulI_reg_reg_2(fRegD dst, gRegI src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct mulI_reg_reg_3(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "XMPY.L   $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_xmpyl_reg_reg( dst, src1, src2, PR0 ) );
//     ins_pipe(fr_XMA_fr_fr);
//   %}
// 
//   instruct mulI_reg_reg_4(gRegI dst, fRegD src) %{
//     format %{ "GETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_getfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
// instruct mulI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
//   match(Set dst (MulI src1 src2));
//   ins_cost(FP_MEMORY_READ_COST + DEFAULT_COST + FP_OP_COST + FP_MEMORY_WRITE_COST);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     fRegD tmp1;
//     fRegD tmp2;
//     fRegD tmp3;
//     mulI_reg_reg_1(tmp1, src1);
//     mulI_reg_reg_2(tmp2, src2);
//     mulI_reg_reg_3(tmp3, tmp1, tmp2);
//     mulI_reg_reg_4(dst, tmp3);
//   %}
// %}

instruct mulI_reg_reg(gRegI dst, gRegI src1, gRegI src2, fr14_fRegD fr14, fr15_fRegD fr15) %{
  match(Set dst (MulI src1 src2));
  ins_cost(FP_MEMORY_READ_COST + DEFAULT_COST + FP_OP_COST + FP_MEMORY_WRITE_COST);
  effect(KILL fr14, KILL fr15);

  format %{ "SETF.SIG FR14=$src1\t// Begin Multiply I\n"
          "\tSETF.SIG FR15=$src2\n"
          "\tXMPY.L   FR14=FR14,FR15\n"
          "\tGETF.SIG $dst=FR14\t// End Multiply Int" %}

  ins_encode( emit_setfSIG_reg( FR14, src1, PR0 ),
              emit_setfSIG_reg( FR15, src2, PR0 ),
              emit_xmpyl_reg_reg( FR14, FR14, FR15, PR0 ),
              emit_getfSIG_reg( dst, FR14, PR0 ) );

  ins_pipe(long_fp_op);
%}

// Long Multiplication
//   instruct mulL_reg_reg_1(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct mulL_reg_reg_2(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct mulL_reg_reg_3(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "XMPY.L   $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_xmpyl_reg_reg( dst, src1, src2, PR0 ) );
//     ins_pipe(fr_XMA_fr_fr);
//   %}
// 
//   instruct mulL_reg_reg_4(gRegL dst, fRegD src) %{
//     format %{ "GETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_getfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
// instruct mulL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
//   match(Set dst (MulL src1 src2));
//   ins_cost(FP_MEMORY_READ_COST + DEFAULT_COST + FP_OP_COST + FP_MEMORY_WRITE_COST);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     fRegD tmp1;
//     fRegD tmp2;
//     fRegD tmp3;
//     mulL_reg_reg_1(tmp1, src1);
//     mulL_reg_reg_2(tmp2, src2);
//     mulL_reg_reg_3(tmp3, tmp1, tmp2);
//     mulL_reg_reg_4(dst, tmp3);
//   %}
// %}

instruct mulL_reg_reg(gRegL dst, gRegL src1, gRegL src2, fr14_fRegD fr14, fr15_fRegD fr15) %{
  match(Set dst (MulL src1 src2));
  effect(KILL fr14, KILL fr15);
  ins_cost(FP_MEMORY_READ_COST + DEFAULT_COST + FP_OP_COST + FP_MEMORY_WRITE_COST);

  format %{ "SETF.SIG FR14=$src1\t// Begin Multiply Long\n"
          "\tSETF.SIG FR15=$src2\n"
          "\tXMPY.L   FR14=FR14,FR15\n"
         "\tGETF.SIG $dst=FR14\t// End   Multiply Long" %}

  ins_encode( emit_setfSIG_reg( FR14, src1, PR0 ),
              emit_setfSIG_reg( FR15, src2, PR0 ),
              emit_xmpyl_reg_reg( FR14, FR14, FR15, PR0 ),
              emit_getfSIG_reg( dst, FR14, PR0 ) );

  ins_pipe(long_fp_op);
%}

// Integer Division
// Note: this presumes that the status for sf0 is extended
// Note: integer division is being elaborated as one node because
//   otherwise we would need to spill an aligned 16 byte entry,
//   which the register allocator is presently incapable of
//   handling.
instruct divI_reg_reg(gRegI dst, gRegI src1, gRegI src2, fr13_fRegD fr13, fr14_fRegD fr14, fr15_fRegD fr15) %{
  match(Set dst (DivI src1 src2));
  ins_cost(FP_MEMORY_READ_COST * 2 + DEFAULT_COST * 2 + FP_MEMORY_WRITE_COST + FP_OP_COST * 11);
  effect(KILL fr13, KILL fr14, KILL fr15);

  format %{ "SXT4      $src1=$src1\t// Begin Int Division\n"
          "\tSXT4      $src2=$src2\n"
          "\tSETF.SIG  FR15=$src1\n"
          "\tSETF.SIG  FR14=$src2\n"
          "\tFCVTXF    FR15=FR15\t// long -> extended\n"
          "\tFCVTXF    FR14=FR14\t// long -> extended\n"
          "\tFRCPA.SF1 FR13,PR0=FR15,FR14\n"
          "\tFMPY.SF1  FR15=FR15,FR13\n"
          "\tFNMA.SF1  FR14=FR14,FR13,FR1\n"
          "\tFMA.SF1   FR15=FR15,FR14,FR15\n"
          "\tFMPY.SF1  FR14=FR14,FR14\n"
          "\tFMA.SF1   FR15=FR15,FR14,FR15\n"
          "\tFMPY.SF1  FR14=FR14,FR14\n"
          "\tFMAD      FR15=FR15,FR14,FR15\n"
          "\tFCVT.FX.TRUNC FR15=FR15\t// double->long\n"
          "\tGETF.SIG $dst=FR15\t// End   Int Division" %}

  ins_encode( emit_sxt4_reg(src1, src1, PR0),
              emit_sxt4_reg(src2, src2, PR0),
              emit_setfSIG_reg(FR15, src1, PR0),
              emit_setfSIG_reg(FR14, src2, PR0),
              emit_fcvtXF_reg(FR15, FR15, PR0),
              emit_fcvtXF_reg(FR14, FR14, PR0),
              emit_frcpa_reg_reg(FR13, PR0, FR15, FR14, PR0),
              emit_fmpy_reg_reg(FR15, FR15, FR13, PR0),
              emit_fnma_reg_reg_reg(FR14, FR1, FR14, FR13, PR0),
              emit_fma_reg_reg_reg(FR15, FR15, FR14, FR15, PR0),
              emit_fmpy_reg_reg(FR14, FR14, FR14, PR0),
              emit_fma_reg_reg_reg(FR15, FR15, FR14, FR15, PR0),
              emit_fmpy_reg_reg(FR14, FR14, FR14, PR0),
              emit_fmaD_reg_reg_reg(FR15, FR15, FR14, FR15, PR0),
              emit_fcvtFXTrunc_reg(FR15, FR15, PR0),
              emit_getfSIG_reg(dst, FR15, PR0) );
  ins_pipe(long_fp_op);
%}

// // Note: this presumes that the status for sf0 is extended
//   instruct divI__1(gRegL dst, gRegI src) %{
//     format %{ "SXT4   $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_sxt4_reg(dst, src, PR0 ) );
//     ins_pipe(gr_XTD_gr);
//   %}
// 
//   instruct divI__2(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg(dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct divI__3(fRegD dst, fRegD src) %{
//     format %{ "FCVTXF $dst=$src\t// long -> extended" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct divI__4(gRegL dst, gRegI src) %{
//     format %{ "SXT4   $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_sxt4_reg(dst, src, PR0 ) );
//     ins_pipe(gr_XTD_gr);
//   %}
// 
//   instruct divI__5(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg(dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct divI__6(fRegD dst, fRegD src) %{
//     format %{ "FCVTXF  $dst=$src\t// long -> extended" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct divI__7(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FRCPA.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_frcpa_reg_reg(dst, PR0, src1, src2, PR0 ) );
//     ins_pipe(fr_FMISC_fr_fr);
//   %}
// 
//   instruct divI__8(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divI__9(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FNMA.SF1 $dst=$src1,$src2,FR1" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fnma_reg_reg_reg(dst, FR1, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divI_10(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divI_11(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divI_12(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divI_13(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divI_14(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMAD   $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fmaD_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divI_15(fRegD dst, fRegD src) %{
//     format %{ "FCVT.FX.TRUNC $dst=$src\t// double->long" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtFXTrunc_reg( dst, src, PR0) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct divI_16(gRegI dst, fRegD src) %{
//     format %{ "GETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_getfSIG_reg(dst, src, PR0 ) );
//     ins_pipe(gr_FRFR_fr);
//   %}
// 
// instruct divI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
//   match(Set dst (DivI src1 src2));
//   ins_cost(FP_MEMORY_READ_COST * 2 + DEFAULT_COST * 2 + FP_MEMORY_WRITE_COST + FP_OP_COST * 11);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     gRegL src1x; gRegL src2x;
//     fRegD a_int; fRegD a; fRegD b_int; fRegD b;
//     fRegD y; fRegD q; fRegD e; fRegD e1;
//     fRegD q1; fRegD q2; fRegD e2; fRegD q3; fRegD q4;
// 
//     divI__1(src1x, src1);
//     divI__2(a_int, src1x);
//     divI__3(a, a_int);       // a = fcvt(A)
//     divI__4(src2x, src2);
//     divI__5(b_int, src2x);
//     divI__6(b, b_int);       // b = fcvt(B)
//     divI__7(y, a, b);        // y = frcpa(b)
//     divI__8(q, a, y);        // q = a * y
//     divI__9(e, b, y);        // e = -(b * y) + 1
//     divI_10(q1, q, e, q);    // q1 = q * e + q
//     divI_11(e1, e, e);       // e1 = e * e
//     divI_12(q2, q1, e1, q1); // q2 = q1 * e1 + q1
//     divI_13(e2, e1, e1);     // e2 = e1 * e1
//     divI_14(q3, q2, e2, q2); // q3 = double(q2 * e2 + q2)
//     divI_15(q4, q3);         // Q  = truncate(q3)
//     divI_16(dst, q4);
//   %}
// %}

// Long Division
// Note: this presumes that the status for sf1 is extended
//   instruct divL__1(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg(dst, src, PR0) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct divL__2(fRegD dst, fRegD src) %{
//     format %{ "FCVTXF $dst=$src\t// long -> extended" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct divL__3(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg(dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct divL__4(fRegD dst, fRegD src) %{
//     format %{ "FCVTXF  $dst=$src\t// long -> extended" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct divL__5(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FRCPA.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_frcpa_reg_reg(dst, PR0, src1, src2, PR0 ) );
//     ins_pipe(fr_FMISC_fr_fr);
//   %}
// 
//   instruct divL__6(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divL__7(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FNMA.SF1 $dst=$src1,$src2,FR1" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fnma_reg_reg_reg(dst, FR1, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divL__8(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src3, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divL__9(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divL_10(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src3, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divL_11(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src3, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divL_12(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FNMA.SF1 $dst=$src1,$src2,src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fnma_reg_reg_reg(dst, src3, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divL_13(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src3, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divL_14(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src3, src1, src2, PR0 ) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divL_15(fRegD dst, fRegD src) %{
//     format %{ "FCVT.FX.TRUNC $dst=$src\t// double->long" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtFXTrunc_reg( dst, src, PR0) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct divL_16(gRegI dst, fRegD src) %{
//     format %{ "GETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_getfSIG_reg(dst, src, PR0 ) );
//     ins_pipe(gr_FRFR_fr);
//   %}
// 
// instruct divL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
//   match(Set dst (DivL src1 src2));
//   ins_cost(FP_MEMORY_READ_COST * 2 + FP_MEMORY_WRITE_COST + FP_OP_COST * 13);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     fRegD a_int; fRegD a; fRegD b_int; fRegD b;
//     fRegD y; fRegD y1; fRegD y2;
//     fRegD q; fRegD q1; fRegD q2; fRegD q3; fRegD q4;
//     fRegD e; fRegD e1;
//     fRegD r;
// 
//     divL__1(a_int, src1);
//     divL__2(a, a_int);       // a = fcvt(A)
//     divL__3(b_int, src2);
//     divL__4(b, b_int);       // b = fcvt(B)
//     divL__5(y, a, b);        // y = frcpa(b)
//     divL__6(q, a, y);        // q = a * y
//     divL__7(e, b, y);        // e = -(b * y) + 1
//     divL__8(q1, q, e, q);    // q1 = q * e + q
//     divL__9(e1, e, e);       // e1 = e * e
//     divL_10(q2, q1, e1, q1); // q2 = q1 * e1 + q1
//     divL_11(y1, y, e, y);    // y1 = y * e + y
//     divL_12(r, b, q2, a);    // r = -(b * q2) + a
//     divL_13(y2, y1, e1, y1); // y2 = y1 * e1 + y1
//     divL_14(q3, r, y2, q2);  // q3 = r * y2 + q2
//     divL_15(q4, q3);         // Q  = truncate(q3)
//     divL_16(dst, q4);
//   %}
// %}

instruct divL_reg_reg(gRegL dst, gRegL src1, gRegL src2, fr10_fRegD fr10, fr11_fRegD fr11, fr12_fRegD fr12, fr13_fRegD fr13, fr14_fRegD fr14, fr15_fRegD fr15) %{
  match(Set dst (DivL src1 src2));
  effect(KILL fr10, KILL fr11, KILL fr12, KILL fr13, KILL fr14, KILL fr15);
  ins_cost(FP_MEMORY_READ_COST * 2 + FP_MEMORY_WRITE_COST + FP_OP_COST * 13);

  format %{ "SETF.SIG  FR15=$src1\t// Begin Long Divide\n"
          "\tSETF.SIG  FR14=$src2\n"
          "\tFCVTXF    FR15=FR15\n"
          "\tFCVTXF    FR14=FR14\n"
          "\tFRCPA.SF1 FR13=FR15,FR14\n"
          "\tFMPY.SF1  FR12=FR15,FR13\n"
          "\tFNMA.SF1  FR11=FR14,FR13,FR1\n"
          "\tFMA.SF1   FR12=FR12,FR11,FR12\n"
          "\tFMPY.SF1  FR10=FR11,FR11\n"
          "\tFMA.SF1   FR12=FR12,FR10,FR12\n"
          "\tFMA.SF1   FR13=FR14,FR11,FR14\n"
          "\tFNMA.SF1  FR14=FR14,FR12,FR15\n"
          "\tFMA.SF1   FR13=FR13,FR10,FR13\n"
          "\tFMA.SF1   FR12=FR14,FR13,FR12\n"
          "\tFCVT.FX.TRUNC FR12=FR12\n"
          "\tGETF.SIG $dst=FR12" %}

  ins_encode( emit_setfSIG_reg(FR15, src1, PR0),
              emit_setfSIG_reg(FR14, src2, PR0),
              emit_fcvtXF_reg(FR15, FR15, PR0),
              emit_fcvtXF_reg(FR14, FR14, PR0),
              emit_frcpa_reg_reg(FR13, PR0, FR15, FR14, PR0),
              emit_fmpy_reg_reg(FR12, FR15, FR13, PR0),
              emit_fnma_reg_reg_reg(FR11, FR1, FR14, FR13, PR0), 
              emit_fma_reg_reg_reg(FR12, FR12, FR12, FR11, PR0),
              emit_fmpy_reg_reg(FR10, FR11, FR11, PR0),
              emit_fma_reg_reg_reg(FR12, FR12, FR12, FR10, PR0),
              emit_fma_reg_reg_reg(FR13, FR13, FR13, FR11, PR0),
              emit_fnma_reg_reg_reg(FR14, FR15, FR14, FR12, PR0),
              emit_fma_reg_reg_reg(FR13, FR13, FR13, FR10, PR0),
              emit_fma_reg_reg_reg(FR12, FR12, FR14, FR13, PR0),
              emit_fcvtFXTrunc_reg(FR12, FR12, PR0),
              emit_getfSIG_reg(dst, FR12, PR0) );

  ins_pipe(long_fp_op);
%}

// Integer Mod
instruct modI_reg_reg(gRegI dst, gRegI src1, gRegI src2, gr29_gRegP gr29, fr12_fRegD fr12, fr13_fRegD fr13, fr14_fRegD fr14, fr15_fRegD fr15) %{
  match(Set dst (ModI src1 src2));
  effect(KILL gr29, KILL fr12, KILL fr13, KILL fr14, KILL fr15);
  ins_cost(FP_MEMORY_READ_COST * 2 + DEFAULT_COST * 3 + FP_MEMORY_WRITE_COST + FP_OP_COST * 12);

  format %{ "SXT4      $src1=$src1\t// Begin Integer Mod\n"
          "\tSXT4      $src2=$src2\n"
          "\tSETF.SIG  FR15=$src1\n"
          "\tSETF.SIG  FR12=$src2\n"
          "\tFCVTXF    FR15=FR15\n"
          "\tFCVTXF    FR14=FR12\n"
          "\tFRCPA.SF1 FR13,PR0=FR15,FR14\n"
          "\tFMPY.SF1  FR15=FR15,FR13\n"
          "\tFNMA.SF1  FR14=FR14,FR13,FR1\n"
          "\tFMA.SF1   FR15=FR15,FR14,FR15\n"
          "\tFMPY.SF1  FR14=FR14,FR14\n"
          "\tFMA.SF1   FR15=FR15,FR14,FR15\n"
          "\tFMPY.SF1  FR14=FR14,FR14\n"
          "\tFMAD      FR15=FR15,FR14,FR15\n"
          "\tFCVT.FX.TRUNC FR15=FR15\n"
          "\tXMPY.L    FR15=FR15,FR12\n"
          "\tGETF.SIG  GR29=FR15\n"
          "\tSUB       $dst=$src1,GR29\t// End Integer Mod" %}

  ins_encode( emit_sxt4_reg(src1, src1, PR0),
              emit_sxt4_reg(src2, src2, PR0),
              emit_setfSIG_reg(FR15, src1, PR0),
              emit_setfSIG_reg(FR12, src2, PR0),
              emit_fcvtXF_reg(FR15, FR15, PR0),
              emit_fcvtXF_reg(FR14, FR12, PR0),
              emit_frcpa_reg_reg(FR13, PR0, FR15, FR14, PR0),
              emit_fmpy_reg_reg(FR15, FR15, FR13, PR0),
              emit_fnma_reg_reg_reg(FR14, FR1, FR14, FR13, PR0),
              emit_fma_reg_reg_reg(FR15, FR15, FR14, FR15, PR0),
              emit_fmpy_reg_reg(FR14, FR14, FR14, PR0),
              emit_fma_reg_reg_reg(FR15, FR15, FR14, FR15, PR0),
              emit_fmpy_reg_reg(FR14, FR14, FR14, PR0),
              emit_fmaD_reg_reg_reg(FR15, FR15, FR14, FR15, PR0),
              emit_fcvtFXTrunc_reg(FR15, FR15, PR0),
              emit_xmpyl_reg_reg( FR15, FR15, FR12, PR0 ),
              emit_getfSIG_reg( GR29, FR15, PR0 ),
              emit_subI_reg_reg( dst, src1, GR29, PR0 ) );

  ins_pipe(long_fp_op);
%}

//   instruct modI_16(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "XMPY.L $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_xmpyl_reg_reg( dst, src1, src2, PR0 ) );
//     ins_pipe(fr_XMA_fr_fr);
//   %}
// 
//   instruct modI_17(gRegI dst, gRegI src1, gRegI src2) %{
//     effect(DEF dst, USE src1, USE src2);
//     format %{ "SUB    $dst=$src1,$src2" %}
//     ins_encode( emit_subI_reg_reg( dst, src1, src2, PR0 ) );
//     ins_pipe(gr_IALU_gr_gr);
//   %}
// 
// instruct modI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
//   match(Set dst (ModI src1 src2));
//   ins_cost(FP_MEMORY_READ_COST * 2 + DEFAULT_COST * 3 + FP_MEMORY_WRITE_COST + FP_OP_COST * 12);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     gRegL src1x; gRegL src2x;
//     fRegD a_int; fRegD a; fRegD b_int; fRegD b;
//     fRegD y; fRegD q; fRegD e; fRegD e1;
//     fRegD q1; fRegD q2; fRegD e2; fRegD q3; fRegD q4; fRegD q5;
//     gRegI g1;
// 
//     divI__1(src1x, src1);
//     divI__2(a_int, src1x);
//     divI__3(a, a_int);
//     divI__4(src2x, src2);
//     divI__5(b_int, src2x);
//     divI__6(b, b_int);
//     divI__7(y, a, b);        // y = frcpa(b)
//     divI__8(q, a, y);        // q = a * y
//     divI__9(e, b, y);        // e = -(b * y) + 1
//     divI_10(q1, q, e, q);    // q1 = q * e + q
//     divI_11(e1, e, e);       // e1 = e * e
//     divI_12(q2, q1, e1, q1); // q2 = q1 * e1 + q1
//     divI_13(e2, e1, e1);     // e2 = e1 * e1
//     divI_14(q3, q2, e2, q2); // q3 = double(q2 * e2 + q2)
//     divI_15(q4, q3);         // q4 = truncate(q3)
//     modI_16(q5, q4, b_int);  // q5 = q4 * b
//     divI_16(g1, q5);         // g1 = q5
//     modI_17(dst, src1, g1);  // dst = src1 - q1
//   %}
// %}

// Long Mod
instruct modL_reg_reg(gRegL dst, gRegL src1, gRegL src2, gr29_gRegP gr29, fr9_fRegD fr9, fr10_fRegD fr10, fr11_fRegD fr11, fr12_fRegD fr12, fr13_fRegD fr13, fr14_fRegD fr14, fr15_fRegD fr15) %{
  match(Set dst (ModL src1 src2));
  ins_cost(FP_MEMORY_READ_COST * 2 + FP_MEMORY_WRITE_COST + FP_OP_COST * 13);
  effect(KILL gr29, KILL fr9, KILL fr10, KILL fr11, KILL fr12, KILL fr13, KILL fr14, KILL fr15);

  format %{ "SETF.SIG  FR15=$src1\t// Begin Long Modulo\n"
          "\tSETF.SIG  FR9=$src2\n"
          "\tFCVTXF    FR15=FR15\n"
          "\tFCVTXF    FR14=FR9\n"
          "\tFRCPA.SF1 FR13=FR15,FR14\n"
          "\tFMPY.SF1  FR12=FR15,FR13\n"
          "\tFNMA.SF1  FR11=FR14,FR13,FR1\n"
          "\tFMA.SF1   FR12=FR12,FR11,FR12\n"
          "\tFMPY.SF1  FR10=FR11,FR11\n"
          "\tFMA.SF1   FR12=FR12,FR10,FR12\n"
          "\tFMA.SF1   FR13=FR14,FR11,FR14\n"
          "\tFNMA.SF1  FR14=FR14,FR12,FR15\n"
          "\tFMA.SF1   FR13=FR13,FR10,FR13\n"
          "\tFMA.SF1   FR12=FR14,FR13,FR12\n"
          "\tFCVT.FX.TRUNC FR12=FR12\n"
          "\tXMPY.L FR12=FR12,FR9\n"
          "\tGETF.SIG  GR29=FR12\n"
          "\tSUB    $dst=$src1,GR29\t// End Long Modulo" %}

  ins_encode( emit_setfSIG_reg(FR15, src1, PR0),
              emit_setfSIG_reg(FR9, src2, PR0),
              emit_fcvtXF_reg(FR15, FR15, PR0),
              emit_fcvtXF_reg(FR14, FR9, PR0),
              emit_frcpa_reg_reg(FR13, PR0, FR15, FR14, PR0),
              emit_fmpy_reg_reg(FR12, FR15, FR13, PR0),
              emit_fnma_reg_reg_reg(FR11, FR1, FR14, FR13, PR0), 
              emit_fma_reg_reg_reg(FR12, FR12, FR12, FR11, PR0),
              emit_fmpy_reg_reg(FR10, FR11, FR11, PR0),
              emit_fma_reg_reg_reg(FR12, FR12, FR12, FR10, PR0),
              emit_fma_reg_reg_reg(FR13, FR13, FR13, FR11, PR0),
              emit_fnma_reg_reg_reg(FR14, FR15, FR14, FR12, PR0),
              emit_fma_reg_reg_reg(FR13, FR13, FR13, FR10, PR0),
              emit_fma_reg_reg_reg(FR12, FR12, FR14, FR13, PR0),
              emit_fcvtFXTrunc_reg(FR12, FR12, PR0),
              emit_xmpyl_reg_reg(FR12, FR12, FR9, PR0),
              emit_getfSIG_reg(GR29, FR12, PR0),
              emit_subL_reg_reg(dst, src1, GR29, PR0) );

  ins_pipe(long_fp_op);
%}

//   instruct modL_16(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "XMPY.L $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_xmpyl_reg_reg( dst, src1, src2, PR0 ) );
//     ins_pipe(fr_XMA_fr_fr);
//   %}
// 
//   instruct modL_17(gRegL dst, gRegL src1, gRegL src2) %{
//     effect(DEF dst, USE src1, USE src2);
//     format %{ "SUB    $dst=$src1,$src2" %}
//     ins_encode( emit_subL_reg_reg( dst, src1, src2, PR0 ) );
//     ins_pipe(gr_IALU_gr_gr);
//   %}
// 
// instruct modL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
//   match(Set dst (ModL src1 src2));
//   ins_cost(FP_MEMORY_READ_COST * 2 + FP_MEMORY_WRITE_COST + FP_OP_COST * 13);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     fRegD a_int; fRegD a; fRegD b_int; fRegD b;
//     fRegD y; fRegD y1; fRegD y2;
//     fRegD q; fRegD q1; fRegD q2; fRegD q3; fRegD q4; fRegD q5;
//     fRegD e; fRegD e1;
//     fRegD r;
//     gRegL g1;
// 
//     divL__1(a_int, src1);
//     divL__2(a, a_int);       // a = fcvt(A)
//     divL__3(b_int, src2);
//     divL__4(b, b_int);       // b = fcvt(B)
//     divL__5(y, a, b);        // y = frcpa(b)
//     divL__6(q, a, y);        // q = a * y
//     divL__7(e, b, y);        // e = -(b * y) + 1
//     divL__8(q1, q, e, q);    // q1 = q * e + q
//     divL__9(e1, e, e);       // e1 = e * e
//     divL_10(q2, q1, e1, q1); // q2 = q1 * e1 + q1
//     divL_11(y1, y, e, y);    // y1 = y * e + y
//     divL_12(r, b, q2, a);    // r = -(b * q2) + a
//     divL_13(y2, y1, e1, y1); // y2 = y1 * e1 + y1
//     divL_14(q3, r, y2, q2);  // q3 = r * y2 + q2
//     divL_15(q4, q3);         // Q  = truncate(q3)
//     modL_16(q5, q4, b_int);  // q5 = q4 * b
//     divL_16(g1, q5);         // g1 = q5
//     modL_17(dst, src1, g1);  // dst = src1 - g1
//   %}
// %}

// Float Remainder
// ###

// Double Remainder
// ###

// Integer Shift Instructions
// Register Shift Left
  instruct shlI_reg_reg_1(gRegI dst, gRegI src) %{
    format %{ "AND3   $dst=#31,$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_andI_31_reg( dst, src ) );
    ins_pipe(gr_ILOG_gr);
  %}

  instruct shlI_reg_reg_2(gRegI dst, gRegI src, gRegI cnt) %{
    format %{ "SHL    $dst=$src,$cnt" %}
    effect(DEF dst, USE src, USE cnt);
    ins_encode( emit_shl_reg_reg(dst, src, cnt, PR0 ) );
    ins_pipe(gr_MMSHF_gr_gr);
  %}

instruct shlI_reg_reg(gRegI dst, gRegI src, gRegI cnt) %{
  match(Set dst (LShiftI src cnt));
  ins_cost(DEFAULT_COST * 2);
  effect(USE src, USE cnt);

  expand %{
    gRegI tmp;
    shlI_reg_reg_1(tmp, cnt);      // Adjust the shift count to integer
    shlI_reg_reg_2(dst, src, tmp); // Do the shift left
  %}
%}

instruct shladdI_reg_reg(gRegI dst, gRegI src1, gRegI src2, immI_1to4 shift) %{
  match(Set dst (AddI src1 (LShiftI src2 shift)));
  ins_cost(DEFAULT_COST);
  format %{ "SHLADD $dst=$src1 + ($src2 << $shift)" %}
  ins_encode( emit_shladd_reg_reg(dst, src1, src2, shift, PR0) );
  ins_pipe(gr_MMSHF_gr_gr);
%}

// Register Shift Left Immediate
instruct shlI_reg_imm6(gRegI dst, gRegI src, immI_1to64 cnt) %{
  match(Set dst (LShiftI src cnt));

  format %{ "SHL    $dst=$src,$cnt" %}
  ins_encode( emit_shlI_reg_imm6(dst, src, cnt, PR0 ) );
  ins_pipe(gr_ISHF_gr_imm);
%}

// Long Register Shift Left
  instruct shlL_reg_reg_1(gRegI dst, gRegI src) %{
    format %{ "AND    $dst=#63,$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_andI_63_reg( dst, src ) );
    ins_pipe(gr_ILOG_gr);
  %}

  instruct shlL_reg_reg_2(gRegL dst, gRegL src, gRegI cnt) %{
    format %{ "SHL    $dst=$src,$cnt\t// long" %}
    effect(DEF dst, USE src, USE cnt);
    ins_encode( emit_shl_reg_reg(dst, src, cnt, PR0 ) );
    ins_pipe(gr_IALU_gr_gr);
  %}

instruct shlL_reg_reg(gRegL dst, gRegL src, gRegI cnt) %{
  match(Set dst (LShiftL src cnt));
  ins_cost(DEFAULT_COST * 2);
  effect(USE src, USE cnt);

  expand %{
    gRegI tmp;
    shlL_reg_reg_1(tmp, cnt);
    shlL_reg_reg_2(dst, src, tmp);
  %}
%}

// Long Register Shift Left Immediate
instruct shlL_reg_imm6(gRegL dst, gRegL src, immI_1to64 cnt) %{
  match(Set dst (LShiftL src cnt));

  format %{ "SHL    $dst=$src,$cnt\t// long" %}
  ins_encode( emit_shlL_reg_imm6(dst, src, cnt, PR0 ) );
  ins_pipe(gr_ISHF_gr_imm);
%}

// Shift Right Unsigned
// Register Shift Right Unsigned
  instruct shrI_reg_reg_1(gRegI dst, gRegI src) %{
    format %{ "AND    $dst=#31,$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_andI_31_reg( dst, src ) );
    ins_pipe(gr_ILOG_gr);
  %}

  instruct shrI_reg_reg_2(gRegI dst, gRegI src) %{
    format %{ "ZXT4   $dst=$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_zxt4_reg( dst, src ) );
    ins_pipe(gr_XTD_gr);
  %}

  instruct shrI_reg_reg_3(gRegI dst, gRegI src, gRegI cnt) %{
    format %{ "SHRU   $dst=$src,$cnt" %}
    effect(DEF dst, USE src, USE cnt);
    ins_encode( emit_shru_reg_reg(dst, src, cnt, PR0 ) );
    ins_pipe(gr_MMSHF_gr_gr);
  %}

instruct shrI_reg_reg(gRegI dst, gRegI src, gRegI cnt) %{
  match(Set dst (URShiftI src cnt));
  ins_cost(DEFAULT_COST * 2);
  effect(USE src, USE cnt);

  expand %{
    gRegI tmp1; gRegI tmp2;
    shrI_reg_reg_1(tmp1, cnt);       // Adjust the shift count to integer
    shrI_reg_reg_2(tmp2, src);       // Zero the high order bits of the shifee
    shrI_reg_reg_3(dst, tmp2, tmp1); // Do the shift left
  %}
%}

// Register Shift Right Unsigned Immediate
instruct shrI_reg_imm6(gRegI dst, gRegI src, immI_1to64 cnt) %{
  match(Set dst (URShiftI src cnt));

  format %{ "SHRU   $dst=$src,$cnt" %}
  ins_encode( emit_shruI_reg_imm6(dst, src, cnt, PR0 ) );
  ins_pipe(gr_ISHF_gr_imm);
%}

// Long Register Shift Right
  instruct shrL_reg_reg_1(gRegI dst, gRegI src) %{
    format %{ "AND    $dst=#63,$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_andI_63_reg( dst, src ) );
    ins_pipe(gr_ILOG_gr);
  %}

  instruct shrL_reg_reg_2(gRegL dst, gRegL src, gRegI cnt) %{
    format %{ "SHRU  $dst=$src,$cnt\t// long" %}
    effect(DEF dst, USE src, USE cnt);
    ins_encode( emit_shru_reg_reg(dst, src, cnt, PR0 ) );
    ins_pipe(gr_IALU_gr_gr);
  %}

instruct shrL_reg_reg(gRegL dst, gRegL src, gRegI cnt) %{
  match(Set dst (URShiftL src cnt));
  ins_cost(DEFAULT_COST * 2);
  effect(USE src, USE cnt);

  expand %{
    gRegI tmp;
    shrL_reg_reg_1(tmp, cnt);
    shrL_reg_reg_2(dst, src, tmp);
  %}
%}

// Long Register Shift Right Immediate
instruct shrL_reg_imm6(gRegL dst, gRegL src, immI_1to64 cnt) %{
  match(Set dst (URShiftL src cnt));

  format %{ "SHRU  $dst=$src,$cnt" %}
  ins_encode( emit_shruL_reg_imm6(dst, src, cnt, PR0 ) );
  ins_pipe(gr_ISHF_gr_imm);
%}

instruct shladdL_reg_reg(gRegL dst, gRegL src1, gRegL src2, immI_1to4 shift) %{
  match(Set dst (AddL src1 (LShiftL src2 shift)));
  ins_cost(DEFAULT_COST);
  format %{ "SHLADD $dst = $src1 + ($src2 << $shift)\t// long" %}
  ins_encode( emit_shladd_reg_reg(dst, src1, src2, shift, PR0 ) );
  ins_pipe(gr_MMSHF_gr_gr);
%}

// Right Shift Arithmetic
// Register Shift Right Arithmetic
  instruct sarI_reg_reg_1(gRegI dst, gRegI src) %{
    format %{ "AND    $dst=#31,$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_andI_31_reg( dst, src ) );
    ins_pipe(gr_ILOG_gr);
  %}

  instruct sarI_reg_reg_2(gRegI dst, gRegI src) %{
    format %{ "SXT4   $dst=$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_sxt4_reg(dst, src, PR0 ) );
    ins_pipe(gr_XTD_gr);
  %}

  instruct sarI_reg_reg_3(gRegI dst, gRegI src, gRegI cnt) %{
    format %{ "SHR    $dst=$src,$cnt" %}
    effect(DEF dst, USE src, USE cnt);
    ins_encode( emit_sar_reg_reg(dst, src, cnt, PR0 ) );
    ins_pipe(gr_MMSHF_gr_gr);
  %}

instruct sarI_reg_reg(gRegI dst, gRegI src, gRegI cnt) %{
  match(Set dst (RShiftI src cnt));
  ins_cost(DEFAULT_COST * 2);
  effect(USE src, USE cnt);

  expand %{
    gRegI tmp1; gRegI tmp2;
    sarI_reg_reg_1(tmp1, cnt);       // Adjust the shift count to integer
    sarI_reg_reg_2(tmp2, src);       // Adjust the source to integer
    sarI_reg_reg_3(dst, tmp2, tmp1); // Do the shift right
  %}
%}

// Register Shift Right Arithmetic Immediate
instruct sarI_reg_imm6(gRegI dst, gRegI src, immI_1to64 cnt) %{
  match(Set dst (RShiftI src cnt));

  format %{ "SHR    $dst=$src,$cnt" %}
  ins_encode( emit_sarI_reg_imm6(dst, src, cnt, PR0 ) );
  ins_pipe(gr_ISHF_gr_imm);
%}

// Long Register Shift Right Arithmetic
  instruct sarL_reg_reg_1(gRegI dst, gRegI src) %{
    format %{ "AND    $dst=#63,$src" %}
    effect(DEF dst, USE src);
    ins_encode( emit_andI_63_reg( dst, src ) );
    ins_pipe(gr_ILOG_gr);
  %}

  instruct sarL_reg_reg_2(gRegL dst, gRegL src, gRegI cnt) %{
    format %{ "SHR    $dst=$src,$cnt\t// long" %}
    effect(DEF dst, USE src, USE cnt);
    ins_encode( emit_sar_reg_reg(dst, src, cnt, PR0 ) );
    ins_pipe(gr_IALU_gr_gr);
  %}

instruct sarL_reg_reg(gRegL dst, gRegL src, gRegI cnt) %{
  match(Set dst (RShiftL src cnt));
  ins_cost(DEFAULT_COST * 2);
  effect(USE src, USE cnt);

  expand %{
    gRegI tmp;
    sarL_reg_reg_1(tmp, cnt);
    sarL_reg_reg_2(dst, src, tmp);
  %}
%}

// Long Register Shift Left Immediate
instruct sarL_reg_imm6(gRegL dst, gRegL src, immI_1to64 cnt) %{
  match(Set dst (RShiftL src cnt));

  format %{ "SHR   $dst=$src,$cnt\t// long" %}
  ins_encode( emit_sarL_reg_imm6(dst, src, cnt, PR0) );
  ins_pipe(gr_ISHF_gr_imm);
%}

instruct shladdP_reg_reg(gRegP dst, gRegP src1, gRegL src2, immI_1to4 shift) %{
  match(Set dst (AddP src1 (LShiftL src2 shift)));
  ins_cost(DEFAULT_COST);
  format %{ "SHLADD $dst = $src1 + ($src2 << $shift)\t// ptr" %}
  ins_encode( emit_shladd_reg_reg(dst, src1, src2, shift, PR0) );
  ins_pipe(gr_MMSHF_gr_gr);
%}

//----------Floating Point Arithmetic Instructions-----------------------------

//  Add float single precision
instruct addF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{
  match(Set dst (AddF src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FADDS  $dst=$src1,$src2" %}
  ins_encode( emit_addF_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

//  Add float double precision
instruct addD_reg_reg(fRegD dst, fRegD src1, fRegD src2) %{
  match(Set dst (AddD src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FADDD  $dst=$src1,$src2" %}
  ins_encode( emit_addD_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

//  Sub float single precision
instruct subF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{
  match(Set dst (SubF src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FSUBS  $dst=$src1,$src2" %}
  ins_encode( emit_subF_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

instruct subF_reg_immF1(fRegF dst, fRegF src1, immF_1 src2) %{
  match(Set dst (SubF src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FSUBS  $dst=$src1,FR1" %}
  ins_encode( emit_subF_reg_reg( dst, src1, FR1, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

//  Sub float double precision
instruct subD_reg_reg(fRegD dst, fRegD src1, fRegD src2) %{
  match(Set dst (SubD src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FSUBD  $dst=$src1,$src2" %}
  ins_encode( emit_subD_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

instruct subD_reg_immD1(fRegD dst, fRegD src1, immD_1 src2) %{
  match(Set dst (SubD src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FSUBD  $dst=$src1,FR1" %}
  ins_encode( emit_subD_reg_reg( dst, src1, FR1, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

// Single Precision Multiply
instruct mulF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{
  match(Set dst (MulF src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FMULS  $dst=$src1,$src2" %}
  ins_encode( emit_fmpyF_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

// Double Precision Multiply
instruct mulD_reg_reg(fRegD dst, fRegD src1, fRegD src2) %{
  match(Set dst (MulD src1 src2));
  ins_cost(FP_OP_COST);

  format %{ "FMULD  $dst=$src1,$src2" %}
  ins_encode( emit_fmpyD_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(fr_FMAC_fr_fr);
%}

//  Div float single precision
// instruct divF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{
//  match(Set dst (DivF src1 src2));
// %}

// Single Precision Divide
// Note: this presumes that the status for sf1 is extended
//   instruct divF__1(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FRCPA.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_frcpa_reg_reg(dst, PR0, src1, src2, PR0) );
//     ins_pipe(fr_FMISC_fr_fr);
//   %}
// 
//   instruct divF__2(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FNMA.SF1 $dst=$src1,$src2,FR1" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fnma_reg_reg_reg(dst, FR1, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divF__3(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divF__4(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divF__5(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMAD    $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fmaF_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divF__6(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divF__7(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FNMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fnma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divF__8(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMAD    $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fmaF_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
// // Assumes that the divisor has been checked for non-zero
// instruct divF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{
//   match(Set dst (DivF src1 src2));
//   ins_cost(FP_OP_COST * 13);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     fRegD y; fRegD y1;
//     fRegD e; fRegD e1;
//     fRegD q; fRegD q1;
//     fRegD r;
// 
//     divF__1(y, src1, src2);       // y = frcpa(b)
//     divF__2(e, src2, y);          // e = -(b * y) + 1
//     divF__3(q, src1, y);          // q = a * y
//     divF__4(e1, e,  e,  e);       // e1 = e  * e  + e
//     divF__5(q1, q,  e1, q);       // q1 = single(q * e1 + q)
//     divF__6(y1, y,  e1, y);       // y1 = y  * e1 + y
//     divF__7(r, src2, q1, src1);   // r = -(b * q1) + a
//     divF__8(dst, r, y1, q1);      // Q = single(r * y1 + q1)
//   %}
// %}

// Assumes that the divisor has been checked for non-zero
instruct divF_reg_reg(fRegF dst, fRegF_notmp13 src1, fRegF_notmp13 src2, fr13_fRegD fr13, fr14_fRegD fr14, fr15_fRegD fr15, pr6_pReg pr6) %{
  match(Set dst (DivF src1 src2));
  effect(KILL fr13, KILL fr14, KILL fr15, KILL pr6);
  ins_cost(FP_OP_COST * 8);

  format %{ "      FRCPA.SF0 FR13,PR6=$src1,$src2\t// Begin Float Divide\n"
          "\t(PR6) FMPY.SF1  FR14=$src1,FR13\n"
          "\t(PR6) FNMA.SF1  FR15=$src2,FR13,FR1 ;;\n"
          "\t(PR6) FMA.SF1   FR14=FR15,FR14,FR14\n"
          "\t(PR6) FMPY.S1   FR15=FR15,FR15 ;;\n"
          "\t(PR6) FMA.SF1   FR14=FR15,FR14,FR14\n"
          "\t(PR6) FMPY.S1   FR15=FR15,FR15 ;;\n"
          "\t(PR6) FMAD.SF1  FR14=FR15,FR14,FR14 ;;\n"
          "\t(PR6) FNORMS    FR13=FR14 ;;\n"
          "\t      MOV       $dst=FR13\t\t// End   Float Divide" %}

  ins_encode( emit_fdivf_reg_reg(dst, src1, src2, FR14, FR15, FR13, PR6) );

  ins_pipe(long_fp_op);
%}

// Double Precision Divide
// Note: this presumes that the status for sf1 is extended
//   instruct divD__1(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FRCPA.SF1 $dst=$src1,$src2" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_frcpa_reg_reg(dst, PR0, src1, src2, PR0) );
//     ins_pipe(fr_FMISC_fr_fr);
//   %}
// 
//   instruct divD__2(fRegD dst, fRegD src1, fRegD src2) %{
//     format %{ "FNMA.SF1 $dst=$src1,$src2,FR1" %}
//     effect(DEF dst, USE src1, USE src2);
//     ins_encode( emit_fnma_reg_reg_reg(dst, FR1, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divD__3(fRegD dst, fRegD src1, fRegD src2) %{
//     effect(DEF dst, USE src1, USE src2);
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divD__4(fRegD dst, fRegD src1, fRegD src2) %{
//     effect(DEF dst, USE src1, USE src2);
//     format %{ "FMPY.SF1 $dst=$src1,$src2" %}
//     ins_encode( emit_fmpy_reg_reg(dst, src1, src2, PR0) );
//     ins_pipe(fr_FMAC_fr_fr);
//   %}
// 
//   instruct divD__5(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD__6(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD__7(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst=$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD__8(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst,$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD__9(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMAD    $dst,$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fmaD_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD_10(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMA.SF1 $dst,$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD_11(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FNMA.SF1 $dst,$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fnma_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
//   instruct divD_12(fRegD dst, fRegD src1, fRegD src2, fRegD src3) %{
//     format %{ "FMAD    $dst,$src1,$src2,$src3" %}
//     effect(DEF dst, USE src1, USE src2, USE src3);
//     ins_encode( emit_fmaD_reg_reg_reg(dst, src1, src2, src3, PR0) );
//     ins_pipe(fr_FMAC_fr_fr_fr);
//   %}
// 
// // Assumes that the divisor has been checked for non-zero
// instruct divD_reg_reg(fRegD dst, fRegD src1, fRegD src2) %{
//   match(Set dst (DivD src1 src2));
//   ins_cost(FP_OP_COST * 13);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     fRegD y; fRegD y1; fRegD y2;
//     fRegD e; fRegD e1; fRegD e2; fRegD e3;
//     fRegD q; fRegD q1; fRegD q2;
//     fRegD r1;
// 
//     divD__1(y, src1, src2);       // y = frcpa(b)
//     divD__2(e, src2, y);          // e = -(b * y) + 1
//     divD__3(q, src1, y);          // q = a * y
//     divD__4(e1, e,  e);           // e1 = e * e
//     divD__5(e2, e,  e,  e);       // e2 = e  * e  + e
//     divD__6(e3, e1, e1, e);       // e3 = e1 * e1 + e
//     divD__7(q1, q,  e2, q);       // q1 = q  * e2 + q
//     divD__8(y1, y, e2, y);        // y1 = y  * e2 + y
//     divD__9(q2, q1, e3, q);       // q2 = double(q1 * e3 + q)
//     divD_10(y2, y1, e3, y);       // y2 = y1 * e3 + y
//     divD_11(r1, src2, q2, src1);  // r1 = -(b * q2) + a
//     divD_12(dst, r1, y2, q2);     // Q = double(r1 * y1 + q2)
//   %}
// %}

// Assumes that the divisor has been checked for non-zero
instruct divD_reg_reg(fRegD_notmp12 dst, fRegD_notmp12 src1, fRegD_notmp12 src2, fr12_fRegD fr12, fr13_fRegD fr13, fr14_fRegD fr14, fr15_fRegD fr15, pr6_pReg pr6) %{
  effect(KILL fr12, KILL fr13, KILL fr14, KILL fr15, KILL pr6);
  match(Set dst (DivD src1 src2));
  ins_cost(FP_OP_COST * 14);

  format %{ "      FRCPA.SF0 FR12,pr=$src1,$src2\t\t// Begin Double Divide\n"
            "\t(PR6) FMPY.SF1  FR13=$src1,FR12\n"
            "\t(PR6) FNMA.SF1  FR14=$src2,FR12,FR1\n"
            "\t(PR6) FMA.SF1   FR13=FR14,FR13,FR13\n"
            "\t(PR6) FMPY.SF1  FR15=FR14,FR14\n"
            "\t(PR6) FMA.SF1   FR12=FR14,FR12,FR12\n"
            "\t(PR6) FMA.SF1   FR13=FR15,FR13,FR13\n"
            "\t(PR6) FMPY.SF1  FR14=FR15,FR15\n"
            "\t(PR6) FMA.SF1   FR12=FR15,FR12,FR12\n"
            "\t(PR6) FMAD.SF1  FR13=FR14,FR13,FR13\n"
            "\t(PR6) FMA.SF1   FR12=FR14,FR12,FR12\n"
            "\t(PR6) FNMAD.SF1 FR14=$src2,FR13,$src1\n"
            "\t(PR6) FMAD.SF0  FR12=FR14,FR12,FR13\n"
            "\t      FMOV      dst=FR12\t\t// End   Double Divide\n" %}

  ins_encode( emit_fdivd_reg_reg( dst, src1, src2, FR12, FR13, FR14, FR15, PR6 ) );

  ins_pipe(long_fp_op);
%}

//  Absolute float double precision
instruct absD_reg(fRegD dst, fRegD src) %{
  match(Set dst (AbsD src));
  ins_cost(FP_OP_COST);

  format %{ "FABS   $dst=$src\t\t// double" %}
  ins_encode( emit_absD_reg(dst, src, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

//  Absolute float single precision
instruct absF_reg(fRegF dst, fRegF src) %{
  match(Set dst (AbsF src));
  ins_cost(FP_OP_COST);

  format %{ "FABS   $dst=$src\t// Single" %}
  ins_encode( emit_absF_reg(dst, src, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

//  Negate float double precision
instruct negD_reg(fRegD dst, fRegD src) %{
  match(Set dst (NegD src));
  ins_cost(FP_OP_COST);

  format %{ "FNEG   $dst=$src\t\t// double" %}
  ins_encode( emit_negD_reg(dst, src, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

//  Negate Absolute Value float double precision
instruct negabsD_reg(fRegD dst, fRegD src) %{
  match(Set dst (NegD (AbsD src)));
  ins_cost(FP_OP_COST);

  format %{ "FNEGABS $dst=$src\t\t// double" %}
  ins_encode( emit_negabsD_reg(dst, src, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

//  Negate float single precision
instruct negF_reg(fRegF dst, fRegF src) %{
  match(Set dst (NegF src));
  ins_cost(FP_OP_COST);

  format %{ "FNEG   $dst=$src\t// Single" %}
  ins_encode( emit_negF_reg(dst, src, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

//  Negate float single precision
instruct negabsF_reg(fRegF dst, fRegF src) %{
  match(Set dst (NegF (AbsF src)));
  ins_cost(FP_OP_COST);

  format %{ "FNEGABS $dst=$src\t// Single" %}
  ins_encode( emit_negabsF_reg(dst, src, PR0 ) );
  ins_pipe(fr_FMISC_fr);
%}

//----------Logical Instructions-----------------------------------------------
// And Instructions
// Register And
instruct andI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
  match(Set dst (AndI src1 src2));

  format %{ "AND3   $dst=$src1,$src2" %}
  ins_encode( emit_andI_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_IALU_gr_gr);
%}

// Immediate And
instruct andI_reg_imm8(gRegI dst, gRegI src1, immI8 src2) %{
  match(Set dst (AndI src1 src2));

  format %{ "AND3   $dst=$src1,$src2" %}
  ins_encode( emit_andI_imm8_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_imm);
%}

// Long Register And
instruct andL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
  match(Set dst (AndL src1 src2));

  format %{ "AND3   $dst=$src1,$src2\t// long" %}
  ins_encode( emit_andL_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_ILOG_gr_gr);
%}

// Long Immediate And
instruct andL_reg_imm8(gRegL dst, gRegL src1, immL8 src2) %{
  match(Set dst (AndL src1 src2));

  format %{ "AND3   $dst=$src1,$src2\t// long" %}
  ins_encode( emit_andL_imm8_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_imm);
%}

// Or Instructions
// Register Or
instruct orI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
  match(Set dst (OrI src1 src2));

  format %{ "OR3    $dst=$src1,$src2" %}
  ins_encode( emit_orI_reg_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_gr);
%}

// Immediate Or
instruct orI_reg_imm8(gRegI dst, gRegI src1, immI8 src2) %{
  match(Set dst (OrI src1 src2));

  format %{ "OR3    $dst=$src1,$src2" %}
  ins_encode( emit_orI_imm8_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_imm);
%}

// Long Register Or
instruct orL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
  match(Set dst (OrL src1 src2));

  format %{ "OR3    $dst=$src1,$src2\t// long" %}
  ins_encode( emit_orL_reg_reg( dst, src1, src2, PR0 ) );
  ins_pipe(gr_ILOG_gr_gr);
%}

// Long Immediate Or
instruct orL_reg_imm8(gRegL dst, gRegL src1, immL8 src2) %{
  match(Set dst (OrL src1 src2));

  format %{ "OR3    $dst=$src1,$src2\t// long" %}
  ins_encode( emit_orL_imm8_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_imm);
%}

// Xor Instructions
// Register Xor
instruct xorI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
  match(Set dst (XorI src1 src2));

  format %{ "XOR3   $dst=$src1,$src2" %}
  ins_encode( emit_xorI_reg_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_gr);
%}

// Immediate Xor
instruct xorI_reg_imm8(gRegI dst, gRegI src1, immI8 src2) %{
  match(Set dst (XorI src1 src2));

  format %{ "XOR3   $dst=$src1,$src2" %}
  ins_encode( emit_xorI_imm8_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_imm);
%}

// Long Register Xor
instruct xorL_reg_reg(gRegL dst, gRegL src1, gRegL src2) %{
  match(Set dst (XorL src1 src2));

  format %{ "xor3   $dst=$src1,$src2\t// long" %}
  ins_encode( emit_xorL_reg_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_gr);
%}

// Long Immediate Xor
instruct xorL_reg_imm8(gRegL dst, gRegL src1, immL8 src2) %{
  match(Set dst (XorL src1 src2));

  format %{ "XOR3   $dst=$src1,$src2\t// long" %}
  ins_encode( emit_xorL_imm8_reg( dst, src2, src1, PR0 ) );
  ins_pipe(gr_ILOG_gr_imm);
%}

//----------Converts-----------------------------------------------------------
// 
// instruct cmpI_reg_imm13(ccReg cr, gRegI op1, immI13 op2) %{
//   effect(DEF cr, USE op1, USE op2);
// 
//   format %{ "CMP    $op1,$op2" %}
//   // Prim = op3, Secnd = bits 31-30
//   opcode(Assembler::subcc_op3, Assembler::arith_op); 
//   ins_encode( form3_rs1_simm13_g0( op1, op2 ) );
//   ins_pipe(ialu_cconly_reg_imm);
// %}
// 
// // %%%%% compI_subI_iReg(ccReg cr, gRegI op1, gRegI op2)
// instruct compI_subI_iReg(ccReg cr, o1RegI op1, gRegI op2) %{
//   effect(DEF cr, USE_DEF op1, USE op2);
// 
//   format %{ "SUBcc  $op1,$op2,$op1" %}
//   // Prim = op3, Secnd = bits 31-30
//   opcode(Assembler::subcc_op3, Assembler::arith_op); 
//   ins_encode( form3_rs1_rs2_rd( op1, op2, op1 ) );
//   ins_pipe(ialu_cc_rwreg_reg);
// %}
// 
// // %%%%% compI_subI_imm13(ccReg cr, gRegI op1, gRegI op2)
// instruct compI_subI_imm13(ccReg cr, o1RegI op1, immI13 op2) %{
//   effect(DEF cr, USE_DEF op1, USE op2);
// 
//   format %{ "SUBcc  $op1,$op2,$op1" %}
//   // Prim = op3, Secnd = bits 31-30
//   opcode(Assembler::subcc_op3, Assembler::arith_op); 
//   ins_encode( form3_rs1_simm13_rd( op1, op2, op1 ) );
//   ins_pipe(ialu_cc_rwreg_imm);
// %}

instruct cmpLTMask_reg_reg( gRegI dst, gRegI src1, gRegI src2, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (CmpLTMask src1 src2));
  effect( KILL pr6, KILL pr7 );
  ins_cost(DEFAULT_COST*2);

  format %{ "CMP4.LT PR6,PR7=$src1,$src2;;\n\t"
            "(PR7) MOV $dst=#0\n\t"
            "(PR6) MOV $dst=#-1" %}
  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src1, src2, PR0 ),
              emit_mov_reg( dst, GR0, PR7 ),
              emit_mov_immI_m1( dst, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_imm);
%}

instruct cmpLTMask_AndI_reg_reg_reg( gRegI dst, gRegI src1, gRegI src2, gRegI src3, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (AndI (CmpLTMask src1 src2) src3));
  effect( KILL pr6, KILL pr7 );
  ins_cost(DEFAULT_COST*2);

  format %{ "CMP4.LT PR6,PR7=$src1,$src2;;\n"
          "\t(PR6) MOV $dst=$src3\n"
          "\t(PR7) MOV $dst=#0" %}
  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src1, src2, PR0 ),
              emit_mov_reg( dst, src3, PR6 ),
              emit_mov_reg( dst, GR0, PR7 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_gr_1);
%}

instruct cmpLTMask_AndI_reg_zero_reg( gRegI dst, gRegI src1, immI_0 zero, gRegI src2, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (AndI (CmpLTMask src1 zero) src2));
  effect( KILL pr6, KILL pr7 );
  ins_cost(DEFAULT_COST*2);

  format %{ "CMP4.LT PR6,PR7=$src1,GR0;;\n"
          "\t(PR6) MOV $dst=$src2\n"
          "\t(PR7) MOV $dst=GR0" %}
  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src1, GR0, PR0 ),
              emit_mov_reg( dst, src2, PR6 ),
              emit_mov_reg( dst, GR0, PR7 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__gr_IALU_gr__gr_IALU_gr);
%}

instruct cmpLTMask_AndI_AddI_reg_zero_reg_reg( gRegI dst, gRegI src1, immI_0 zero, gRegI src2, gRegI src3, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (AddI (AndI (CmpLTMask src1 zero) src2) src3) );
  effect( KILL pr6, KILL pr7 );
  ins_cost(DEFAULT_COST*2);

  format %{ "CMP4.LT PR6,PR7=$src1,GR0;;\n"
          "\t(PR6) ADD $dst=$src2,$src3\n"
          "\t(PR7) MOV $dst=$src3" %}
  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src1, GR0, PR0 ),
              emit_addI_reg_reg( dst, src2, src3, PR6 ),
              emit_mov_reg( dst, src3, PR7 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__gr_IALU_gr_gr__gr_IALU_gr);
%}

//----------Convert to Boolean-------------------------------------------------
instruct convI2B( gRegI dst, gRegI src, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (Conv2B src));
  effect( KILL pr6, KILL pr7 );
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP4.EQ PR6,PR7=$src,GR0 ;;\n\t"
            "(PR6) MOV $dst=#0\n\t"
            "(PR7) MOV $dst=#1" %}
  ins_encode( emit_cmp4_eq_reg_reg( PR6, PR7, src, GR0, PR0 ),
              emit_mov_reg( dst, GR0, PR6 ),
              emit_mov_immI_1( dst, PR7 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_imm);
%}

instruct convP2B( gRegI dst, gRegP src, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (Conv2B src));
  effect( KILL pr6, KILL pr7 );
  ins_cost(DEFAULT_COST * 2);
  format %{ "CMP.EQ  PR6,PR7=$src,GR0\n\t"
            "(PR6) MOV $dst=#0\n\t"
            "(PR7) MOV $dst=#1" %}
  ins_encode( emit_cmp_eq_reg_reg( PR6, PR7, src, GR0, PR0 ),
              emit_mov_reg( dst, GR0, PR6 ),
              emit_mov_immI_1( dst, PR7 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_imm);
%}

//----------Arithmetic Conversion Instructions---------------------------------
// Convert a double to a float
instruct convD2F_reg(fRegF dst, fRegD src) %{
  match(Set dst (ConvD2F src));
  ins_cost(FP_OP_COST);

  format %{ "FDTOS  $dst=$src" %}
  ins_encode( emit_fcvtDS_reg(dst, src, PR0) );
  ins_pipe(fr_FMAC_fr);
%}

// Convert a float to a double
instruct convF2D_reg(fRegD dst, fRegF src) %{
  match(Set dst (ConvF2D src));
  ins_cost(FP_OP_COST);

  format %{ "FSTOD  $dst=$src" %}
  ins_encode( emit_fcvtSD_reg(dst, src, PR0) );
  ins_pipe(fr_FMAC_fr);
%}

// Convert Integer -> Long
instruct convI2L(gRegL dst, gRegI src) %{
  match(Set dst (ConvI2L src));
  effect(DEF dst, USE src);
  format %{ "SXT4   $dst=$src\t\t// int->long" %}
  ins_encode( emit_sxt4_reg( dst, src, PR0 ) );
  ins_pipe(gr_XTD_gr);
%}

// Convert Integer -> Float
//
//   instruct convI2F_reg_1(gRegL dst, gRegI src) %{
//     effect(DEF dst, USE src);
//     format %{ "SXT4   $dst=$src\t\t// int->long" %}
//     ins_encode( emit_sxt4_reg( dst, src, PR0 ) );
//     ins_pipe(gr_XTD_gr);
//   %}
// 
//   instruct convI2F_reg_2(fRegD dst, gRegL src) %{
//     effect(DEF dst, USE src);
//     format %{ "SETF.SIG $dst=$src" %}
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct convI2F_reg_3(fRegD dst, fRegD src) %{
//     effect(DEF dst, USE src);
//     format %{ "FCVTXF $dst=$src\t// long->double" %}
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct convI2F_reg_4(fRegF dst, fRegD src) %{
//     effect(DEF dst, USE src);
//     format %{ "FDTOS   $dst=$src\t\t// double->float" %}
//     ins_encode( emit_fcvtDS_reg(dst, src, PR0) );
//     ins_pipe(fr_FMAC_fr);
//   %}
// 
// instruct convI2F_reg(fRegF dst, gRegI src) %{
//   match(Set dst (ConvI2F src));
//   ins_cost(DEFAULT_COST + FP_MEMORY_READ_COST + FP_OP_COST);
//   effect(USE src);
// 
//   expand %{
//     gRegL tmp1; fRegD tmp2; fRegD tmp3;
//     convI2L      (tmp1, src);
//     convI2F_reg_2(tmp2, tmp1);
//     convI2F_reg_3(tmp3, tmp2);
//     convI2F_reg_4(dst,  tmp3);
//   %}
// %}

instruct convI2F_reg(fRegF dst, gRegI src) %{
  match(Set dst (ConvI2F src));
  ins_cost(DEFAULT_COST + FP_MEMORY_READ_COST + FP_OP_COST * 2);

  format %{ "SXT4   $src=$src\t// Begin Convert Int->Float\n"
          "\tSETF.SIG $dst=$src\n"
          "\tFCVTXF $dst=$dst\n"
          "\tFDTOS  $dst=$dst\t// End   Convert Int->Float" %}

  ins_encode( emit_sxt4_reg(src, src, PR0),
              emit_setfSIG_reg(dst, src, PR0),
              emit_fcvtXF_reg(dst, dst, PR0),
              emit_fcvtDS_reg(dst, dst, PR0) );

  ins_pipe(long_fp_op);
%}

// Convert Integer -> Double
//   instruct convI2D_reg_1(gRegL dst, gRegI src) %{
//     effect(DEF dst, USE src);
//     format %{ "SXT4   $dst=$src\t\t// int->long" %}
//     ins_encode( emit_sxt4_reg( dst, src, PR0 ) );
//     ins_pipe(gr_XTD_gr);
//  %}
// 
//   instruct convI2D_reg_2(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
//   instruct convI2D_reg_3(fRegD dst, fRegD src) %{
//     format %{ "FCVTFX $dst=$src\t// long -> double" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
// instruct convI2D_reg(fRegD dst, gRegI src) %{
//   match(Set dst (ConvI2D src));
//   ins_cost(DEFAULT_COST + FP_MEMORY_READ_COST + FP_OP_COST);
//   effect(USE src);
// 
//   expand %{
//     gRegL tmp1; fRegD tmp2;
//     convI2L      (tmp1, src);
//     convI2D_reg_2(tmp2, tmp1);
//     convI2D_reg_3(dst,  tmp2);
//   %}
// %}

instruct convI2D_reg(fRegD dst, gRegI src) %{
  match(Set dst (ConvI2D src));
  ins_cost(DEFAULT_COST + FP_MEMORY_READ_COST + FP_OP_COST * 2);

  format %{ "SXT4   $src=$src\t// Begin Convert Int->Double\n"
          "\tSETF.SIG $dst=$src\n"
          "\tFCVTXF $dst=$dst\t// End   Convert Int->Double" %}

  ins_encode( emit_sxt4_reg(src, src, PR0),
              emit_setfSIG_reg(dst, src, PR0),
              emit_fcvtXF_reg(dst, dst, PR0) );

  ins_pipe(long_fp_op);
%}

// Convert Long -> Double
//   instruct convL2D_stk_1(fRegD dst, stackSlotL src, gr29_gRegP temp1) %{
//     format %{ "ADDR   GR29=$src ;;\n\tLDF8   $dst=[GR29]\t// long" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_ldf8_stack( dst, src ) );
//     ins_pipe(fr_LDF_mem);
//   %}
// 
//   instruct convL2D_xxx_2(fRegD dst, fRegD src) %{
//     format %{ "FCVTFX $dst=$src\t// long -> extended" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct convL2D_xxx_3(fRegD dst, fRegD src) %{
//     format %{ "FNORMD $dst=$src\t// extended -> double" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fnormD_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FMAC_fr);
//   %}
// 
// instruct convL2D_stk(fRegD dst, stackSlotL src) %{
//   match(Set dst (ConvL2D src));
//   ins_cost(FP_MEMORY_READ_COST + (FP_OP_COST * 2));
//   effect(USE src);
// 
//   expand %{
//     fRegD tmp1; fRegD tmp2;
//     convL2D_stk_1(tmp1, src);
//     convL2D_xxx_2(tmp2, tmp1);
//     convL2D_xxx_3(dst,  tmp2);
//   %}
// %}
// 
//   instruct convL2D_reg_1(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
// 
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
// instruct convL2D_reg(fRegD dst, gRegL src) %{
//   match(Set dst (ConvL2D src));
//   ins_cost(FP_MEMORY_READ_COST + (FP_OP_COST * 2));
//   effect(USE src);
// 
//   expand %{
//     fRegD tmp1; fRegD tmp2;
//     convL2D_reg_1(tmp1, src);
//     convL2D_xxx_2(tmp2, tmp1);
//     convL2D_xxx_3(dst,  tmp2);
//   %}
// %}

instruct convL2D_reg(fRegD dst, gRegL src) %{
  match(Set dst (ConvL2D src));
  ins_cost(FP_MEMORY_READ_COST + FP_OP_COST * 2);

  format %{ "SETF.SIG $dst=$src\t// Begin Convert Long->Double\n"
          "\tFCVTXF $dst=$dst\n"
          "\tFNORMD $dst=$dst\t// End   Convert Long->Double" %}

  ins_encode( emit_setfSIG_reg(dst, src, PR0),
              emit_fcvtXF_reg(dst, dst, PR0),
              emit_fnormD_reg(dst, dst, PR0) );

  ins_pipe(long_fp_op);
%}

// Convert Long -> Float
//   instruct convL2F_stk_1(fRegD dst, stackSlotL src, gr29_gRegP temp1) %{
//     format %{ "ADDR   GR29=$src ;;\n\tLDF8   $dst=[GR29]\t// long" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_ldf8_stack( dst, src ) );
//     ins_pipe(fr_LDF_mem);
//   %}
// 
//   instruct convL2F_xxx_2(fRegF dst, fRegD src) %{
//     format %{ "FCVTFX $dst=$src\t// long -> extended" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fcvtXF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct convL2F_xxx_3(fRegF dst, fRegD src) %{
//     format %{ "FNORMF $dst=$src\t// extended -> float" %}
//     effect(DEF dst, USE src);
//     ins_encode( emit_fnormF_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FMAC_fr);
//   %}
// 
// instruct convL2F_stk(fRegF dst, stackSlotL src) %{
//   match(Set dst (ConvL2F src));
//   ins_cost(FP_MEMORY_READ_COST + (FP_OP_COST * 2));
//   effect(USE src);
// 
//   expand %{
//     fRegD tmp1; fRegD tmp2;
//     convL2F_stk_1(tmp1, src);
//     convL2F_xxx_2(tmp2, tmp1);
//     convL2F_xxx_3(dst,  tmp2);
//   %}
// %}
// 
//   instruct convL2F_reg_1(fRegD dst, gRegL src) %{
//     format %{ "SETF.SIG $dst=$src" %}
//     effect(DEF dst, USE src);
// 
//     ins_encode( emit_setfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
// instruct convL2F_reg(fRegF dst, gRegL src) %{
//   match(Set dst (ConvL2F src));
//   ins_cost(FP_MEMORY_READ_COST + (FP_OP_COST * 2));
//   effect(USE src);
// 
//   expand %{
//     fRegD tmp1; fRegD tmp2;
//     convL2F_reg_1(tmp1, src);
//     convL2F_xxx_2(tmp2, tmp1);
//     convL2F_xxx_3(dst,  tmp2);
//   %}
// %}

instruct convL2F_reg(fRegF dst, gRegL src) %{
  match(Set dst (ConvL2F src));
  ins_cost(FP_MEMORY_READ_COST + FP_OP_COST * 2);

  format %{ "SETF.SIG $dst=$src\t// Begin Convert Long->Float\n"
          "\tFCVTXF $dst=$dst\n"
          "\tFNORMF $dst=$dst\t// End   Convert Long->Float" %}

  ins_encode( emit_setfSIG_reg(dst, src, PR0),
              emit_fcvtXF_reg(dst, dst, PR0),
              emit_fnormF_reg(dst, dst, PR0) );

  ins_pipe(long_fp_op);
%}

// Convert Long -> Integer
//  Note: the sign-extend is not really needed, as only the lower 32 bits
//        are valid, but a sign extend and a move cost the same.
instruct convL2I_reg(gRegI dst, gRegL src) %{
  match(Set dst (ConvL2I src));
  format %{ "SXT4   $dst=$src\t\t// long->int" %}
  ins_encode( emit_sxt4_reg( dst, src, PR0 ) );
  ins_pipe(gr_XTD_gr);
%}

// The following code is derived from code provided by Hewlett-Packard
//
//     if (isnan((double)f))
//       return 0;
//     else {
//       int64_t ltmp = (int64_t)f;
//       int32_t itmp = (int32_t)ltmp;
//       if (ltmp == lltmp)
//         return ltmp;
//       else if (f < 0)
//         return 0x800000000;
//       else
//         return 0x7ffffffff;
//       }
//     }

//   instruct convD2I_1(pReg pTrue, pReg pFalse, fRegD src) %{
//     effect(DEF pTrue, DEF pFalse, USE src);
//     format %{ "FCMP.UNORD $src,$src,$pTrue,$pFalse" %}
//     ins_encode( emit_fcmp_unord( pTrue, pFalse, src, src, PR0 ) );
//     ins_pipe(pr_pr_FCMP_fr_fr);
//   %}
// 
//   instruct convD2I_2(gRegL dst, pReg qp) %{
//     effect(DEF dst, USE qp);
//     format %{ "($qp) MOV    GR0,$dst" %}
//     ins_encode( emit_mov_reg( dst, GR0, qp ) );
//     ins_pipe(gr_IALU_pr);
//   %}
// 
//   instruct convD2I_3(fRegD dst, fRegD src, pReg qp) %{
//     effect(DEF dst, USE src, USE qp);
//     format %{ "($qp) FCVT.FX.TRUNC $dst=$src\t// float->long" %}
//     ins_encode( emit_fcvtFXTrunc_reg( dst, src, qp ) );
//     ins_pipe(fr_FCVTFX_fr_pr);
//   %}
// 
//   instruct convD2I_4(gRegL dst, fRegD src, pReg qp) %{
//     effect(DEF dst, USE src, USE qp);
//     format %{ "GETF.SIG $dst=$src" %}
//     ins_encode( emit_getfSIG_reg( dst, src, qp ) );
//     ins_pipe(gr_FRFR_fr_pr);
//   %}
// 
//   instruct convD2I_5(gRegL dst, gRegL src, pReg qp) %{
//     effect(USE_DEF dst, USE src, USE qp);
//     format %{ "SXT4   $dst=$src\t\t// long->int" %}
//     ins_encode( emit_sxt4_reg(dst, src, qp) );
//     ins_pipe(gr_XTD_gr_pr);
//   %}
// 
//   instruct convD2I_6(pReg pTrue, gRegL src1, gRegL src2, pReg qp) %{
//     effect(DEF pTrue, USE src1, USE src2, USE qp);
//     format %{ "($qp) CMP4.EQ $src1,$src2,$pTrue,PR0" %}
//     ins_encode( emit_cmp_eq_unc_reg_reg( pTrue, PR0, src1, src2, qp ) );
//     ins_pipe(pr_ICMP_gr_gr_pr);
//   %}
// 
//   instruct convD2I_7(pReg pTrue, pReg pFalse, fRegD src, pReg qp) %{
//     effect(DEF pTrue, DEF pFalse, USE src, USE qp);
//     format %{ "($qp) FCMP.LE.UNC $src,FR0,$pTrue,$pFalse" %}
//     ins_encode( emit_fcmp_le_unc( pTrue, pFalse, src, FR0, PR0 ) );
//     ins_pipe(pr_pr_FCMP_fr_pr);
//   %}
// 
//   instruct convD2I_8(gRegI dst, pReg pTrue, pReg pFalse) %{
//     effect(USE_DEF dst, USE pTrue, USE pFalse);
//     format %{ "($pTrue) MOVL 0x7fffffff,$src\n\t"
//               "($pFalse) MOVL 0x80000000,$src" %}
//     ins_encode( emit_movl_max_int( dst, pTrue ), emit_movl_min_int( dst, pFalse ) );
//     ins_pipe(gr_LONG_I_pr__gr_LONG_I_pr);
//   %}
// 
// instruct convD2I(gRegI dst, fRegD src) %{
//   match(Set dst (ConvD2I src));
//   ins_cost(FP_CMP_COST + DEFAULT_COST + FP_OP_COST + FP_MEMORY_WRITE_COST);
//   expand %{
//     pReg unord; pReg ord; pReg ovfl; pReg pos; pReg neg;
//     fRegD ftmp1;
//     gRegL tmp2; gRegL tmp3;
//     convD2I_1(unord, ord, src);
//     convD2I_2(dst, unord);
//     convD2I_3(ftmp1, src, ord);
//     convD2I_4(tmp2, src, ord);
//     convD2I_5(dst, tmp2, ord);
//     convD2I_6(ovfl, dst, tmp2, ord);
//     convD2I_7(pos, neg, src, ord);
//     convD2I_8(dst, pos, neg);
//   %}
// %}

// We will do this in one node because expand does not handle multiple
// outputs at this time. This will hopefully be rectified in the future.
instruct convD2I(gRegI dst, fRegD_notmp15 src, fr15_fRegD fr15, gr30_gRegL gr30, pr6_pReg p6, pr7_pReg p7, pr8_pReg p8, pr9_pReg p9, pr10_pReg p10) %{
  match(Set dst (ConvD2I src));
  effect(KILL fr15, KILL gr30, KILL p6, KILL p7, KILL p8, KILL p9, KILL p10);

  format %{ "FCMP.UNORD PR6,PR7=$src,$src\n\t"
            "(PR6) MOV $dst=GR0\n\t"
            "(PR7) FCVT.FX.TRUNC FR15=$src ;;\n\t"
            "(PR7) GETF.SIG $dst=FR15\n\t"
            "(PR7) SXT4   GR30=$dst ;;\n\t"
            "(PR7) CMP4.EQ.UNC PR0,PR8=$dst,GR30 ;;\n\t"
            "(PR8) FCMP.LE.UNC PR10,PR9=$src,FR0 ;;\n\t"
            "(PR9) MOVL $dst=0x7fffffff\n\t"
            "(PR10) MOVL $dst=0x80000000" %}

  ins_encode( emit_fcmp_unord( PR6, PR7, src, src, PR0 ),
              emit_mov_reg( dst, GR0, PR6 ),
              emit_fcvtFXTrunc_reg( FR15, src, PR7 ),
              emit_getfSIG_reg( dst , FR15, PR7 ),
              emit_sxt4_reg( GR30, dst, PR7 ),
              emit_cmp_eq_unc_reg_reg( PR0, PR8, dst, GR30, PR7 ),
              emit_fcmp_le_unc( PR10, PR9, src, FR0, PR8 ),
              emit_movl_min_int( dst, PR10 ),
              emit_movl_max_int( dst, PR9 ) );

  ins_pipe(convD2I_pipe);
%}

// Convert Float to Integer is the same as convert Double to Integer
instruct convF2I(gRegI dst, fRegF_notmp15 src, fr15_fRegD fr15, gr30_gRegL gr30, pr6_pReg p6, pr7_pReg p7, pr8_pReg p8, pr9_pReg p9, pr10_pReg p10) %{
  match(Set dst (ConvF2I src));
  effect(KILL fr15, KILL gr30, KILL p6, KILL p7, KILL p8, KILL p9, KILL p10);

  format %{ "FCMP.UNORD PR6,PR7=$src,$src\t// Convert Float to Integer\n\t"
            "(PR6) MOV    GR0,$dst ;;\n\t"
            "(PR7) FCVT.FX.TRUNC $src,FR15 ;;\n\t"
            "(PR7) GETF.SIG FR15,$dst ;;\n\t"
            "(PR7) SXT4   GR30=$dst ;;\n\t"
            "(PR7) CMP.EQ.UNC PR0,PR8=$dst,GR30 ;;\n\t"
            "(PR8) FCMP.LE.UNC PR10,PR9=$src,FR0 ;;\n\t"
            "(PR9) MOVL $dst=0x7fffffff\n\t"
            "(PR10) MOVL $dst=0x80000000" %}

  ins_encode( emit_fcmp_unord( PR6, PR7, src, src, PR0 ),
              emit_mov_reg( dst, GR0, PR6 ),
              emit_fcvtFXTrunc_reg( FR15, src, PR7 ),
              emit_getfSIG_reg( dst, FR15, PR7 ),
              emit_sxt4_reg( GR30, dst, PR7 ),
              emit_cmp_eq_unc_reg_reg( PR0, PR8, dst, GR30, PR7 ),
              emit_fcmp_le_unc( PR10, PR9, src, FR0, PR8 ),
              emit_movl_min_int( dst, PR10 ),
              emit_movl_max_int( dst, PR9 ) );

  ins_pipe(convD2I_pipe);
%}

// The following code is derived from code provided by Hewlett-Packard
//
//     if (isnan((double)f))
//       return 0;
//     else {
//       int64_t ltmp = (int64_t)f;
//       if (ltmp != 0x8000000000000000)
//         return ltmp;
//       else if (f < 0)
//         return 0x8000000000000000;
//       else
//         return 0x7fffffffffffffff;
//       }
//     }

instruct convD2L(gRegL dst, fRegD_notmp15 src, fr15_fRegD fr15, gr30_gRegL gr30, pr6_pReg p6, pr7_pReg p7, pr8_pReg p8, pr9_pReg p9, pr10_pReg p10) %{
  match(Set dst (ConvD2L src));
  effect(KILL fr15, KILL gr30, KILL p6, KILL p7, KILL p8, KILL p9, KILL p10);

  format %{ "FCMP.UNORD PR6,PR7=$src,$src\t// Convert Double to Long\n\t"
            "(PR6) MOV  dst=GR0 ;;\n\t"
            "(PR7) FCVT.FX.TRUNC FR15=$src ;;\n\t"
            "(PR7) GETF.SIG $dst=FR15\n\t"
            "(PR7) MOVL GR30=0x8000000000000000 ;;\n\t"
            "(PR7) CMP4.EQ.UNC PR8,PR0=$dst,GR30 ;;\n\t"
            "(PR8) FCMP.LE.UNC PR10,PR9=$src,FR0 ;;\n\t"
            "(PR9) MOVL $dst=0x7fffffffffffffff\n\t"
            "(PR10) MOV $dst=GR30" %}

  ins_encode( emit_fcmp_unord( PR6, PR7, src, src, PR0 ),
              emit_mov_reg( dst, GR0, PR6 ),
              emit_fcvtFXTrunc_reg( FR15, src, PR7 ),
              emit_getfSIG_reg( dst , FR15, PR7 ),
              emit_movl_min_long( GR30, PR7 ),
              emit_cmp_eq_unc_reg_reg( PR8, PR0, dst, GR30, PR7 ),
              emit_fcmp_le_unc( PR10, PR9, src, FR0, PR8 ),
              emit_movl_max_long( dst, PR9 ),
              emit_mov_reg( dst, GR30, PR10 ) );

  ins_pipe(convD2I_pipe);
%}

instruct convF2L(gRegL dst, fRegF_notmp15 src, fr15_fRegD fr15, gr30_gRegL gr30, pr6_pReg p6, pr7_pReg p7, pr8_pReg p8, pr9_pReg p9, pr10_pReg p10) %{
  match(Set dst (ConvF2L src));
  effect(DEF dst, USE src, KILL fr15, KILL gr30, KILL p6, KILL p7, KILL p8, KILL p9, KILL p10);

  format %{ "FCMP.UNORD PR6,PR7=$src,$src\t// Convert Float to Long\n\t"
            "(PR6) MOV  $dst=GR0 ;;\n\t"
            "(PR7) FCVT.FX.TRUNC FR15=$src ;;\n\t"
            "(PR7) GETF.SIG $dst=FR15\n\t"
            "(PR7) MOVL GR30=0x8000000000000000 ;;\n\t"
            "(PR7) CMP4.EQ.UNC PR8,PR0=$dst,GR30 ;;\n\t"
            "(PR8) FCMP.LE.UNC PR10,PR9=$src,FR0 ;;\n\t"
            "(PR9) MOVL $dst=0x7fffffffffffffff\n\t"
            "(PR10) MOV  $dst=GR30" %}

  ins_encode( emit_fcmp_unord( PR6, PR7, src, src, PR0 ),
              emit_mov_reg( dst, GR0, PR6 ),
              emit_fcvtFXTrunc_reg( FR15, src, PR7 ),
              emit_getfSIG_reg( dst, FR15, PR7 ),
              emit_movl_min_long( GR30, PR7 ),
              emit_cmp_eq_unc_reg_reg( PR8, PR0, dst, GR30, PR7 ),
              emit_fcmp_le_unc( PR10, PR9, src, FR0, PR8 ),
              emit_movl_max_long( dst, PR9 ),
              emit_mov_reg( dst, GR30, PR10 ) );

  ins_pipe(convD2I_pipe);
%}

// Convert Float -> Long
//   instruct convF2L_xxx_1(fRegD dst, fRegF src) %{
//     effect(DEF dst, USE src);
//     format %{ "FCVT.FX.TRUNC $dst=$src\t// float->long" %}
//     ins_encode( emit_fcvtFXTrunc_reg( dst, src, PR0 ) );
//     ins_pipe(fr_FCVTFX_fr);
//   %}
// 
//   instruct convF2L_reg_2(gRegL dst, fRegD src) %{
//     effect(DEF dst, USE src);
//     format %{ "GETF.SIG $dst=$src" %}
//     ins_encode( emit_getfSIG_reg( dst, src, PR0 ) );
//     ins_pipe(fr_TOFR_gr);
//   %}
// 
// instruct convF2L_reg(gRegL dst, fRegD src) %{
//   match(Set dst (ConvD2L src));
//   ins_cost(FP_OP_COST + FP_MEMORY_WRITE_COST);
//   expand %{
//     fRegD tmp1;
//     convF2L_xxx_1(tmp1, src);
//     convF2L_reg_2(dst, tmp1);
//   %}
// %}

instruct convF2L_reg(gRegL dst, fRegD_notmp15 src, fr15_fRegD fr15) %{
  match(Set dst (ConvD2L src));
  effect(KILL fr15);
  ins_cost(FP_OP_COST + FP_MEMORY_WRITE_COST);

  format %{ "FCVT.FX.TRUNC FR15=$src\t// Begin Float->Long\n"
          "\tGETF.SIG $dst=FR15\t\t// End   Float->Long" %}

  ins_encode( emit_fcvtFXTrunc_reg( FR15, src, PR0 ),
              emit_getfSIG_reg( dst, FR15, PR0 ) );

  ins_pipe(long_fp_op);
%}


instruct MoveF2I_stack_reg(gRegI dst, stackSlotF src) %{
  match(Set dst (MoveF2I src));
  effect(DEF dst, USE src);

  ins_cost(INT_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n\t"
            "LD4    $dst=[GR29]\t// MoveF2I_stack_reg" %}
  ins_encode( emit_ld4_stack( dst, src ) );
  ins_pipe(gr_LD_mem);
%}

instruct MoveF2I_reg_stack(stackSlotI dst, fRegF src) %{
  match(Set dst (MoveF2I src));
  effect(DEF dst, USE src);

  ins_cost(FP_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n\t"
            "STFS   [GR29]=$src\t// MoveF2I_reg_stack" %}
  ins_encode( emit_stfs_stack( dst, src ) );
  ins_pipe(mem_STF_fr);
%}

instruct MoveI2F_stack_reg(fRegF dst, stackSlotI src) %{
  match(Set dst (MoveI2F src));
  effect(DEF dst, USE src);

  ins_cost(FP_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n\t"
            "LDFS   $dst=[GR29]\t// MoveI2F_stack_reg" %}
  ins_encode( emit_ldfs_stack( dst, src ) );
  ins_pipe(fr_LDF_mem);
%}

instruct MoveI2F_reg_stack(stackSlotF dst, gRegI src) %{
  match(Set dst (MoveI2F src));
  effect(DEF dst, USE src);

  ins_cost(INT_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n\t"
            "ST4    [GR29]=$src\t// MoveI2F_stack_reg" %}
  ins_encode( emit_st4_stack( dst, src ) );
  ins_pipe(mem_ST_gr);
%}

instruct MoveD2L_stack_reg(gRegL dst, stackSlotD src) %{
  match(Set dst (MoveD2L src));
  effect(DEF dst, USE src);

  ins_cost(INT_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n\t"
            "LD8    $dst=[GR29]\t// MoveD2L_stack_reg" %}
  ins_encode( emit_ld8_stack( dst, src ) );
  ins_pipe(gr_LD_mem);
%}

instruct MoveD2L_reg_stack(stackSlotL dst, fRegD src) %{
  match(Set dst (MoveD2L src));
  effect(DEF dst, USE src);

  ins_cost(FP_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n\t"
            "STFD   [GR29]=$src\t// MoveD2L_reg_stack" %}
  ins_encode( emit_stfd_stack( dst, src ) );
  ins_pipe(mem_STF_fr);
%}

instruct MoveL2D_stack_reg(fRegD dst, stackSlotL src) %{
  match(Set dst (MoveL2D src));
  effect(DEF dst, USE src);

  ins_cost(FP_MEMORY_READ_COST);
  format %{ "ADDS   GR29=$src ;;\n\t"
            "LDFD   $dst=[GR29]\t// MoveL2D_stack_reg" %}
  ins_encode( emit_ldfd_stack( dst, src ) );
  ins_pipe(fr_LDF_mem);
%}

instruct MoveL2D_reg_stack(stackSlotD dst, gRegL src) %{
  match(Set dst (MoveL2D src));
  effect(DEF dst, USE src);

  ins_cost(INT_MEMORY_WRITE_COST);
  format %{ "ADDS   GR29=$dst ;;\n\t"
            "ST8    [GR29]=$src\t// MoveL2D_reg_stack" %}
  ins_encode( emit_st8_stack( dst, src ) );
  ins_pipe(mem_ST_gr);
%}


//----------Absolute Value-----------------------------------------------------
// Absolute Value
//   instruct absI_reg_reg_1(pReg pr, gRegI src) %{
//     effect(DEF pr, USE src);
// 
//     format %{ "CMP.LT   GR0,$src,PR6/PR0" %}
//     ins_encode( emit_cmp4_reg_reg( Assembler::less, PR6, PR0, GR0, src, PR0 ) );
//     ins_pipe(pr_pr_ICMP_gr_gr);
//   %}
// 
//   instruct absI_reg_reg_2(gRegI dst, gRegI src) %{
//     effect(DEF dst, USE src);
//   
//     format %{ "mov    $dst=$src" %}
//     ins_encode( emit_mov_reg( dst, src, PR0 ) );
//     ins_pipe( gr_IALU_gr );
//   %}
// 
//   instruct absI_reg_reg_3(gRegI dst, gRegI src) %{
//     effect(DEF dst, USE src);
//   
//     format %{ "NEG    $dst=$src" %}
//     ins_encode( emit_negI_reg( dst, src, PR0 ) );
//     ins_pipe(gr_IALU_gr);
//   %}
// 
// instruct absI_reg_reg(gRegI dst, gRegI src) %{
//   match(Set dst (AbsI src));
//   ins_cost(DEFAULT_COST * 3);
//   effect(USE src);
// 
//   expand %{
//     pReg pr;
//     absI_reg_reg_1(pr,  src);
//     absI_reg_reg_2(dst, src);
//     absI_reg_reg_3(dst, src, pr);
//   %}
// %}

instruct absI_reg_reg(gRegI dst, gRegI src, pr6_pReg pr6, pr7_pReg pr7) %{
  match(Set dst (AbsI src));
  ins_cost(DEFAULT_COST * 3);
  effect(KILL pr6, KILL pr7);

  format %{ "CMP4.LT PR6,PR7=$src,GR0 ;;\n"
         "\t(PR6) MOV $dst=$src\n"
         "\t(PR7) NEG $dst=$src" %}

  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src, GR0, PR0 ),
              emit_mov_reg(  dst, src, PR6 ),
              emit_negI_reg( dst, src, PR7 ) );

  ins_pipe(pr_pr_ICMP_gr__gr_IALU_gr__gr_IALU_gr);
%}

//----------Max and Min--------------------------------------------------------
// Min Instructions
// Min Register with Register.
//   instruct minI_reg_reg_1(pReg pr, gRegI src1, gRegI src2) %{
//     effect(DEF pr, USE src1, USE src2);
//   
//     format %{ "CMP.LT PR6/PR0=$src1,$src2" %}
//     ins_encode( emit_cmp4_reg_reg( Assembler::less, PR6, PR0, src1, src2, PR0 ) );
//     ins_pipe(pr_pr_ICMP_gr_gr);
//   %}
// 
//   instruct minI_reg_reg_2(gRegI dst, gRegI src) %{
//     effect(DEF dst, USE src);
//   
//     format %{ "MOV    $dst=$src" %}
//     ins_encode( emit_mov_reg( dst, src, PR0 ) );
//     ins_pipe( gr_IALU_gr );
//   %}
// 
//   instruct minI_reg_reg_3(gRegI dst, gRegI src) %{
//     effect(DEF dst, USE src);
//   
//     format %{ "MOV    $dst=$src" %}
//     ins_encode( emit_mov_reg( dst, src, PR0 ) );
//     ins_pipe( gr_IALU_gr );
//   %}
// 
// instruct minI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
//   match(Set dst (MinI src1 src2));
//   ins_cost(DEFAULT_COST * 3);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     pReg pr;
//     minI_reg_reg_1(pr,  src1, src2, PR0);
//     minI_reg_reg_2(dst, src2, PR0);
//     minI_reg_reg_3(dst, src1, pr);
//   %}
// %}

instruct minI_reg_reg(gRegI dst, gRegI src1, gRegI src2, pr6_pReg pr6, pr7_pReg pr7) %{
  match(Set dst (MinI src1 src2));
  effect(KILL pr6, KILL pr7);
  ins_cost(DEFAULT_COST * 3);

  format %{ "CMP4.LT PR6,PR7=$src1,$src2\t// min\n"
          "\t(PR6) MOV $dst=$src1\n"
          "\t(PR7) MOV $dst=$src2" %}
  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src1, src2, PR0 ),
              emit_mov_reg( dst, src1, PR6 ),
              emit_mov_reg( dst, src2, PR7 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_gr);
%}

// Max Instructions
// Max Register with Register
//   instruct maxI_reg_reg_1(pReg pr, gRegI src1, gRegI src2) %{
//     effect(DEF pr, USE src1, USE src2);
//   
//     format %{ "CMP.LT   PR6,PR0=$src2,$src1" %}
//     ins_encode( emit_cmp4_reg_reg( Assembler::less, PR6, PR0, src2, src1, PR0 ) );
//     ins_pipe(pr_pr_ICMP_gr_gr);
//   %}
// 
//   instruct maxI_reg_reg_2(gRegI dst, gRegI src) %{
//     effect(DEF dst, USE src);
//   
//     format %{ "MOV    $dst=$src" %}
//     ins_encode( emit_mov_reg( dst, src, PR0 ) );
//     ins_pipe( gr_IALU_gr );
//   %}
// 
//   instruct maxI_reg_reg_3(gRegI dst, gRegI src) %{
//     effect(DEF dst, USE src);
//   
//     format %{ "MOV    $dst=$src" %}
//     ins_encode( emit_mov_reg( dst, src, PR0 ) );
//     ins_pipe( gr_IALU_gr );
//   %}
// 
// instruct maxI_reg_reg(gRegI dst, gRegI src1, gRegI src2) %{
//   match(Set dst (MinI src1 src2));
//   ins_cost(DEFAULT_COST * 3);
//   effect(USE src1, USE src2);
// 
//   expand %{
//     pReg pr;
//     maxI_reg_reg_1(pr,  src1, src2);
//     maxI_reg_reg_2(dst, src2);
//     maxI_reg_reg_3(dst, src1, pr);
//   %}
// %}

instruct maxI_reg_reg(gRegI dst, gRegI src1, gRegI src2, pr6_pReg pr6, pr7_pReg pr7) %{
  match(Set dst (MaxI src1 src2));
  effect(KILL pr6, KILL pr7);
  ins_cost(DEFAULT_COST * 3);

  format %{ "CMP4.LT PR6,PR7=$src1,$src2\t// max\n"
          "\t(PR7) MOV $dst=$src1\n"
          "\t(PR6) MOV $dst=$src2" %}

  ins_encode( emit_cmp4_lt_reg_reg( PR6, PR7, src1, src2, PR0 ),
              emit_mov_reg( dst, src1, PR7 ),
              emit_mov_reg( dst, src2, PR6 ) );

  ins_pipe(pr_pr_ICMP_gr_gr__gr_IALU_gr__gr_IALU_gr);
%}

//----------Branches---------------------------------------------------------
// Direct Branch
instruct branch(label labl) %{
  match(Goto);
  effect(USE labl);
  ins_cost(BRANCH_COST);

  format %{ "BR     $labl" %}
  ins_encode( emit_branch( labl, PR0 ) );
  ins_pc_relative(1);
  ins_pipe(BR_pr);
%}

// ============================================================================
// Long Compare
//
// Manifest a CmpL3 result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpL3_reg_reg(gRegI dst, gRegL src1, gRegL src2, pr6_pReg pr6, pr7_pReg pr7 ) %{
  match(Set dst (CmpL3 src1 src2) );
  effect(KILL pr6, KILL pr7);
  format %{ "MOV    $dst=GR0\n"
          "\tCMP.LT PR6,PR0=$src1,$src2 \n"
          "\tCMP.GT PR7,PR0=$src1,$src2 ;;\n"
          "\t(PR6) MOV $dst=#-1\n"
          "\t(PR7) MOV $dst=#1" %}
  ins_encode( emit_mov_reg( dst, GR0, PR0 ),
              emit_cmp_lt_reg_reg( PR6, PR0, src1, src2, PR0 ),
              emit_cmp_gt_reg_reg( PR7, PR0, src1, src2, PR0 ),
              emit_mov_imm_m1( dst, PR6 ),
              emit_mov_imm_1(  dst, PR7 ) );
  ins_pipe( gr_IALU_gr__pr_ICMP_gr_gr__pr_ICMP_gr_gr__gr_IALU_imm__gr_IALU_imm );
%}

// ============================================================================
// Float Compare
//
// Manifest a CmpF3 result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpF_reg_reg(gRegI dst, fRegF src1, fRegF src2, pr6_pReg pr6, pr7_pReg pr7, pr8_pReg pr8, pr9_pReg pr9 ) %{
  match(Set dst (CmpF3 src1 src2) );
  effect(KILL pr6, KILL pr7, KILL pr8, KILL pr9);

  format %{ "MOV   $dst=GR0\n"
          "\tFCMP.UNORD PR6,PR7=$src1,$src2 ;;\n"
          "\t(PR6) MOV $dst=-1\t#// unordered is less\n"
          "\t(PR7) FCMP.LT.UNC PR8=$src1,$src2\n"
          "\t(PR7) FCMP.GT.UNC PR9=$src1,$src2 ;;\n"
          "\t(PR8) MOV $dst=#-1\n"
          "\t(PR9) MOV $dst=#1" %}

  ins_encode( emit_mov_reg( dst, GR0, PR0 ),
              emit_fcmp_unord( PR6, PR7, src1, src2, PR0 ),
              emit_mov_imm_m1( dst, PR6 ),
              emit_fcmp_lt_unc( PR8, PR0, src1, src2, PR7 ),
              emit_fcmp_gt_unc( PR9, PR0, src1, src2, PR7 ),
              emit_mov_imm_m1( dst, PR8 ),
              emit_mov_imm_1(  dst, PR9 ) );

  ins_pipe( gr_IALU_imm__pr_pr_FCMP_fr_fr__gr_IALU_imm__pr_FCMP_fr_fr_pr__pr_FCMP_fr_fr_pr__gr_IALU_imm__gr_IALU_imm );
%}


// Manifest a CmpD3 result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpD_reg_reg(gRegI dst, fRegD src1, fRegD src2, pr6_pReg pr6, pr7_pReg pr7, pr8_pReg pr8, pr9_pReg pr9 ) %{
  match(Set dst (CmpD3 src1 src2) );
  effect(KILL pr6, KILL pr7, KILL pr8, KILL pr9);

  format %{ "MOV   $dst=GR0\n"
          "\tFCMP.UNORD PR6,PR7=$src1,$src2 ;;\n"
          "\t(PR6) MOV $dst=#-1\t// unordered is less\n"
          "\t(PR7) FCMP.LT.UNC PR8=$src1,$src2\n"
          "\t(PR7) FCMP.GT.UNC PR9=$src1,$src2 ;;\n"
          "\t(PR8) MOV $dst=#-1\n"
          "\t(PR9) MOV $dst=#1" %}

  ins_encode( emit_mov_reg( dst, GR0, PR0 ),
              emit_fcmp_unord( PR6, PR7, src1, src2, PR0 ),
              emit_mov_imm_m1( dst, PR6 ),
              emit_fcmp_lt_unc( PR8, PR0, src1, src2, PR7 ),
              emit_fcmp_gt_unc( PR9, PR0, src1, src2, PR7 ),
              emit_mov_imm_m1( dst, PR8 ),
              emit_mov_imm_1(  dst, PR9 ) );

  ins_pipe( gr_IALU_imm__pr_pr_FCMP_fr_fr__gr_IALU_imm__pr_FCMP_fr_fr_pr__pr_FCMP_fr_fr_pr__gr_IALU_imm__gr_IALU_imm );
%}


//----------Control Flow Instructions------------------------------------------
// Compare-and-Branch
// Integer branch
instruct if_cmpI_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pr6_pReg pr6) %{
  match(If cmp (CmpI src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr6);
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\n"
         "\t(PR6) BR $labl" %}

  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, src1, src2, PR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe(pr_pr_ICMP_gr_gr__BR_pr);
%}

// Integer branch on equal or not equal
instruct if_cmpI_reg_immI8(cmpOp cmp, gRegI src1, immI8 src2, label labl, pr6_pReg pr6) %{
  match(If cmp (CmpI src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr6);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Integer branch on less than, greater than or equal to
instruct if_cmpI_reg_immI8m1(cmpOp cmp, gRegI src1, immI8m1 src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpI src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Unsigned branch
instruct if_cmpU_reg_reg(cmpOpU cmp, gRegI src1, gRegI src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpU src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\t// unsigned\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4u_reg_reg( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__BR_pr);
%}

// Unsigned branch on equal or not equal
instruct if_cmpU_reg_immI8(cmpOpU cmp, gRegI src1, immI8 src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpU src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\t// unsigned\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4u_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Unsigned branch on less than, greater than or equal to
instruct if_cmpU_reg_immI8m1(cmpOpU cmp, gRegI src1, immI8m1 src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpU src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\t// unsigned\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4u_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Long branch on equal
instruct if_cmpL_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpL src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP.$cmp PR6,PR0=$src1,$src2\t// long\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__BR_pr);
%}

instruct if_cmpL_reg_immL8(cmpOp cmp, gRegL src1, immL8 src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpL src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq || 
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne || 
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt || 
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP.$cmp PR6,PR0=$src1,$src2\t// long\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Long branch on less than
instruct if_cmpL_reg_immL8m1(cmpOp cmp, gRegL src1, immL8m1 src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpL src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt || 
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP.$cmp PR6,PR0=$src1,$src2\t// long\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_branch( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Pointer Compares
instruct if_cmpP_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpP src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);

  ins_cost(BRANCH_COST + DEFAULT_COST);
  format %{ "CMP.$cmp PR6,PR0=$src1,$src2\t// ptr\n"
         "\t(PR6) BR $labl" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, src1, src2, PR0 ),
              emit_branch( labl, PR6 ) );
  ins_pipe( pr_pr_ICMP_gr_gr__BR_pr );
%}

instruct if_cmpP_reg_zero(cmpOpU cmp, gRegP src1, immP0 src2, label labl, pr6_pReg pr) %{
  match(If cmp (CmpP src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP.$cmp PR6,PR0=$src1,GR0\t// ptr\n"
         "\t(PR6) BR $labl" %}
  ins_encode( emit_cmp_reg_reg( cmp, PR6, PR0, src1, GR0, PR0 ),
              emit_branch( labl, PR6 ) );
  ins_pipe( pr_pr_ICMP_gr_gr__BR_pr );
%}

// Float Compares
// Float branch on equal
instruct if_cmpF_eq(cmpOp cmp, fRegF src1, fRegF src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR0,PR6=$src1,$src2 ;;\n"
          "\t(PR6) FCMP.EQ PR6,PR0=$src1,$src2\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpF_eq_zero(cmpOp cmp, fRegF src1, immF_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR0,PR6=$src1,FR0 ;;\n"
          "\t(PR6) FCMP.EQ PR6,PR0=$src1,FR0\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, FR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

instruct if_cmpF_ne(cmpOp cmp, fRegF src1, fRegF src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR6,PR7=$src1,$src2 ;;\n"
          "\t(PR7) FCMP.NE PR6,PR0=$src1,$src2\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpF_ne_zero(cmpOp cmp, fRegF src1, immF_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR6,PR7=$src1,FR0 ;;\n"
          "\t(PR7) FCMP.NE PR6,PR0=$src1,FR0\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, FR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

// Float branch on less than, or less than or equal
instruct if_cmpF_lt_le(cmpOp cmp, fRegF src1, fRegF src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR6,PR7=$src1,$src2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$src1,$src2 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpF_lt_le_zero(cmpOp cmp, fRegF src1, immF_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR6,PR7=$src1,FR0 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$src1,FR0 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, src1, FR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

// Float branch on greater than, or greater than or equal
instruct if_cmpF_gt_ge(cmpOp cmp, fRegF src1, fRegF src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR0,PR6=$src1,$src2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$src1,$src2 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpF_gt_ge_zero(cmpOp cmp, fRegF src1, immF_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpF src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR0,PR6=$src1,FR0 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$src1,FR0 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

// Double branch on equal
instruct if_cmpD_eq(cmpOp cmp, fRegD src1, fRegD src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR0,PR6=$src1,$src2 ;;\n"
          "\t(PR6) FCMP.EQ PR6,PR0=$src1,$src2\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpD_eq_zero(cmpOp cmp, fRegD src1, immD_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR0,PR6=$src1,FR0 ;;\n"
          "\t(PR6) FCMP.EQ PR6,PR0=$src1,FR0\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, FR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

instruct if_cmpD_ne(cmpOp cmp, fRegD src1, fRegD src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR6,PR7=$src1,$src2 ;;\n"
          "\t(PR7) FCMP.NE PR6,PR0=$src1,$src2\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpD_ne_zero(cmpOp cmp, fRegD src1, immD_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR6,PR7=$src1,FR0 ;;\n"
          "\t(PR7) FCMP.NE PR6,PR0=$src1,FR0\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_eq_ne_with_unordered( cmp, PR6, PR7, src1, FR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

// Double branch on less than, or less than or equal
instruct if_cmpD_lt_le(cmpOp cmp, fRegD src1, fRegD src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR6,PR7=$src1,$src2 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$src1,$src2 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpD_lt_le_zero(cmpOp cmp, fRegD src1, immD_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR6,PR7=$src1,FR0 ;;\n"
          "\t(PR7) FCMP.$cmp PR6,PR0=$src1,FR0 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_lt_le_with_unordered( cmp, PR6, PR7, src1, FR0 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}

// Double branch on greater than, or greater than or equal
instruct if_cmpD_gt_ge(cmpOp cmp, fRegD src1, fRegD src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2);

  format %{ "FCMP.UNORD PR0,PR6=$src1,$src2 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$src1,$src2 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_fr__pr_FCMP_fr_fr_pr__BR_pr );
%}

instruct if_cmpD_gt_ge_zero(cmpOp cmp, fRegD src1, immD_0 src2, label labl, pr6_pReg pr6, pr7_pReg pr7) %{
  match(If cmp (CmpD src1 src2));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt ||
             _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  effect(USE labl, KILL pr6, KILL pr7);
  ins_cost(BRANCH_COST + FP_CMP_COST * 2 - 1);

  format %{ "FCMP.UNORD PR0,PR6=$src1,FR0 ;;\n"
          "\t(PR6) FCMP.$cmp PR6,PR0=$src1,FR0 ;;\n"
          "\t(PR6) BR $labl" %}

  ins_encode( emit_fcmp_gt_ge_with_unordered( cmp, PR6, PR7, src1, src2 ),
              emit_branch( labl, PR6 ) );

  ins_pipe( pr_FCMP_fr_imm__pr_FCMP_fr_imm_pr__BR_pr );
%}


// Loop End 
// Integer branch on equal
instruct loop_cmpI_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pr6_pReg pr) %{
  match(CountedLoopEnd cmp (CmpI src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4_reg_reg( cmp, PR6, PR0, src1, src2, PR0 ), emit_loop_end( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__BR_pr);
%}

instruct loop_cmpI_reg_immI8(cmpOp cmp, gRegI src1, immI8 src2, label labl, pr6_pReg pr) %{
  match(CountedLoopEnd cmp (CmpI src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_loop_end( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Integer end loop on less than, greater than or equal to
instruct loop_cmpI_reg_immI8m1(cmpOp cmp, gRegI src1, immI8m1 src2, label labl, pr6_pReg pr) %{
  match(CountedLoopEnd cmp (CmpI src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_loop_end( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Unsigned branch on equal
instruct loop_cmpU_reg_reg(cmpOpU cmp, gRegI src1, gRegI src2, label labl, pr6_pReg pr) %{
  match(CountedLoopEnd cmp (CmpU src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\t// unsigned\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4u_reg_reg( cmp, PR6, PR0, src1, src2, PR0 ), emit_loop_end( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_gr__BR_pr);
%}

instruct loop_cmpU_reg_immI8(cmpOpU cmp, gRegI src1, immI8 src2, label labl, pr6_pReg pr) %{
  match(CountedLoopEnd cmp (CmpU src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\t// unsigned\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4u_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_loop_end( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}

// Unsigned end loop on less than, greater than or equal to
instruct loop_cmpU_reg_immI8m1(cmpOpU cmp, gRegI src1, immI8m1 src2, label labl, pr6_pReg pr) %{
  match(CountedLoopEnd cmp (CmpU src1 src2));
  effect(USE cmp, USE src1, USE src2, USE labl, KILL pr);
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt || _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
  ins_cost(BRANCH_COST + DEFAULT_COST);

  format %{ "CMP4.$cmp PR6,PR0=$src1,$src2\t// unsigned\n\t(PR6) BR $labl" %}
  ins_encode( emit_cmp4u_reg_imm( cmp, PR6, PR0, src1, src2, PR0 ), emit_loop_end( labl, PR6 ) );
  ins_pipe(pr_pr_ICMP_gr_imm__BR_pr);
%}


//********* RETAIN THIS FOR WHEN PREDICATE REGISTERS ARE ALLOCATED ***************
//
// instruct branchCond(label labl) %{
//   match(If);
//   predicate( false );
//   effect(USE labl);
//   ins_cost(BRANCH_COST);
// 
//   format %{ "BR $labl" %}
//   ins_encode( emit_branch( labl, PR0 ) );
//   ins_pc_relative(1);
//   ins_pipe(BR_pr);
// %}
//
// //----------Compare Instructions-----------------------------------------------
// // Integer Compare Instructions
// instruct cmpI_eq_gRegI_gRegI(pReg pr, gRegI src1, gRegI src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP4.EQ PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_reg( Assembler::equal, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpI_ne_gRegI_gRegI(pReg pr, gRegI src1, gRegI src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP4.NE PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_reg( Assembler::notEqual, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpI_lt_gRegI_gRegI(pReg pr, gRegI src1, gRegI src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP4.LT PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_reg( Assembler::less, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpI_gt_gRegI_gRegI(pReg pr, gRegI src1, gRegI src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP4.GT PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_reg( Assembler::greater, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpI_le_gRegI_gRegI(pReg pr, gRegI src1, gRegI src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP4.LE PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_reg( Assembler::less, PR6, PR0, src2, src1, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpI_ge_gRegI_gRegI(pReg pr, gRegI src1, gRegI src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP4.GE PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_reg( Assembler::greaterEqual, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpI_eq_gRegI_immI8(pReg pr, gRegI src1, immI8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.EQ   PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_immI8( BoolTest::eq, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpI_ne_gRegI_immI8(pReg pr, gRegI src1, immI8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.NE   PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_immI8( BoolTest::ne, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpI_lt_gRegI_immI8m1(pReg pr, gRegI src1, immI8m1 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LT   PR6,PR0=$src1,$src1" %}
//   ins_encode( emit_cmp4_reg_immI8m1( BoolTest::lt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpI_gt_gRegI_immI8(pReg pr, gRegI src1, immI8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GT   PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_immI8( BoolTest::gt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpI_le_gRegI_immI8(pReg pr, gRegI src1, immI8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LE   PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_immI8( BoolTest::le, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpI_ge_gRegI_immI8m1(pReg pr, gRegI src1, immI8m1 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GE   PR6,PR0=$src1,$src2" %}
//   ins_encode( emit_cmp4_reg_imm( BoolTest::ge, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// // Long Compare Instructions
// instruct cmpL_eq_gRegL_gRegL(pReg pr, gRegL src1, gRegL src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.EQ   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::eq, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpL_ne_gRegL_gRegL(pReg pr, gRegL src1, gRegL src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.NE   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::ne, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpL_lt_gRegL_gRegL(pReg pr, gRegL src1, gRegL src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LT   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::lt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpL_gt_gRegL_gRegL(pReg pr, gRegL src1, gRegL src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GT   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::gt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpL_le_gRegL_gRegL(pReg pr, gRegL src1, gRegL src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LE   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::le, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpL_ge_gRegL_gRegL(pReg pr, gRegL src1, gRegL src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GE   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::ge, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpL_eq_gRegL_immL8(pReg pr, gRegL src1, immL8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.EQ   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::eq, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpL_ne_gRegL_immL8(pReg pr, gRegL src1, immL8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.NE   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::ne, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpL_lt_gRegL_immL8m1(pReg pr, gRegL src1, immL8m1 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LT   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::lt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpL_gt_gRegL_immL8(pReg pr, gRegL src1, immL8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GT   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::gt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpL_le_gRegL_immL8(pReg pr, gRegL src1, immL8 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LE   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::le, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpL_ge_gRegL_immL8m1(pReg pr, gRegL src1, immL8m1 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GE   PR6,PR0=$src1,$src2\t// long" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::ge, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// // Pointer Compare Instructions
// instruct cmpP_eq_gRegP_gRegP(pReg pr, gRegP src1, gRegP src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.EQ   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::eq, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpP_ne_gRegP_gRegP(pReg pr, gRegP src1, gRegP src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.NE   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::ne, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpP_lt_gRegP_gRegP(pReg pr, gRegP src1, gRegP src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LT   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::lt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpP_gt_gRegP_gRegP(pReg pr, gRegP src1, gRegP src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GT   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::gt, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpP_le_gRegP_gRegP(pReg pr, gRegP src1, gRegP src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.LE   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::le, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpP_ge_gRegP_gRegP(pReg pr, gRegP src1, gRegP src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.GE   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_reg( BoolTest::ge, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_gr);
// %}
// 
// instruct cmpP_eq_gRegP_immP0(pReg pr, gRegP src1, immP0 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.EQ   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::eq, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}
// 
// instruct cmpP_ne_gRegP_immP0(pReg pr, gRegP src1, immP0 src2, pReg qp) %{
//   effect(DEF pr, USE src1, USE src2, USE qp);
// 
//   format %{ "($qp) CMP.NE   PR6,PR0=$src1,$src2\t// ptr" %}
//   ins_encode( emit_cmp_reg_imm( BoolTest::ne, PR6, PR0, src1, src2, qp ) );
//   ins_pipe(pr_pr_ICMP_gr_imm);
// %}

//
// //----------Control Flow Instructions------------------------------------------
// // Compare-and-Branch
// // Integer branch on equal
// instruct if_cmpI_eq_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_eq_gRegI_gRegI(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpI_eq_reg_imm(cmpOp cmp, gRegI src1, immI8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_eq_gRegI_immI8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Integer branch on not equal
// instruct if_cmpI_ne_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_ne_gRegI_gRegI(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpI_ne_reg_imm(cmpOp cmp, gRegI src1, immI8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_ne_gRegI_immI8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Integer branch on less than
// instruct if_cmpI_lt_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_lt_gRegI_gRegI(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpI_lt_reg_imm(cmpOp cmp, gRegI src1, immI8m1 src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_lt_gRegI_immI8m1(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Integer branch on greater than
// instruct if_cmpI_gt_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_gt_gRegI_gRegI(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpI_gt_reg_imm(cmpOp cmp, gRegI src1, immI8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_gt_gRegI_immI8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Integer branch on less than or equal to
// instruct if_cmpI_le_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_le_gRegI_gRegI(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpI_le_reg_imm(cmpOp cmp, gRegI src1, immI8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_le_gRegI_immI8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Integer branch on greater than or equal to
// instruct if_cmpI_ge_reg_reg(cmpOp cmp, gRegI src1, gRegI src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_ge_gRegI_gRegI(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpI_ge_reg_imm(cmpOp cmp, gRegI src1, immI8m1 src2, label labl, pReg qp) %{
//   match(If cmp (CmpI src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpI_ge_gRegI_immI8m1(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Long branch on equal
// instruct if_cmpL_eq_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_eq_gRegL_gRegL(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpL_eq_reg_imm(cmpOp cmp, gRegL src1, immL8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_eq_gRegL_immL8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Long branch on not equal
// instruct if_cmpL_ne_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_ne_gRegL_gRegL(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpL_ne_reg_imm(cmpOp cmp, gRegL src1, immL8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_ne_gRegL_immL8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Long branch on less than
// instruct if_cmpL_lt_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_lt_gRegL_gRegL(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpL_lt_reg_imm(cmpOp cmp, gRegL src1, immL8m1 src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_lt_gRegL_immL8m1(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Long branch on greater than
// instruct if_cmpL_gt_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_gt_gRegL_gRegL(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpL_gt_reg_imm(cmpOp cmp, gRegL src1, immL8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_gt_gRegL_immL8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Long branch on less than or equal to
// instruct if_cmpL_le_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_le_gRegL_gRegL(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpL_le_reg_imm(cmpOp cmp, gRegL src1, immL8 src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_le_gRegL_immL8(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Long branch on greater than or equal to
// instruct if_cmpL_ge_reg_reg(cmpOp cmp, gRegL src1, gRegL src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_ge_gRegL_gRegL(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpL_ge_reg_imm(cmpOp cmp, gRegL src1, immL8m1 src2, label labl, pReg qp) %{
//   match(If cmp (CmpL src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpL_ge_gRegL_immL8m1(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Pointer Compares
// // Pointer branch on equal
// instruct if_cmpP_eq_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_eq_gRegP_gRegP(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpP_eq_reg_imm(cmpOpU cmp, gRegP src1, immP0 src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::eq );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_eq_gRegP_immP0(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Pointer branch on not equal
// instruct if_cmpP_ne_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_ne_gRegP_gRegP(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// instruct if_cmpP_ne_reg_imm(cmpOpU cmp, gRegP src1, immP0 src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_ne_gRegP_immP0(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Pointer branch on less than
// instruct if_cmpP_lt_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::lt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_lt_gRegP_gRegP(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Pointer branch on greater than
// instruct if_cmpP_gt_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::gt );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_gt_gRegP_gRegP(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Pointer branch on less than or equal to
// instruct if_cmpP_le_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::le );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_le_gRegP_gRegP(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}
// 
// // Pointer branch on greater than or equal to
// instruct if_cmpP_ge_reg_reg(cmpOpU cmp, gRegP src1, gRegP src2, label labl, pReg qp) %{
//   match(If cmp (CmpP src1 src2));
//   effect(USE cmp, USE src1, USE src2, USE labl, USE qp);
//   predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ge );
// 
//   ins_cost(BRANCH_COST + DEFAULT_COST);
//   expand %{
//     pReg pr;
//     cmpP_ge_gRegP_gRegP(pr, src1, src2, qp);
//     branchCond(labl, pr);
//   %}
// %}

instruct safePoint_poll() %{
  match(SafePoint);
  format %{ "LD8 GR31_SCRATCH,[GR5_poll_page_addr]\t! Safepoint: poll for GC" %}
  ins_cost(INT_MEMORY_READ_COST);
  ins_encode( emit_safepoint_poll() );
  ins_pipe( gr_LD_mem );
%}


// ============================================================================
// Call Instructions
// Call Java Static Instruction
instruct CallStaticJavaDirect(method meth, gr29_gRegP gr29, call_bRegP br7, return_bRegP br0) %{
  match(CallStaticJava);
  effect(USE meth, KILL gr29, KILL br7, KILL br0);

  ins_cost(CALL_COST);
  format %{ "MOVL   GR29=$meth ;;\n"
          "\tMOV    BR7=GR29\t\t// int->branch\n"
          "\tBR.CALL BR7,BR0 ;;\t// static java" %}
  ins_encode( emit_java_static_call(meth, GR29, BR7), call_epilog );
  ins_pipe( pipeline_java_static_call );
%}

// Call Java Dynamic Instruction
instruct CallDynamicJavaDirect(method meth, inline_cache_gRegP inline_cache_gr, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp_gr) %{
  match(CallDynamicJava);
  effect(USE meth, KILL inline_cache_gr, KILL target_gr, KILL target_br, KILL save_rp_gr);
  ins_cost(CALL_COST);
  format %{ "MOVL   GR27=<inline cache>\t// inline cache\n"
          "\tMOVL   GR29=$meth ;;\t// method\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;;\t// dynamic java" %}
  ins_encode( emit_java_dynamic_call(meth, GR27, GR29, BR7, L2), call_epilog );
  ins_pipe( pipeline_java_dynamic_call );
%}

// Call Compiled Java Instruction
// Required: Used in converter frame from interpreter to compiler
instruct CallCompiledJavaDirect(method meth, inline_cache_gRegP oop_gr, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp_gr) %{
  // %%% See Intel version:  Do we need to declare a kill of interpreter_fp?
  match(CallCompiledJava);
  effect(USE meth, USE oop_gr, KILL target_gr, KILL target_br, KILL save_rp_gr);

  ins_cost(CALL_COST);
  format %{ "ADDS   GR29=GR27,#compiled_code_entry_offset ;;\t// address of method\n"
          "\tLD8    GR29=[GR29] ;;\t// load address of method\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 \t// compiled java" %}
  ins_encode( emit_compiled_call(GR27, GR29, BR7, L2), call_epilog );
  ins_pipe( pipeline_compiled_call );
%}

// Call Java Interpreter Instruction
instruct CallInterpreterDirect(method meth, o0RegP arg0, gr29_gRegP target_gr, call_bRegP target_br, Lsave_RP_gRegP save_rp) %{
  match(CallInterpreter);
  effect(USE meth, KILL arg0, KILL target_gr, KILL target_br, KILL save_rp);

  ins_cost(CALL_COST);
  format %{ "ADD    GR_O0=#arglist_size+8,GR12_SP ;;\t// start of argument list\n"
          "\tMOVL   GR29=$meth ;;\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;;\t// interpreter" %}
  ins_encode( emit_interpreter_call(meth, O0, GR29, BR7), call_epilog );
  ins_pipe( pipeline_interpreter_call );
%}

// Call Runtime Instruction
instruct CallRuntimeDirect(method meth, gr29_gRegP target_gr, call_bRegP target_br, gpRegP gp, gr2_gRegP gr2, gr3_gRegP gr3, Lsave_RP_gRegP save_rp_gr, Lsave_GP_gRegP save_gp_gr, Lsave_BSP_gRegP save_bsp_gr) %{
  match(CallRuntime);
  effect(USE meth, KILL target_gr, KILL target_br, KILL save_rp_gr, KILL gp, KILL gr2, KILL gr3, KILL save_gp_gr, KILL save_bsp_gr);

  ins_cost(CALL_COST);

  format %{ "ADD    GR2=GR4,#last_Java_pc_offset\n"
          "\tMOVL   GR3=.+96 ;;\n"
          "\tST8    [GR2]=GR3,#last_Java_fp_offset - #last_Java_pc_offset\n"
          "\tMOV    Lsave_BSP=AR.BSP\n"
          "\tMOV    Lsave_GP=GP ;;\n"
          "\tST8    [GR2]=Lsave_BSP,#last_Java_sp_offset - #last_Java_fp_offset\n"
          "\tMOVL   GP=<new gp> ;;\n"
          "\tST8    [GR2]=GR12_SP,ORDERED_RELEASE ;;\n"
          "\tMF     ;;\n"
          "\tMOVL   GR29=$meth ;;\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;; // runtime\n"
          "\tMOV    GP=GR_Lsave_GP\n" %}

  ins_encode( emit_runtime_call(meth, GR29, BR7, GR1_GP, GR2, GR3, L2, L5, L3), call_epilog );
  ins_pipe( pipe_runtime_call );
%}

// Call Native Instruction
instruct CallNativeDirect(method meth, gr29_gRegP gr, call_bRegP br, Lsave_RP_gRegP save_rp, gpRegP gp, gr2_gRegP gr2, gr3_gRegP gr3, Lsave_GP_gRegP save_gp, Lsave_BSP_gRegP save_bsp) %{
  match(CallNative);
  effect(USE meth, KILL gr, KILL br, KILL save_rp, KILL gp, KILL gr2, KILL gr3, KILL save_gp, KILL save_bsp);

  ins_cost(CALL_COST);
  format %{ "ADD    GR2=GR4,#last_Java_pc_offset\n"
          "\tMOVL   GR3=.+96 ;;\n"
          "\tST8    [GR2]=GR3,#last_Java_fp_offset - #last_Java_pc_offset\n"
          "\tMOV    Lsave_BSP=AR.BSP\n"
          "\tMOV    Lsave_GP=GP ;;\n"
          "\tST8    [GR2]=Lsave_BSP,#last_Java_sp_offset - #last_Java_fp_offset\n"
          "\tST8    [GR2]=GR12_SP,#thread_state_offset - #last_Java_sp_offset,ORDERED_RELEASE\n"
          "\tMOV    GR3,_thread_in_native ;;\n"
          "\tST4    [GR2]=GR3,ORDERED_RELEASE ;;\n"
          "\tMF     ;;\n"
          "\tMOVL   GR8=$meth ;;\n"
          "\tMOVL   GR29=jni_call_trampoline ;;\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;; // runtime\n"
          "\tMOV    GP=GR_Lsave_GP\n" %}
  ins_encode( emit_native_call(meth, GR29, BR7, L2, GR1_GP, GR2, GR3, L5, L3, GR8_RET), call_epilog );
  ins_pipe( pipe_native_call );
%}


// Call runtime without safepoint
instruct CallLeafDirect(method meth, gr29_gRegP target_gr, call_bRegP target_br, gpRegP gp, Lsave_RP_gRegP save_rp_gr, Lsave_GP_gRegP save_gp_gr) %{
  match(CallLeaf);
  effect(USE meth, KILL target_gr, KILL target_br, KILL gp, KILL save_rp_gr, KILL save_gp_gr);

  ins_cost(CALL_COST);
  format %{ "MOV    GR_Lsave_GP=GR1_GP ;;\n"
          "\tMOVL   GR29=$meth ;;\n"
          "\tMOVL   GR1_GP=<new gp>\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;;\t// leaf\n"
          "\tMOV    GR1_GP=GR_Lsave_GP" %}
  ins_encode( emit_simple_call(meth, GR29, BR7, GR1_GP, L5), call_epilog );
  ins_pipe( pipeline_simple_call );
%}

// Call runtime without safepoint - same as CallLeaf
instruct CallLeafNoFPDirect(method meth, gr29_gRegP target_gr, call_bRegP target_br, gpRegP gp, Lsave_RP_gRegP save_rp_gr, Lsave_GP_gRegP save_gp_gr) %{
  match(CallLeafNoFP);
  effect(USE meth, KILL target_gr, KILL target_br, KILL gp, KILL save_rp_gr, KILL save_gp_gr);

  ins_cost(CALL_COST);
  format %{ "MOV    GR_Lsave_GP=GR1_GP ;;\n"
          "\tMOVL   GR29=$meth ;;\n"
          "\tMOVL   GR1_GP=<new gp>\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;;\t// leaf nofp\n"
          "\tMOV    GR1_GP=GR_Lsave_GP" %}
  ins_encode( emit_simple_call(meth, GR29, BR7, GR1_GP, L5), call_epilog );
  ins_pipe( pipeline_simple_call );
%}

// Tail Call; Jump from runtime stub to Java code.
// Also known as an 'interprocedural jump'.
// Target of jump will eventually return to caller.
// TailJump below removes the return address.
instruct TailCalljmpInd(gRegP jump_target, inline_cache_gRegP method_oop, call_bRegP br, scratch_bRegP br_scratch) %{
  match(TailCall jump_target method_oop);
  effect(USE jump_target, KILL method_oop, KILL br, KILL br_scratch);

  ins_cost(CALL_COST);
  format %{ "MOV    BR7=$jump_target\t// pointer->branch\n"
          "\tBR     BR7" %}
  ins_encode( rematerialize_tls(), emit_mov_to_br(BR7, jump_target), emit_tail_call(BR7) );
  ins_pipe( pipeline_tail_call );
%}

// Return Instruction
instruct Ret() %{
  match(Return);

  format %{ "BR.RET BR0\t\t// return" %}
  ins_encode( emit_ret() );
  ins_pipe(BR_pr);
%}

// Tail Jump; remove the return address; jump to target.
//
// Actually we must return to target because we need to be in
// the window of the caller. We have already removed the stack
// we used in the epilog but unlike sparc (which did this by
// a restore AND changed windows) we can't get the windows changed
// until we do a return.
//
// TailCall above leaves the return address around.
// TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
// ex_oop (Exception Oop) is needed in r8 at the jump. Complicating matters
// is the fact that jump_target is a result of a call so the value is also
// in r8. 
// We also "know" that we got here after doing a call to find the jump_target
// that call will have left our return address in b0 which we then move
// to r9 where the exception blob will expect to find it.
// How the heck does the exception pc get to r9?
// gRegP
// instruct TailjmpInd(gRegP jump_target, inline_cache_gRegP ex_oop, call_bRegP br, scratch_bRegP br_scratch) %{
instruct TailjmpInd(gRegP jump_target, retRegP ex_oop, call_bRegP br, scratch_bRegP br_scratch) %{
  match( TailJump jump_target ex_oop );
  // effect(USE jump_target, KILL ex_oop, KILL br, KILL br_scratch);
  effect(USE jump_target, USE ex_oop, KILL br, KILL br_scratch);
  ins_cost(CALL_COST);
  format %{ "MOV    BR7=$jump_target\t// pointer->branch\n"
          "\tMOV    R8=$ex_oop\n"
          "\tMOV    R9=BR0\n"
          "\tBR     BR7" %}
  ins_encode( emit_mov_from_br(GR9, BR0), emit_mov_to_br(BR0, jump_target), emit_ret() );
  // ins_encode( emit_mov_from_br(GR9, BR0), emit_mov_to_br(BR0, jump_target), emit_mov_reg( GR8_RET, ex_oop, PR0 ), emit_ret() );
  // ins_encode( emit_mov_to_br(BR7, jump_target), emit_mov_reg( GR8_RET, ex_oop, PR0 ), emit_mov_from_br(GR9, BR0), emit_tail_call(BR7) );
  ins_pipe(pipeline_tail_jump);
%}

// Create exception oop: created by stack-crawling runtime code.
// Created exception is now available to this handler, and is setup
// just prior to jumping to this handler.  No code emitted.
instruct CreateException( retRegP ex_oop ) %{
  match(Set ex_oop (CreateEx));
  ins_cost(0);

  // use the following format syntax
  format %{ "// exception oop; no code emitted" %}
  ins_encode();
  ins_pipe(empty);
%}

// Rethrow exception: 
// The exception oop will come in the first argument position.
// Then JUMP (not call) to the rethrow stub code.
instruct RethrowException() %{
  match(Rethrow);
  ins_cost(CALL_COST);

  // use the following format syntax
  format %{ "MOVL   GR29=rethrow_stub ;;\n\t"
            "MOV    BR7=GR29\t\t// pointer->branch\n\t"
            "BR     BR7" %}
  ins_encode( emit_rethrow(GR29, BR7) );
  ins_pipe( pipeline_rethrow_exception );
%}


// Die now
instruct ShouldNotReachHere( ) %{
  match(Halt);
  ins_cost(CALL_COST);

  // Use the following format syntax
  format %{ "ILLTRAP \t!ShouldNotReachHere" %}
  ins_encode( emit_illtrap() );
  ins_pipe(long_memory_op);
%}

// ============================================================================
// The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary superklass
// array for an instance of the superklass.  Set a hidden internal cache on a
// hit (cache is checked with exposed code in gen_subtype_check()).  Return
// zero for a miss and not zero for a hit.
instruct partialSubtypeCheck( g8retRegI index, o0RegP sub, o1RegP super, gr29_gRegP target_gr, call_bRegP target_br, o2RegP o2, o3RegP o3, o4RegP o4, o5RegP o5, o6RegP o6, o7RegP o7 ) %{
  effect(KILL index, KILL sub, KILL super, KILL target_gr, KILL target_br, KILL o2, KILL o3, KILL o4, KILL o5, KILL o6, KILL o7);
  match(Set index (PartialSubtypeCheck sub super));

  ins_cost(CALL_COST);
  format %{ "MOVA   GR29=PartialSubtypeCheck ;;\n"
          "\tMOV    BR7=GR29\n"
          "\tBR.CALL BR7,BR0 ;;\t// PartialSubtypeCheck" %}
  ins_encode( emit_PartialSubtypeCheck(GR29, BR7) );
  ins_pipe(pipeline_partial_subtype_check);
%}

// ============================================================================
// inlined locking and unlocking

instruct cmpFastLock(cmpOpU cmp, gRegP oop, gRegP box, label labl, gr28_gRegP scratch1, gr29_gRegP scratch2, gr30_gRegP scratch3, pr6_pReg pr) %{
  match(If cmp (FastLock oop box));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  effect(USE cmp, USE oop, USE box, USE labl, KILL scratch1, KILL scratch2, KILL scratch3, KILL pr);
  ins_cost(100);

  format %{ "FASTLOCK $oop,$box,PR6\t// KILL GR28, GR29, GR30\n\t"
            "(PR6) BR $labl" %}

  ins_encode( emit_compiler_fast_lock(cmp, oop, GR30, box, GR28, GR29, PR6, labl) );
  ins_pipe(long_memory_op);
%}

instruct cmpFastUnlock(cmpOpU cmp, gRegP oop, gRegP box, label labl, gr28_gRegP scratch1, gr29_gRegP scratch2, gr30_gRegP scratch3, pr6_pReg pr) %{
  match(If cmp (FastUnlock oop box));
  predicate( _kids[0]->_leaf->is_Bool()->_test._test == BoolTest::ne );
  effect(USE cmp, USE oop, USE box, USE labl, KILL scratch1, KILL scratch2, KILL scratch3, KILL pr);
  ins_cost(100);

  format %{ "FASTUNLOCK $oop,$box,PR6\t// KILL GR28, GR29, GR30\n\t"
            "(PR6) BR $labl" %}
  ins_encode( emit_compiler_fast_unlock(cmp, oop, GR30, box, GR28, GR29, PR6, labl) );
  ins_pipe(long_memory_op);
%}

instruct inlineCallClearArray( gRegI cnt, gRegP base, gr28_gRegP scratch1, gr29_gRegP scratch2, gr30_gRegL scratch3, pr6_pReg pr, gRegI dummy) %{
  match(Set dummy (ClearArray cnt base));
  effect(KILL scratch1, KILL scratch2, KILL scratch3, KILL pr);
  ins_cost(300);
  format %{ "EXTR   GR30=$cnt,1,31\t// ClearArray\n\t"
            "MOV    GR28=$base\n\t"
            "CMP.le PR6,PR0=$cnt,0 ;;\t// skip if count <= 0\n\t"
            "SUB    GR30=GR30,1\n\t"
            "ADD    GR29=GR28,8\n\t"
            "(PR6) BR skip_all ;;\n\t"
            "CMP.ls PR6,PR0=GR30,0\t// skip if loop count < 0\n\t"
            "(PR6) BR skip_loop ;;\n"
          "loop_start:\n\t"
            "CMP.ne PR6,PR0=GR30,0\n\t"
            "ST8    [GR28]=GR0,16\t// store 0, post-increment\n\t"
            "ST8    [GR29]=GR0,16 ;;\t// store 0, post-increment\n\t"
            "(PR6) SUB GR30=GR30,1\n\t"
            "(PR6) BR loop_start ;;\n"
          "skip_loop:\n\t"
            "EXTR.U GR30=$cnt,0,1 ;;\n\t"
            "CMP.ne PR6,PR0=GR30,0\t// skip store if count == 0\n\t"
            "(PR6) ST8 [GR28]=GR0\t// store 0\n"
          "skip_all:" %}
  ins_encode( enc_Clear_Array(cnt, base, GR28, GR29, GR30, PR6 ) );
  ins_pipe(long_memory_op);
%}

instruct string_compare(gRegI dst, gRegP_notmp src1, gRegP_notmp src2, gr2_gRegP tmp1, gr3_gRegP tmp2, gr28_gRegP tmp3, gr29_gRegP tmp4, gr30_gRegP tmp5, gr31_gRegP tmp6, pr6_pReg pr6, pr7_pReg pr7) %{
  match(Set dst (StrComp src1 src2));
  effect(KILL tmp1, KILL tmp2, KILL tmp3, KILL tmp4, KILL tmp5, KILL tmp6, KILL pr6, KILL pr7);
  ins_cost(300);

  format %{ "String Compare $src1,$src2 -> $dst " %}
  ins_encode( enc_String_Compare(dst, src1, src2, GR2, GR3, GR28, GR29, GR30, GR31, PR6, PR7) );
  ins_pipe(long_memory_op);
%}


// ============================================================================


//----------PEEPHOLE RULES-----------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.
// 
// peepmatch ( root_instr_name [preceeding_instruction]* );
//
// peepconstraint %{
// (instruction_number.operand_name relational_op instruction_number.operand_name
//  [, ...] );
// // instruction numbers are zero-based using left to right order in peepmatch
//
// peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
// // provide an instruction_number.operand_name for each operand that appears
// // in the replacement instruction's match rule
//
// ---------VM FLAGS---------------------------------------------------------
// 
// All peephole optimizations can be turned off using -XX:-OptoPeephole
// 
// Each peephole rule is given an identifying number starting with zero and
// increasing by one in the order seen by the parser.  An individual peephole
// can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
// on the command-line.
// 
// ---------CURRENT LIMITATIONS----------------------------------------------
// 
// Only match adjacent instructions in same basic block
// Only equality constraints
// Only constraints between operands, not (0.dest_reg == EAX_enc)
// Only one replacement instruction
//
// ---------EXAMPLE----------------------------------------------------------
//
// // pertinent parts of existing instructions in architecture description
// instruct movI(eRegI dst, eRegI src) %{
//   match(Set dst (CopyI src));
// %}
// 
// instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg flags) %{
//   match(Set dst (AddI dst src));
//   effect(KILL flags);
// %}
// 
// // Change (inc mov) to lea
// peephole %{
//   // increment preceeded by register-register move
//   peepmatch ( incI_eReg movI );
//   // require that the destination register of the increment 
//   // match the destination register of the move
//   peepconstraint ( 0.dst == 1.dst );
//   // construct a replacement instruction that sets
//   // the destination to ( move's source register + one )
//   peepreplace ( incI_eReg_immI1( 0.dst 1.src 0.src ) );
// %}
// 

// // Change load of spilled value to only a spill
// instruct storeI(memory mem, eRegI src) %{
//   match(Set mem (StoreI mem src));
// %}
// 
// instruct loadI(eRegI dst, memory mem) %{
//   match(Set dst (LoadI mem));
// %}
// 
// peephole %{
//   peepmatch ( loadI storeI );
//   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
//   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
// %}

//----------SMARTSPILL RULES---------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.
//
// IA64 will probably not have any of these rules due to RISC instruction set.
